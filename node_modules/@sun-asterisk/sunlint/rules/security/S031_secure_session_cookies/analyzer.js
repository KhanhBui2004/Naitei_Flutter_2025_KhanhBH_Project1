/**
 * S031 Main Analyzer - Set Secure flag for Session Cookies
 * Uses symbol-based analysis only (regex-based removed)
 * Command: node cli.js --rule=S031 --input=examples/rule-test-fixtures/rules/S031_secure_session_cookies --engine=heuristic
 */

const S031SymbolBasedAnalyzer = require("./symbol-based-analyzer.js");

class S031Analyzer {
  constructor(options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`üîß [S031] Constructor called with options:`, !!options);
      console.log(
        `üîß [S031] Options type:`,
        typeof options,
        Object.keys(options || {})
      );
    }

    this.ruleId = "S031";
    this.ruleName = "Set Secure flag for Session Cookies";
    this.description =
      "Set Secure flag for Session Cookies to protect via HTTPS. This ensures cookies are only transmitted over secure connections, preventing interception.";
    this.semanticEngine = options.semanticEngine || null;
    this.verbose = options.verbose || false;

    // Initialize symbol analyzer only
    try {
      this.symbolAnalyzer = new S031SymbolBasedAnalyzer(this.semanticEngine);
      if (process.env.SUNLINT_DEBUG) {
        console.log(`üîß [S031] Symbol analyzer created successfully`);
      }
    } catch (error) {
      console.error(`üîß [S031] Error creating symbol analyzer:`, error);
    }

    if (process.env.SUNLINT_DEBUG) {
      console.log(`üîß [S031] Constructor completed`);
    }
  }

  /**
   * Initialize analyzer with semantic engine
   */
  async initialize(semanticEngine = null) {
    if (semanticEngine) {
      this.semanticEngine = semanticEngine;
    }
    this.verbose = semanticEngine?.verbose || false;

    // Initialize symbol analyzer
    if (this.symbolAnalyzer) {
      await this.symbolAnalyzer.initialize?.(semanticEngine);
    }

    // Ensure verbose flag is propagated
    if (this.symbolAnalyzer) {
      this.symbolAnalyzer.verbose = this.verbose;
    }

    if (this.verbose) {
      console.log(
        `üîß [S031] Analyzer initialized - verbose: ${this.verbose}`
      );
    }
  }

  /**
   * Single file analysis method for testing
   */
  analyzeSingle(filePath, options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`üîç [S031] analyzeSingle() called for: ${filePath}`);
    }

    // Return result using same format as analyze method
    return this.analyze([filePath], "typescript", options);
  }

  async analyze(files, language, options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(
        `üîß [S031] analyze() method called with ${files.length} files, language: ${language}`
      );
    }

    const violations = [];

    for (const filePath of files) {
      try {
        if (process.env.SUNLINT_DEBUG) {
          console.log(`üîß [S031] Processing file: ${filePath}`);
        }

        const fileViolations = await this.analyzeFile(filePath, options);
        violations.push(...fileViolations);

        if (process.env.SUNLINT_DEBUG) {
          console.log(
            `üîß [S031] File ${filePath}: Found ${fileViolations.length} violations`
          );
        }
      } catch (error) {
        console.warn(
          `‚ö† [S031] Analysis failed for ${filePath}:`,
          error.message
        );
      }
    }

    if (process.env.SUNLINT_DEBUG) {
      console.log(`üîß [S031] Total violations found: ${violations.length}`);
    }

    return violations;
  }

  async analyzeFile(filePath, options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`üîç [S031] analyzeFile() called for: ${filePath}`);
    }

    // Create a Map to track unique violations and prevent duplicates
    const violationMap = new Map();

    // Symbol-based analysis only
    if (this.semanticEngine?.project && this.semanticEngine?.initialized) {
      try {
        if (process.env.SUNLINT_DEBUG) {
          console.log(`üîß [S031] Running symbol-based analysis...`);
        }
        const sourceFile = this.semanticEngine.project.getSourceFile(filePath);
        if (sourceFile) {
          if (process.env.SUNLINT_DEBUG) {
            console.log(
              `üîß [S031] Source file found, analyzing with symbol-based...`
            );
          }

          const violations = await this.symbolAnalyzer.analyze(
            sourceFile,
            filePath
          );

          // Add violations to map to deduplicate and add filePath
          violations.forEach((v) => {
            const key = `${v.line}:${v.column}:${v.message}`;
            if (!violationMap.has(key)) {
              v.analysisStrategy = "symbol-based";
              v.filePath = filePath;
              v.file = filePath; // Also add 'file' for compatibility
              violationMap.set(key, v);
            }
          });

          if (process.env.SUNLINT_DEBUG) {
            console.log(
              `‚úÖ [S031] Symbol-based analysis: ${violations.length} violations`
            );
          }

          const finalViolations = Array.from(violationMap.values());
          return finalViolations; // Return deduplicated violations with filePath
        } else {
          if (process.env.SUNLINT_DEBUG) {
            console.log(`‚ö†Ô∏è [S031] Source file not found in project`);
          }
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è [S031] Symbol analysis failed: ${error.message}`);
      }
    } else {
      if (process.env.SUNLINT_DEBUG) {
        console.log(`üîÑ [S031] Symbol analysis conditions check:`);
        console.log(`  - semanticEngine: ${!!this.semanticEngine}`);
        console.log(
          `  - semanticEngine.project: ${!!this.semanticEngine?.project}`
        );
        console.log(
          `  - semanticEngine.initialized: ${this.semanticEngine?.initialized}`
        );
        console.log(`üîÑ [S031] Symbol analysis unavailable`);
      }
    }

    if (process.env.SUNLINT_DEBUG) {
      console.log(`üîß [S031] Analysis completed: ${violationMap.size} violations`);
    }
    return Array.from(violationMap.values());
  }

  /**
   * Methods for compatibility with different engine invocation patterns
   */
  async analyzeFileWithSymbols(filePath, options = {}) {
    return this.analyzeFile(filePath, options);
  }

  async analyzeWithSemantics(filePath, options = {}) {
    return this.analyzeFile(filePath, options);
  }

  /**
   * Get analyzer metadata
   */
  getMetadata() {
    return {
      rule: "S031",
      name: "Set Secure flag for Session Cookies",
      category: "security",
      type: "symbol-based",
      description:
        "Uses symbol-based analysis to detect session cookies missing Secure flag",
    };
  }
}

module.exports = S031Analyzer;
