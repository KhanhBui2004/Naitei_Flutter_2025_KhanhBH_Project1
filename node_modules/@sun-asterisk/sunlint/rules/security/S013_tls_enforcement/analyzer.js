// Command: node cli.js --rule=S013 --input=examples/rule-test-fixtures/rules/S013_tls_enforcement --engine=heuristic

const S013SymbolBasedAnalyzer = require("./symbol-based-analyzer");

class S013Analyzer {
  constructor(options = {}) {
    this.ruleId = "S013";
    this.semanticEngine = options.semanticEngine || null;
    this.verbose = options.verbose || false;

    try {
      this.symbolAnalyzer = new S013SymbolBasedAnalyzer(this.semanticEngine);
    } catch (e) {
      console.warn(`⚠ [S013] Failed to create symbol analyzer: ${e.message}`);
    }
  }

  async initialize(semanticEngine) {
    this.semanticEngine = semanticEngine;
    if (this.symbolAnalyzer && this.symbolAnalyzer.initialize) {
      await this.symbolAnalyzer.initialize(semanticEngine);
    }
  }

  analyzeSingle(filePath, options = {}) {
    return this.analyze([filePath], "typescript", options);
  }

  async analyze(files, language, options = {}) {
    const violations = [];
    for (const filePath of files) {
      try {
        const vs = await this.analyzeFile(filePath, options);
        violations.push(...vs);
      } catch (e) {
        console.warn(`⚠ [S013] Analysis error for ${filePath}: ${e.message}`);
      }
    }
    return violations;
  }

  async analyzeFile(filePath, options = {}) {
    const violationMap = new Map();

    if (!this.symbolAnalyzer) {
      return [];
    }

    try {
      let sourceFile = null;
      if (this.semanticEngine?.project) {
        sourceFile = this.semanticEngine.project.getSourceFile(filePath);
      }

      if (!sourceFile) {
        // create temporary ts-morph source file
        const fs = require("fs");
        const path = require("path");
        const { Project } = require("ts-morph");
        if (!fs.existsSync(filePath)) {
          throw new Error(`File not found: ${filePath}`);
        }
        const content = fs.readFileSync(filePath, "utf8");
        const tmp = new Project({
          useInMemoryFileSystem: true,
          compilerOptions: { allowJs: true },
        });
        sourceFile = tmp.createSourceFile(path.basename(filePath), content);
      }

      if (sourceFile) {
        const symbolViolations = await this.symbolAnalyzer.analyze(
          sourceFile,
          filePath
        );
        symbolViolations.forEach((v) => {
          const key = `${v.line}:${v.column}:${v.message}`;
          if (!violationMap.has(key)) violationMap.set(key, v);
        });
      }
    } catch (e) {
      console.warn(`⚠ [S013] Symbol analysis failed: ${e.message}`);
    }

    return Array.from(violationMap.values()).map((v) => ({
      ...v,
      filePath,
      file: filePath,
    }));
  }

  cleanup() {
    if (this.symbolAnalyzer?.cleanup) {
      this.symbolAnalyzer.cleanup();
    }
  }
}

module.exports = S013Analyzer;
