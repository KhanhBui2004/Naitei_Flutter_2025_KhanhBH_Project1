const fs = require('fs');
const path = require('path');

class S027CategorizedAnalyzer {
  constructor() {
    this.ruleId = 'S027';
    this.ruleName = 'No Hardcoded Secrets (Categorized)';
    this.description = 'Phát hiện thông tin bảo mật theo categories với độ ưu tiên khác nhau';
    
    // Load categories config
    this.config = this.loadConfig();
    this.categories = this.config.categories;
    this.globalExcludePatterns = this.config.global_exclude_patterns.map(p => new RegExp(p, 'i'));
    this.minLength = this.config.min_length || 8;
    this.maxLength = this.config.max_length || 1000;
    
    // Compile patterns for performance
    this.compilePatterns();
  }
  
  loadConfig() {
    const configPath = path.join(__dirname, 'categories.json');
    try {
      const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
      return config.S027;
    } catch (error) {
      console.error('Failed to load S027 categories config:', error.message);
      return { categories: [], global_exclude_patterns: [] };
    }
  }
  
  compilePatterns() {
    this.categories.forEach(category => {
      category.compiledPatterns = category.patterns.map(p => ({
        regex: new RegExp(p, 'gm'),
        original: p
      }));
      
      if (category.exclude_patterns) {
        category.compiledExcludePatterns = category.exclude_patterns.map(p => new RegExp(p, 'i'));
      }
    });
  }
  
  async analyze(files, language, options = {}) {
    const violations = [];
    this.currentFilePath = '';
    
    for (const filePath of files) {
      // Skip build/dist/node_modules
      if (this.shouldSkipFile(filePath)) {
        continue;
      }
      
      this.currentFilePath = filePath;
      
      try {
        const content = fs.readFileSync(filePath, 'utf8');
        const fileViolations = this.analyzeFile(content, filePath);
        violations.push(...fileViolations);
      } catch (error) {
        if (options.verbose) {
          console.error(`Error analyzing ${filePath}:`, error.message);
        }
      }
    }
    
    return violations;
  }
  
  shouldSkipFile(filePath) {
    const skipPatterns = [
      'build/', 'dist/', 'node_modules/', '.git/',
      'coverage/', '.next/', '.cache/', 'tmp/',
      '.lock', '.log', '.min.js', '.bundle.js'
    ];

    // Skip test files completely - they often contain mock/fake credentials
    const testPatterns = [
      /\.spec\.(ts|tsx|js|jsx)$/,
      /\.test\.(ts|tsx|js|jsx)$/,
      /__tests__\//,
      /__mocks__\//,
      /\/tests?\//,
      /\/fixtures?\//,
      /\/factories\//,        // Test factories
      /setupTests\./,
      /testSetup\./,
    ];

    if (testPatterns.some(pattern => pattern.test(filePath))) {
      return true;
    }

    return skipPatterns.some(pattern => filePath.includes(pattern));
  }
  
  analyzeFile(content, filePath) {
    const violations = [];
    // Handle different line endings (Windows \r\n, Unix \n, Mac \r)
    const lines = content.split(/\r?\n/);
    
    // Check if this is a test file for context
    const isTestFile = this.isTestFile(filePath);
    
    lines.forEach((line, index) => {
      const lineNumber = index + 1;
      const trimmedLine = line.trim();
      
      // Skip comments and imports
      if (this.isCommentOrImport(trimmedLine)) {
        return;
      }
      
      // Skip NEXT_PUBLIC_ environment variables - these are public by design
      if (this.isPublicEnvironmentVariable(line)) {
        return;
      }

      // Check global exclude patterns first
      if (this.matchesGlobalExcludes(line)) {
        return;
      }

      // Check each category
      this.categories.forEach(category => {
        const categoryViolations = this.checkCategory(
          category, line, lineNumber, filePath, isTestFile
        );
        violations.push(...categoryViolations);
      });
    });
    
    return violations;
  }
  
  isTestFile(filePath) {
    const testPatterns = [
      /\.(test|spec)\./i,
      /__tests__/i,
      /\/tests?\//i,
      /\/spec\//i,
      /setupTests/i,
      /testSetup/i,
      /test[-_]/i,  // Matches test- or test_
      /^.*\/test[^\/]*\.js$/i  // Matches files starting with test
    ];
    
    return testPatterns.some(pattern => pattern.test(filePath));
  }
  
  isCommentOrImport(line) {
    return line.startsWith('//') || line.startsWith('/*') || 
           line.startsWith('import') || line.startsWith('export') ||
           line.startsWith('*') || line.startsWith('<');
  }
  
  matchesGlobalExcludes(line) {
    return this.globalExcludePatterns.some(pattern => pattern.test(line));
  }

  isPublicEnvironmentVariable(line) {
    // NEXT_PUBLIC_, REACT_APP_, VITE_, PUBLIC_ prefixed env vars are public by design
    // These are intentionally exposed to the client-side and are not secrets
    const publicEnvPatterns = [
      /NEXT_PUBLIC_[A-Z0-9_]+\s*[:=]/i,      // Next.js public env vars
      /REACT_APP_[A-Z0-9_]+\s*[:=]/i,        // Create React App public env vars
      /VITE_[A-Z0-9_]+\s*[:=]/i,             // Vite public env vars
      /PUBLIC_[A-Z0-9_]+\s*[:=]/i,           // Generic public prefix
      /EXPO_PUBLIC_[A-Z0-9_]+\s*[:=]/i,      // Expo public env vars
    ];

    return publicEnvPatterns.some(pattern => pattern.test(line));
  }

  isEnvironmentVariableUsage(line) {
    // Patterns that indicate environment variable or config service usage - these are SAFE
    const safePatterns = [
      /process\.env\./i,                    // process.env.DB_PASSWORD
      /configService\.get/i,                // configService.get('DB_PASSWORD')
      /config\.get/i,                       // config.get('API_KEY')
      /getConfig\(/i,                       // getConfig('secret')
      /env\(['"]([^'"]+)['"]\)/i,          // env('SECRET_KEY')
      /process\.env\[['"]([^'"]+)['"]\]/i, // process.env['API_KEY']
      /import\.meta\.env\./i,              // import.meta.env.VITE_API_KEY
      /Deno\.env\.get/i,                   // Deno.env.get()
      /os\.getenv/i,                       // Python os.getenv()
      /System\.getenv/i,                   // Java System.getenv()
    ];

    return safePatterns.some(pattern => pattern.test(line));
  }

  checkCategory(category, line, lineNumber, filePath, isTestFile) {
    const violations = [];
    
    category.compiledPatterns.forEach(({ regex, original }) => {
      let match;
      
      // Reset regex lastIndex for global patterns
      regex.lastIndex = 0;
      
      while ((match = regex.exec(line)) !== null) {
        const matchedText = match[0];
        const column = match.index + 1;
        
        // Check length constraints
        if (matchedText.length < this.minLength || matchedText.length > this.maxLength) {
          continue;
        }
        
        // Check category-specific excludes
        if (category.compiledExcludePatterns &&
            category.compiledExcludePatterns.some(pattern => pattern.test(matchedText))) {
          continue;
        }

        // Check if this uses environment variables or config services - SAFE patterns
        if (this.isEnvironmentVariableUsage(line)) {
          continue;
        }

        // Be more lenient in test files - skip all but critical severity
        // Test files commonly use hardcoded values for testing purposes
        if (isTestFile && (category.severity === 'low' || category.severity === 'medium' || category.severity === 'high')) {
          continue;
        }
        
        violations.push({
          file: filePath,
          line: lineNumber,
          column: column,
          message: `[${category.name}] Potential ${category.severity} security risk: '${matchedText}'. ${category.description}`,
          severity: this.mapSeverity(category.severity),
          ruleId: this.ruleId,
          category: category.name,
          categoryDescription: category.description,
          matchedPattern: original,
          matchedText: matchedText
        });
      }
    });
    
    return violations;
  }
  
  mapSeverity(categorySeverity) {
    const severityMap = {
      'critical': 'error',
      'high': 'warning', 
      'medium': 'warning',
      'low': 'info'
    };
    
    return severityMap[categorySeverity] || 'warning';
  }
  
  // Method for getting category statistics
  getCategoryStats(violations) {
    const stats = {};
    
    violations.forEach(violation => {
      const category = violation.category;
      if (!stats[category]) {
        stats[category] = {
          count: 0,
          severity: violation.severity,
          files: new Set()
        };
      }
      stats[category].count++;
      stats[category].files.add(violation.file);
    });
    
    // Convert Set to array for JSON serialization
    Object.keys(stats).forEach(category => {
      stats[category].files = Array.from(stats[category].files);
      stats[category].fileCount = stats[category].files.length;
    });
    
    return stats;
  }
  
  // Method for filtering by category
  filterByCategory(violations, categoryNames) {
    if (!categoryNames || categoryNames.length === 0) {
      return violations;
    }
    
    return violations.filter(violation => 
      categoryNames.includes(violation.category)
    );
  }
  
  // Method for filtering by severity
  filterBySeverity(violations, minSeverity = 'info') {
    const severityOrder = ['info', 'warning', 'error'];
    const minIndex = severityOrder.indexOf(minSeverity);
    
    if (minIndex === -1) return violations;
    
    return violations.filter(violation => {
      const violationIndex = severityOrder.indexOf(violation.severity);
      return violationIndex >= minIndex;
    });
  }
}

module.exports = S027CategorizedAnalyzer;
