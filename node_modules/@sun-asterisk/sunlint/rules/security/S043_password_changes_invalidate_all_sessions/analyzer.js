/**
 * S043 Password changes must invalidate all other login sessions
 * Primary: Symbol-based analysis (when available)
 * Fallback: Regex-based for all other cases
 * Purpose: Ensure attackers cannot continue using old session tokens after a password change. Enforce correct access control after sensitive updates.
 * Command: node cli.js --rule=S043 --input=examples/rule-test-fixtures/rules/S043_password_changes_invalidate_all_sessions --engine=heuristic --verbose
 */

const S043SymbolBasedAnalyzer = require("./symbol-based-analyzer.js");

class S043Analyzer {
  constructor(options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`üîß [S043] Constructor called with options:`, !!options);
      console.log(
        `üîß [S043] Options type:`,
        typeof options,
        Object.keys(options || {})
      );
    }

    this.ruleId = "S043";
    this.ruleName = "Password changes must invalidate all other login sessions";
    this.description =
      "Ensure attackers cannot continue using old session tokens after a password change. Enforce correct access control after sensitive updates.";
    this.semanticEngine = options.semanticEngine || null;
    this.verbose = options.verbose || false;

    this.config = {
      useSymbolBased: true,
      fallbackToRegex: false,
      regexBasedOnly: false,
      fallbackToSymbol: true, // Allow symbol analysis even without semantic engine
    };

    try {
      this.symbolAnalyzer = new S043SymbolBasedAnalyzer(this.semanticEngine);
      if (process.env.SUNLINT_DEBUG)
        console.log(`üîß [S043] Symbol analyzer created successfully`);
    } catch (error) {
      console.error(`üîß [S043] Error creating symbol analyzer:`, error);
    }
  }

  async initialize(semanticEngine = null) {
    if (semanticEngine) {
      this.semanticEngine = semanticEngine;
    }
    this.verbose = semanticEngine?.verbose || false;

    // Initialize both analyzers
    await this.symbolAnalyzer.initialize(semanticEngine);

    // Ensure verbose flag is propagated
    this.symbolAnalyzer.verbose = this.verbose;

    if (this.verbose) {
      console.log(`üîß [S043 Hybrid] Analyzer initialized - verbose: ${this.verbose}`);
    }
  }

  analyzeSingle(filePath, options = {}) {
    if (process.env.SUNLINT_DEBUG)
      console.log(`üîç [S043] analyzeSingle() called for: ${filePath}`);
    return this.analyze([filePath], "typescript", options);
  }

  async analyze(files, language, options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`üîß [S043] analyze() method called with ${files.length} files, language: ${language}`);
    }

    const violations = [];

    for (const filePath of files) {
      try {
        if (process.env.SUNLINT_DEBUG) {
          console.log(`üîß [S043] Processing file: ${filePath}`);
        }

        const fileViolations = await this.analyzeFile(filePath, options);
        violations.push(...fileViolations);

        if (process.env.SUNLINT_DEBUG) {
          console.log(`üîß [S043] File ${filePath}: Found ${fileViolations.length} violations`);
        }
      } catch (error) {
        console.warn(`‚ùå [S043] Analysis failed for ${filePath}:`, error.message);
      }
    }

    if (process.env.SUNLINT_DEBUG) {
      console.log(`üîß [S043] Total violations found: ${violations.length}`);
    }

    return violations;
  }

  async analyzeFile(filePath, options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`üîß [S043] analyzeFile() called for: ${filePath}`);
    }

    // 1. Try Symbol-based analysis first (primary)
    if (this.config.useSymbolBased &&
        this.semanticEngine?.project &&
        this.semanticEngine?.initialized) {
      try {
        if (process.env.SUNLINT_DEBUG) {
          console.log(`üîß [S043] Trying symbol-based analysis...`);
        }
        const sourceFile = this.semanticEngine.project.getSourceFile(filePath);
        if (sourceFile) {
          if (process.env.SUNLINT_DEBUG) {
            console.log(`üîß [S043] Source file found, analyzing with symbol-based...`);
          }
          const violations = await this.symbolAnalyzer.analyzeFileWithSymbols(filePath, { ...options, verbose: options.verbose });

          // Mark violations with analysis strategy
          violations.forEach(v => v.analysisStrategy = 'symbol-based');

          if (process.env.SUNLINT_DEBUG) {
            console.log(`‚úÖ [S043] Symbol-based analysis: ${violations.length} violations`);
          }
          return violations; // Return even if 0 violations - symbol analysis completed successfully
        } else {
          if (process.env.SUNLINT_DEBUG) {
            console.log(`‚ö†Ô∏è [S043] Source file not found in project`);
          }
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è [S043] Symbol analysis failed: ${error.message}`);
        // Continue to fallback
      }
    } else {
      if (process.env.SUNLINT_DEBUG) {
        console.log(`üîÑ [S043] Symbol analysis conditions check:`);
        console.log(`  - useSymbolBased: ${this.config.useSymbolBased}`);
        console.log(`  - semanticEngine: ${!!this.semanticEngine}`);
        console.log(`  - semanticEngine.project: ${!!this.semanticEngine?.project}`);
        console.log(`  - semanticEngine.initialized: ${this.semanticEngine?.initialized}`);
        console.log(`üîÑ [S043] Symbol analysis unavailable, using regex fallback`);
      }
    }

    if (options?.verbose) {
      console.log(`üîß [S043] No analysis methods succeeded, returning empty`);
    }
    return [];
  }
}

module.exports = S043Analyzer;
