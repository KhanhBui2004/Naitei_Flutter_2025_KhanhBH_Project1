/**
 * S014 - Enforce TLS 1.2 or 1.3 Only
 *
 * Main analyzer using symbol-based analysis to detect insecure TLS/SSL version usage.
 */
// Command: node cli.js --rule=S014 --input=examples/rule-test-fixtures/rules/S014_tls_version_enforcement --engine=heuristic

const S014SymbolBasedAnalyzer = require("./symbol-based-analyzer");

class S014Analyzer {
  constructor(options = {}) {
    this.ruleId = "S014";
    this.semanticEngine = options.semanticEngine || null;
    this.verbose = options.verbose || false;

    try {
      this.symbolAnalyzer = new S014SymbolBasedAnalyzer(this.semanticEngine);
    } catch (e) {
      console.warn(`⚠ [S014] Failed to create symbol analyzer: ${e.message}`);
    }
  }

  async initialize(semanticEngine) {
    this.semanticEngine = semanticEngine;
    if (this.symbolAnalyzer && this.symbolAnalyzer.initialize) {
      await this.symbolAnalyzer.initialize(semanticEngine);
    }
  }

  analyzeSingle(filePath, options = {}) {
    return this.analyze([filePath], "typescript", options);
  }

  async analyze(files, language, options = {}) {
    const violations = [];
    for (const filePath of files) {
      try {
        const vs = await this.analyzeFile(filePath, options);
        violations.push(...vs);
      } catch (e) {
        console.warn(`⚠ [S014] Error analyzing ${filePath}: ${e.message}`);
      }
    }
    return violations;
  }

  async analyzeFile(filePath, options = {}) {
    const violationMap = new Map();

    if (!this.symbolAnalyzer) {
      return [];
    }

    try {
      let sourceFile = null;
      if (this.semanticEngine?.project) {
        sourceFile = this.semanticEngine.project.getSourceFile(filePath);
      }

      if (!sourceFile) {
        // Create temporary ts-morph source file
        const fs = require("fs");
        const path = require("path");
        const { Project } = require("ts-morph");
        if (!fs.existsSync(filePath)) {
          throw new Error(`File not found: ${filePath}`);
        }
        const content = fs.readFileSync(filePath, "utf8");
        const tmp = new Project({
          useInMemoryFileSystem: true,
          compilerOptions: { allowJs: true },
        });
        sourceFile = tmp.createSourceFile(path.basename(filePath), content);
      }

      if (sourceFile) {
        const symbolViolations = await this.symbolAnalyzer.analyze(
          sourceFile,
          filePath
        );
        symbolViolations.forEach((v) => {
          // Use only line number as key to deduplicate multiple detections on same line
          const key = `${v.line}`;
          if (!violationMap.has(key)) {
            violationMap.set(key, v);
          } else {
            // Keep the more specific message if available
            const existing = violationMap.get(key);
            if (v.message.length > existing.message.length) {
              violationMap.set(key, v);
            }
          }
        });
      }
    } catch (err) {
      if (this.verbose) {
        console.warn(
          `⚠ [S014] Symbol analysis failed for ${filePath}:`,
          err.message
        );
      }
    }

    return Array.from(violationMap.values()).map((v) => ({
      ...v,
      filePath,
      file: filePath,
    }));
  }

  async cleanup() {
    if (this.symbolAnalyzer) {
      await this.symbolAnalyzer.cleanup?.();
    }
  }
}

module.exports = S014Analyzer;
