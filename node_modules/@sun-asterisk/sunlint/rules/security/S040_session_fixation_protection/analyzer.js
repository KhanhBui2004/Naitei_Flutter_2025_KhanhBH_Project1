const fs = require('fs');

class S040Analyzer {
  constructor() {
    this.ruleId = 'S040';
    this.ruleName = 'Session Fixation Protection';
  }

  async analyze(files, language, options = {}) {
    const violations = [];

    for (const filePath of files) {
      // Skip test files
      if (this.isTestFile(filePath)) {
        continue;
      }

      try {
        const content = fs.readFileSync(filePath, 'utf8');
        const fileViolations = this.analyzeFile(content, filePath);
        violations.push(...fileViolations);
      } catch (error) {
        if (options.verbose) {
          console.warn(`S040: Error analyzing ${filePath}:`, error.message);
        }
      }
    }

    return violations;
  }

  isTestFile(filePath) {
    const testPatterns = [
      /\.test\.(ts|tsx|js|jsx|php|py)$/,
      /\.spec\.(ts|tsx|js|jsx|php|py)$/,
      /__tests__\//,
      /__mocks__\//,
      /\/tests?\//,
    ];
    return testPatterns.some(p => p.test(filePath));
  }

  analyzeFile(content, filePath) {
    const violations = [];

    // Find login/authentication functions
    const loginFunctions = this.findLoginFunctions(content);

    loginFunctions.forEach(({ startLine, endLine, functionContent, functionName }) => {
      // Check if session is regenerated
      if (!this.hasSessionRegeneration(functionContent)) {
        violations.push({
          file: filePath,
          line: startLine,
          column: 1,
          message: `Login function '${functionName}' does not regenerate session - vulnerable to Session Fixation. Use session.regenerate(), req.session.regenerate(), or create new JWT token.`,
          severity: 2, // error
          ruleId: this.ruleId,
        });
      }
    });

    return violations;
  }

  findLoginFunctions(content) {
    const functions = [];
    const lines = content.split(/\r?\n/);

    // Patterns that indicate login/authentication functions
    const loginPatterns = [
      /(?:async\s+)?(?:function\s+)?(\w*login\w*|authenticate\w*|signin\w*)\s*\(/gi,
      /(?:const|let|var)\s+(\w*login\w*|authenticate\w*|signin\w*)\s*=\s*(?:async\s+)?\(/gi,
      /@Post\s*\(\s*['"`]\/?(login|signin|authenticate)/gi,
      /router\.\w+\s*\(\s*['"`]\/?(login|signin|authenticate)/gi,
    ];

    let currentFunction = null;
    let braceCount = 0;

    lines.forEach((line, index) => {
      // Check if this line starts a login function
      if (!currentFunction) {
        loginPatterns.forEach(pattern => {
          const match = line.match(pattern);
          if (match) {
            currentFunction = {
              startLine: index + 1,
              functionName: match[1] || 'anonymous',
              functionContent: '',
            };
            braceCount = 0;
          }
        });
      }

      if (currentFunction) {
        currentFunction.functionContent += line + '\n';

        // Count braces to find function end
        braceCount += (line.match(/\{/g) || []).length;
        braceCount -= (line.match(/\}/g) || []).length;

        if (braceCount === 0 && currentFunction.functionContent.includes('{')) {
          currentFunction.endLine = index + 1;
          functions.push(currentFunction);
          currentFunction = null;
        }
      }
    });

    return functions;
  }

  hasSessionRegeneration(functionContent) {
    // Patterns that indicate session regeneration
    const regenerationPatterns = [
      /session\.regenerate\s*\(/,
      /req\.session\.regenerate\s*\(/,
      /request\.session\.regenerate\s*\(/,
      /sessionStore\.regenerate\s*\(/,

      // Express-session
      /session\.destroy.*session\.save/s,
      /req\.session\.destroy.*new\s+session/s,

      // JWT token creation (new token after login)
      /jwt\.sign\s*\(/,
      /generateToken\s*\(/,
      /createToken\s*\(/,
      /signToken\s*\(/,

      // PHP session regeneration
      /session_regenerate_id\s*\(/,
      /session_destroy.*session_start/s,

      // Python Flask/Django
      /session\.regenerate\s*\(/,
      /session\.clear\s*\(.*session\[/s,
      /login_user.*renew=True/,

      // Passport.js (implicitly regenerates)
      /passport\.authenticate/,
      /req\.login\s*\(/,
    ];

    return regenerationPatterns.some(pattern => pattern.test(functionContent));
  }

  cleanup() {}
}

module.exports = S040Analyzer;
