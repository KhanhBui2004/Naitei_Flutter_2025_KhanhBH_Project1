/**
 * C019 ts-morph Analyzer - Log Level Usage
 *
 * Detects inappropriate use of ERROR log level for business logic errors.
 * Business logic errors (validation, not found, unauthorized, etc.) should use WARN or INFO.
 * System errors (database, network, crashes) should use ERROR.
 *
 * Following Rule C005: Single responsibility - log level detection only
 * Following Rule C006: Verb-noun naming
 */

const { Project, SyntaxKind, Node } = require('ts-morph');
const fs = require('fs');
const path = require('path');

class C019TsMorphAnalyzer {
  constructor(semanticEngine = null, options = {}) {
    this.ruleId = 'C019';
    this.ruleName = 'Log Level Usage';
    this.description = 'Detect inappropriate ERROR log level for business logic errors';
    this.semanticEngine = semanticEngine;
    this.project = null;
    this.verbose = false;

    // Load config
    this.config = this.loadConfig();
  }

  loadConfig() {
    try {
      const configPath = path.join(__dirname, 'config.json');
      const configData = fs.readFileSync(configPath, 'utf8');
      return JSON.parse(configData).config;
    } catch (error) {
      console.warn('[C019] Could not load config, using defaults');
      return {
        errorKeywords: ['not found', 'invalid', 'unauthorized', 'validation'],
        legitimateErrorKeywords: ['exception', 'crash', 'database', 'connection']
      };
    }
  }

  async initialize(semanticEngine = null) {
    if (semanticEngine) {
      this.semanticEngine = semanticEngine;
    }
    this.verbose = semanticEngine?.verbose || false;

    // Use semantic engine's project if available
    if (this.semanticEngine?.project) {
      this.project = this.semanticEngine.project;
      if (this.verbose) {
        console.log('[DEBUG] ðŸŽ¯ C019: Using semantic engine project');
      }
    } else {
      this.project = new Project({
        compilerOptions: {
          target: 99,
          module: 99,
          allowJs: true,
          checkJs: false,
          jsx: 2,
        },
      });
      if (this.verbose) {
        console.log('[DEBUG] ðŸŽ¯ C019: Created standalone ts-morph project');
      }
    }
  }

  async analyze(files, language, options = {}) {
    this.verbose = options.verbose || this.verbose;

    if (!this.project) {
      await this.initialize();
    }

    const violations = [];

    for (const filePath of files) {
      try {
        const fileViolations = await this.analyzeFile(filePath, options);
        violations.push(...fileViolations);
      } catch (error) {
        if (this.verbose) {
          console.warn(`[C019] Error analyzing ${filePath}:`, error.message);
        }
      }
    }

    return violations;
  }

  async analyzeFile(filePath, options = {}) {
    // Get or add source file
    let sourceFile = this.project.getSourceFile(filePath);

    if (!sourceFile && fs.existsSync(filePath)) {
      sourceFile = this.project.addSourceFileAtPath(filePath);
    }

    if (!sourceFile) {
      return [];
    }

    const violations = [];

    // Find all error-level log calls
    const errorLogCalls = this.findErrorLogCalls(sourceFile);

    for (const logCall of errorLogCalls) {
      const violation = this.checkLogCall(logCall, sourceFile);
      if (violation) {
        violations.push(violation);
      }
    }

    return violations;
  }

  /**
   * Find all log calls with ERROR level
   * Supports: logger.error(), console.error(), log.error(), etc.
   */
  findErrorLogCalls(sourceFile) {
    const errorCalls = [];

    // Find all call expressions
    const callExpressions = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);

    for (const call of callExpressions) {
      const expression = call.getExpression();

      // Check if it's a property access (logger.error, console.error, etc.)
      if (Node.isPropertyAccessExpression(expression)) {
        const methodName = expression.getName();

        // Check if method name is "error" or "e" (Log.e, Timber.e)
        if (methodName === 'error' || methodName === 'e') {
          const object = expression.getExpression().getText();

          // Common logger patterns
          const loggerPatterns = [
            'logger', 'log', 'console', 'Logger',
            'winston', 'bunyan', 'Log', 'Timber',
            '_logger', 'this.logger'
          ];

          if (loggerPatterns.some(pattern =>
            object.toLowerCase().includes(pattern.toLowerCase())
          )) {
            errorCalls.push({
              node: call,
              object: object,
              method: methodName,
              position: {
                line: call.getStartLineNumber(),
                column: call.getStart() - call.getStartLinePos() + 1
              }
            });
          }
        }
      }
    }

    return errorCalls;
  }

  /**
   * Check if error log call is inappropriate
   */
  checkLogCall(logCall, sourceFile) {
    // Skip if in catch block (legitimate exception handling)
    if (this.isInCatchBlock(logCall.node)) {
      return null;
    }

    // Get the log message (first argument)
    const args = logCall.node.getArguments();
    if (args.length === 0) {
      return null;
    }

    const messageArg = args[0];
    let messageText = '';

    // Extract message text
    if (Node.isStringLiteral(messageArg) || Node.isNoSubstitutionTemplateLiteral(messageArg)) {
      messageText = messageArg.getLiteralText();
    } else if (Node.isTemplateExpression(messageArg)) {
      messageText = messageArg.getText();
    } else {
      // Complex expression, get surrounding context
      const parent = logCall.node.getParent();
      if (parent) {
        messageText = parent.getText().substring(0, 200); // First 200 chars
      }
    }

    messageText = messageText.toLowerCase();

    // Check if message contains business logic error keywords
    const hasBusinessLogicError = this.config.errorKeywords.some(keyword =>
      messageText.includes(keyword.toLowerCase())
    );

    if (!hasBusinessLogicError) {
      return null; // Not a business logic error
    }

    // Check if it's actually a legitimate system error
    const hasLegitimateError = this.config.legitimateErrorKeywords.some(keyword =>
      messageText.includes(keyword.toLowerCase())
    );

    if (hasLegitimateError) {
      return null; // Legitimate system error
    }

    // This is a violation: business logic error using ERROR level
    return {
      ruleId: this.ruleId,
      message: `Log level "error" is inappropriate for business logic errors. Use "warn" or "info" for: ${this.extractKeyword(messageText)}`,
      severity: 'warning',
      filePath: sourceFile.getFilePath(),
      location: {
        start: {
          line: logCall.position.line,
          column: logCall.position.column
        },
        end: {
          line: logCall.node.getEndLineNumber(),
          column: logCall.node.getEnd() - logCall.node.getStartLinePos() + 1
        }
      },
      context: {
        logLevel: 'error',
        suggestedLevel: 'warn',
        logObject: logCall.object,
        messagePreview: messageText.substring(0, 50)
      }
    };
  }

  /**
   * Check if node is inside a catch block
   */
  isInCatchBlock(node) {
    let current = node.getParent();

    while (current) {
      if (Node.isCatchClause(current)) {
        return true;
      }
      current = current.getParent();
    }

    return false;
  }

  /**
   * Extract the matched keyword from message for better error message
   */
  extractKeyword(messageText) {
    for (const keyword of this.config.errorKeywords) {
      if (messageText.includes(keyword.toLowerCase())) {
        return keyword;
      }
    }
    return 'business logic error';
  }
}

module.exports = C019TsMorphAnalyzer;
