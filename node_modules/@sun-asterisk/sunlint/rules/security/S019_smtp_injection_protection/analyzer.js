/**
 * Rule S019: SMTP Injection Protection - Analyzer Wrapper
 *
 * This analyzer wraps the symbol-based analyzer to provide a consistent
 * interface for the SunLint engine.
 */
// Command: node cli.js --rule=S019 --input=examples/rule-test-fixtures/rules/S019_smtp_injection_protection --engine=heuristic

const fs = require("fs");
const path = require("path");
const { Project } = require("ts-morph");
const S019SymbolBasedAnalyzer = require("./symbol-based-analyzer");

class S019Analyzer {
  constructor(options = {}) {
    this.ruleId = "S019";
    this.semanticEngine = options.semanticEngine || null;
    this.symbolAnalyzer = new S019SymbolBasedAnalyzer(this.semanticEngine);
  }

  /**
   * Analyze multiple files
   */
  async analyze(files, language, options = {}) {
    const violations = [];

    for (const filePath of files) {
      try {
        const fileViolations = await this.analyzeFile(filePath, options);
        violations.push(...fileViolations);
      } catch (error) {
        console.error(
          `[S019] Error analyzing file ${filePath}:`,
          error.message
        );
      }
    }

    return violations;
  }

  /**
   * Analyze a single file
   */
  async analyzeFile(filePath, options = {}) {
    // Skip files that shouldn't be analyzed
    if (this.shouldSkipFile(filePath)) {
      return [];
    }

    try {
      // Check if file exists
      if (!fs.existsSync(filePath)) {
        return [];
      }

      const content = fs.readFileSync(filePath, "utf-8");

      // Try to get source file from semantic engine
      let sourceFile = this.semanticEngine?.project?.getSourceFile(filePath);

      // If not available, create a temporary ts-morph source file
      if (!sourceFile) {
        const tempProject = new Project({
          useInMemoryFileSystem: true,
          compilerOptions: {
            allowJs: true,
            noLib: true,
            target: 99, // ESNext
          },
        });

        sourceFile = tempProject.createSourceFile(
          path.basename(filePath),
          content
        );
      }

      // Run the symbol-based analyzer
      const symbolViolations = await this.symbolAnalyzer.analyze(
        sourceFile,
        filePath
      );

      // Format violations to include file path
      return symbolViolations.map((violation) => ({
        ...violation,
        filePath: filePath,
        file: filePath,
      }));
    } catch (error) {
      console.error(`[S019] Error processing ${filePath}:`, error.message);
      return [];
    }
  }

  /**
   * Check if file should be skipped
   */
  shouldSkipFile(filePath) {
    const skipPatterns = [
      "node_modules/",
      "dist/",
      "build/",
      ".next/",
      "coverage/",
      "__tests__/",
      "test/",
      "tests/",
      ".test.",
      ".spec.",
      ".min.js",
      ".bundle.js",
    ];

    return skipPatterns.some((pattern) => filePath.includes(pattern));
  }
}

module.exports = S019Analyzer;
