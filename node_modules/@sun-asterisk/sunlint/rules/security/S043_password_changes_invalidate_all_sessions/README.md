# S043 - Password Changes Must Invalidate All Active Sessions

## Overview

**Rule ID:** S043
**Severity:** Medium
**Category:** Security
**Status:** Activated
**Version:** 1.0

## Objective

Ensure that attackers cannot continue using old session tokens after a password change. This rule enforces correct access control after sensitive password updates by requiring all active sessions to be invalidated.

## Description

When a user changes their password, all existing session tokens, JWT tokens, and cached credentials must be invalidated immediately. This prevents attackers who may have compromised an old session from continuing to access the account after the password has been changed.

This rule performs **deep analysis** across multiple layers:
- **Controller → Service → Repository → Third Party**
- Traces up to 4 levels deep in the call chain
- Resolves NestJS dependency injection to follow service calls
- Detects session invalidation in any layer of the application

## Violation Criteria

A password change function is flagged if it does NOT:

1. Invalidate all other active sessions (except current if necessary)
2. Clear all session tokens from database, Redis, or memory storage
3. For JWT: use token versioning or timestamp to revoke old tokens
4. Require re-login across all devices
5. Call logout or sign out operations
6. Clear session cache (Redis, in-memory, etc.)
7. Use third-party auth service global sign out (AWS Cognito, Auth0, Firebase)

## Detected Patterns

### ✅ Session Invalidation (PASS)

The rule detects the following valid patterns:

#### 1. Direct Session Invalidation Calls
```typescript
await sessionService.invalidateAllSessions(userId);
await sessionService.clearAllSessions(userId);
await sessionService.destroyAllSessions(userId);
await sessionService.logoutAllDevices(userId);

### 2. Database Session Deletion
```typescript
await sessionRepository.delete({ userId });
await sessionRepository.deleteAllByUserId(userId);
await this.sessionRepository
  .createQueryBuilder()
  .delete()
  .where('userId = :userId', { userId })
  .execute();
```

### 3. JWT Token Versioning
```typescript
user.tokenVersion = (user.tokenVersion || 0) + 1;
user.tokenVersion++;
await userRepository.update(userId, {
  tokenVersion: () => 'tokenVersion + 1'
});
```

### 4. Redis/Cache Clearing
```typescript
await redis.del(`session:${userId}:*`);
await cacheManager.del(username);
await redisService.clearUserSessions(userId);
```

### Deep Analysis Features
```typescript
// File: auth.controller.ts
async changePassword(data) {
  await this.authService.changePassword(data); // ← Traces into service
}

// File: auth.service.ts (different file)
async changePassword(data) {
  await this.userRepo.updatePassword(data);
  await this.sessionService.clearAllSessions(data.userId); // ← Found! ✅
}
```

### NestJS Dependency Injection Resolution

```typescript
@Injectable()
export class AuthController {
  constructor(
    private readonly commonChangePasswordService: CommonChangePasswordService
  ) {}

  async changePassword() {
    // Resolves: commonChangePasswordService → CommonChangePasswordService class
    await this.commonChangePasswordService.changePassword();
    // ↓ Deep traces into CommonChangePasswordService.changePassword() method
  }
}
```

