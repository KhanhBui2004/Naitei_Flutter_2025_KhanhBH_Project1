/**
 * C021 ts-morph Analyzer - Import Organization
 *
 * Enforces organized imports with proper grouping and sorting:
 * 1. Built-in modules (fs, path, etc.)
 * 2. External dependencies (express, axios, etc.)
 * 3. Internal modules (./utils, ../services, etc.)
 *
 * Within each group, imports should be sorted alphabetically.
 * Blank lines should separate groups.
 *
 * Following Rule C005: Single responsibility - import organization only
 * Following Rule C006: Verb-noun naming
 */

const { Project, SyntaxKind, Node } = require('ts-morph');
const fs = require('fs');
const path = require('path');

class C021TsMorphAnalyzer {
  constructor(semanticEngine = null, options = {}) {
    this.ruleId = 'C021';
    this.ruleName = 'Import Organization';
    this.description = 'Enforce organized imports with grouping and sorting';
    this.semanticEngine = semanticEngine;
    this.project = null;
    this.verbose = false;

    // Load config
    this.config = this.loadConfig();
  }

  loadConfig() {
    try {
      const configPath = path.join(__dirname, 'config.json');
      const configData = fs.readFileSync(configPath, 'utf8');
      return JSON.parse(configData).config;
    } catch (error) {
      console.warn('[C021] Could not load config, using defaults');
      return {
        groups: [
          {
            name: 'builtin',
            patterns: ['^(fs|path|http|https|crypto)$']
          },
          {
            name: 'external',
            patterns: ['^[^.]']
          },
          {
            name: 'internal',
            patterns: ['^\\\\.|^@/|^~/']
          }
        ],
        sortOrder: {
          groupOrder: ['builtin', 'external', 'internal'],
          withinGroup: 'alphabetical'
        },
        spacing: {
          requireBlankLineBetweenGroups: true
        }
      };
    }
  }

  async initialize(semanticEngine = null) {
    if (semanticEngine) {
      this.semanticEngine = semanticEngine;
    }
    this.verbose = semanticEngine?.verbose || false;

    // Use semantic engine's project if available
    if (this.semanticEngine?.project) {
      this.project = this.semanticEngine.project;
      if (this.verbose) {
        console.log('[DEBUG] ðŸŽ¯ C021: Using semantic engine project');
      }
    } else {
      this.project = new Project({
        compilerOptions: {
          target: 99,
          module: 99,
          allowJs: true,
          checkJs: false,
          jsx: 2,
        },
      });
      if (this.verbose) {
        console.log('[DEBUG] ðŸŽ¯ C021: Created standalone ts-morph project');
      }
    }
  }

  async analyze(files, language, options = {}) {
    this.verbose = options.verbose || this.verbose;

    if (!this.project) {
      await this.initialize();
    }

    const violations = [];

    for (const filePath of files) {
      try {
        const fileViolations = await this.analyzeFile(filePath, options);
        violations.push(...fileViolations);
      } catch (error) {
        if (this.verbose) {
          console.warn(`[C021] Error analyzing ${filePath}:`, error.message);
        }
      }
    }

    return violations;
  }

  async analyzeFile(filePath, options = {}) {
    // Get or add source file
    let sourceFile = this.project.getSourceFile(filePath);

    if (!sourceFile && fs.existsSync(filePath)) {
      sourceFile = this.project.addSourceFileAtPath(filePath);
    }

    if (!sourceFile) {
      return [];
    }

    const violations = [];

    // Get all import declarations
    const imports = sourceFile.getImportDeclarations();

    if (imports.length === 0) {
      return [];
    }

    // Organize imports into groups
    const importGroups = this.organizeImports(imports);

    // Check group order
    const orderViolations = this.checkGroupOrder(importGroups, imports);
    violations.push(...orderViolations);

    // Check sorting within groups
    const sortViolations = this.checkGroupSorting(importGroups);
    violations.push(...sortViolations);

    // Check spacing between groups
    const spacingViolations = this.checkGroupSpacing(importGroups, sourceFile);
    violations.push(...spacingViolations);

    return violations.map(v => ({
      ...v,
      filePath: sourceFile.getFilePath()
    }));
  }

  /**
   * Organize imports into groups based on config
   */
  organizeImports(imports) {
    const groups = {};

    // Initialize groups
    for (const groupConfig of this.config.groups) {
      groups[groupConfig.name] = [];
    }

    // Categorize each import
    for (const importDecl of imports) {
      const moduleSpecifier = importDecl.getModuleSpecifierValue();
      const groupName = this.categorizeImport(moduleSpecifier);

      if (groupName && groups[groupName]) {
        groups[groupName].push({
          node: importDecl,
          moduleSpecifier,
          line: importDecl.getStartLineNumber()
        });
      }
    }

    return groups;
  }

  /**
   * Categorize an import into a group
   */
  categorizeImport(moduleSpecifier) {
    for (const groupConfig of this.config.groups) {
      for (const pattern of groupConfig.patterns) {
        const regex = new RegExp(pattern);
        if (regex.test(moduleSpecifier)) {
          return groupConfig.name;
        }
      }
    }
    return null;
  }

  /**
   * Check if groups appear in correct order
   */
  checkGroupOrder(importGroups, allImports) {
    const violations = [];
    const expectedOrder = this.config.sortOrder.groupOrder;

    // Get actual order of groups
    const actualOrder = [];
    const groupFirstLines = new Map();

    for (const importInfo of allImports.map(imp => ({
      node: imp,
      moduleSpecifier: imp.getModuleSpecifierValue(),
      line: imp.getStartLineNumber()
    }))) {
      const groupName = this.categorizeImport(importInfo.moduleSpecifier);
      if (groupName && !groupFirstLines.has(groupName)) {
        groupFirstLines.set(groupName, importInfo.line);
        actualOrder.push(groupName);
      }
    }

    // Check if actual order matches expected order
    const expectedFiltered = expectedOrder.filter(g => actualOrder.includes(g));

    for (let i = 0; i < actualOrder.length; i++) {
      if (actualOrder[i] !== expectedFiltered[i]) {
        // Find the misplaced import
        const misplacedGroup = actualOrder[i];
        const imports = importGroups[misplacedGroup];

        if (imports && imports.length > 0) {
          violations.push({
            ruleId: this.ruleId,
            message: `Import group "${misplacedGroup}" should come ${this.getOrderMessage(misplacedGroup, expectedFiltered, i)}`,
            severity: 'info',
            location: {
              start: {
                line: imports[0].line,
                column: 1
              },
              end: {
                line: imports[0].line,
                column: 1
              }
            },
            context: {
              violationType: 'group-order',
              currentGroup: misplacedGroup,
              expectedOrder: expectedFiltered
            }
          });
        }
        break;
      }
    }

    return violations;
  }

  /**
   * Get descriptive message for group order violation
   */
  getOrderMessage(groupName, expectedOrder, currentIndex) {
    const expectedIndex = expectedOrder.indexOf(groupName);
    if (expectedIndex < currentIndex) {
      return `before "${expectedOrder[currentIndex]}" imports`;
    } else {
      return `after "${expectedOrder[currentIndex - 1]}" imports`;
    }
  }

  /**
   * Check sorting within each group
   */
  checkGroupSorting(importGroups) {
    const violations = [];

    for (const [groupName, imports] of Object.entries(importGroups)) {
      if (imports.length <= 1) continue;

      // Check if sorted alphabetically
      for (let i = 0; i < imports.length - 1; i++) {
        const current = imports[i].moduleSpecifier;
        const next = imports[i + 1].moduleSpecifier;

        if (current.toLowerCase() > next.toLowerCase()) {
          violations.push({
            ruleId: this.ruleId,
            message: `Import "${current}" should come after "${next}" (alphabetical order within ${groupName} group)`,
            severity: 'info',
            location: {
              start: {
                line: imports[i].line,
                column: 1
              },
              end: {
                line: imports[i].line,
                column: 1
              }
            },
            context: {
              violationType: 'sorting',
              group: groupName,
              currentImport: current,
              nextImport: next
            }
          });
        }
      }
    }

    return violations;
  }

  /**
   * Check spacing between groups
   */
  checkGroupSpacing(importGroups, sourceFile) {
    const violations = [];

    if (!this.config.spacing.requireBlankLineBetweenGroups) {
      return violations;
    }

    const expectedOrder = this.config.sortOrder.groupOrder;
    const nonEmptyGroups = expectedOrder.filter(groupName =>
      importGroups[groupName] && importGroups[groupName].length > 0
    );

    // Check spacing between consecutive groups
    for (let i = 0; i < nonEmptyGroups.length - 1; i++) {
      const currentGroup = importGroups[nonEmptyGroups[i]];
      const nextGroup = importGroups[nonEmptyGroups[i + 1]];

      const lastImportOfCurrentGroup = currentGroup[currentGroup.length - 1];
      const firstImportOfNextGroup = nextGroup[0];

      const lastLine = lastImportOfCurrentGroup.line;
      const nextLine = firstImportOfNextGroup.line;

      // Should have at least 1 blank line between groups
      if (nextLine - lastLine < 2) {
        violations.push({
          ruleId: this.ruleId,
          message: `Missing blank line between "${nonEmptyGroups[i]}" and "${nonEmptyGroups[i + 1]}" import groups`,
          severity: 'info',
          location: {
            start: {
              line: lastLine,
              column: 1
            },
            end: {
              line: nextLine,
              column: 1
            }
          },
          context: {
            violationType: 'spacing',
            currentGroup: nonEmptyGroups[i],
            nextGroup: nonEmptyGroups[i + 1]
          }
        });
      }
    }

    return violations;
  }
}

module.exports = C021TsMorphAnalyzer;
