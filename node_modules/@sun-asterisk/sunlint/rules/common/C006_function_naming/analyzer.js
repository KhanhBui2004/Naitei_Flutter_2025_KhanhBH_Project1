const fs = require('fs');
const path = require('path');
const ts = require('typescript');
const { CommentDetector } = require('../../utils/rule-helpers');

/**
 * SMART C006 ANALYZER - INTELLIGENT FUNCTION NAMING ANALYSIS
 * 
 * ðŸ§  5-TIER ANALYSIS APPROACH:
 * 1. Context Analysis: File path, imports, class context
 * 2. Semantic Analysis: Function body inspection for intent
 * 3. Architectural Layer Detection: UI, Logic, Data, Utils
 * 4. Natural Language Processing: Verb/noun classification
 * 5. Confidence Scoring: Multi-factor violation assessment
 */
class SmartC006Analyzer {
  constructor() {
    this.ruleId = 'C006';
    this.ruleName = 'Smart Function Naming Convention';
    this.description = 'Intelligent verb-noun naming pattern detection with context awareness';
    
    // ðŸŽ¯ CONFIDENCE THRESHOLDS
    this.confidenceThresholds = {
      HIGH: 0.8,    // Clear violations
      MEDIUM: 0.6,  // Likely violations  
      LOW: 0.4      // Potential violations
    };
    
    // ðŸ—‚ï¸ ARCHITECTURAL CONTEXT PATTERNS
    this.architecturalLayers = {
      UI: ['component', 'view', 'page', 'screen', 'modal', 'dialog'],
      DATA: ['service', 'repository', 'dao', 'api', 'client', 'adapter'],
      UTILS: ['util', 'helper', 'tool', 'lib', 'common'],
      LOGIC: ['controller', 'handler', 'processor', 'manager', 'engine']
    };
    
    // ðŸŽ­ SEMANTIC INTENT PATTERNS
    this.semanticPatterns = {
      // Return patterns indicate getters
      GETTER: [/return\s+[^;]+/, /=>\s*[^{]/, /\?\s*[^:]+:/],
      // Assignment patterns indicate setters
      SETTER: [/=\s*[^=]/, /\.push\(/, /\.set\(/],
      // Conditional patterns indicate checkers
      CHECKER: [/if\s*\(/, /\?\s*/, /return\s+(true|false)/],
      // Side effect patterns indicate actions
      ACTION: [/console\./, /fetch\(/, /\.send\(/, /\.post\(/]
    };

    // ðŸ“š COMPREHENSIVE VERB LIST (from C006 rule specification)
    this.acceptedVerbs = [
      // Getters/Queries
      'get', 'fetch', 'retrieve', 'find', 'search', 'query', 'load',
      // Setters/Modifiers
      'set', 'update', 'modify', 'change', 'edit', 'alter', 'transform',
      // Creation
      'create', 'build', 'make', 'generate', 'construct', 'produce',
      // Deletion
      'delete', 'remove', 'destroy', 'clean', 'clear', 'reset',
      // Validation
      'validate', 'verify', 'check', 'confirm', 'ensure', 'test', 'compare',
      // Computation
      'calculate', 'compute', 'parse', 'format', 'convert',
      // Communication
      'send', 'receive', 'transmit', 'broadcast', 'emit', 'publish',
      // Collections
      'map', 'filter', 'sort', 'group', 'merge', 'split', 'add', 'append', 'insert',
      'push', 'pop', 'shift', 'splice', 'unshift', 'slice', 'concat', 'join',
      // State checks (Boolean)
      'is', 'has', 'can', 'should', 'will', 'does', 'contains', 'includes', 'exists',
      // UI actions
      'show', 'hide', 'display', 'render', 'draw', 'toggle', 'enable', 'disable',
      'activate', 'deactivate', 'select', 'deselect', 'focus', 'blur',
      // Lifecycle
      'connect', 'disconnect', 'open', 'close', 'start', 'stop', 'run', 'refresh',
      'initialize', 'init', 'setup', 'teardown', 'shutdown', 'restart', 'reload',
      'restore', 'resume', 'pause', 'suspend',
      // Event Handling
      'on', 'trigger', 'fire', 'dispatch', 'invoke', 'call', 'emit', 'handle',
      // Monitoring
      'count', 'measure', 'monitor', 'watch', 'track', 'observe', 'log', 'record',
      // Navigation
      'navigate', 'redirect', 'route', 'go', 'move', 'scroll',
      // Data Operations
      'save', 'store', 'persist', 'cache', 'serialize', 'deserialize',
      // Detection/Analysis
      'detect', 'analyze', 'scan', 'inspect', 'evaluate', 'assess',
      // Computation & Transformation
      'calculate', 'compute', 'parse', 'format', 'convert',
      'normalize', 'sanitize', 'encode', 'decode', 'encrypt', 'decrypt',
      'compress', 'decompress', 'zip', 'unzip', 'tar', 'untar', // â† Add these
      'stringify', 'objectify',
      // State Management
      'apply', 'revert', 'undo', 'redo', 'commit', 'rollback',
      // Async Operations
      'await', 'defer', 'debounce', 'throttle', 'delay',
      // Error Handling
      'throw', 'catch', 'handle', 'recover', 'retry',
      // Copying/Cloning
      'copy', 'clone', 'duplicate', 'replicate',
      // Comparison
      'equals', 'match', 'differ', 'compare',
      // Registration
      'register', 'unregister', 'subscribe', 'unsubscribe',
      // Import/Export
      'import', 'export', 'download', 'upload',
      // Expansion/Collapse
      'expand', 'collapse', 'maximize', 'minimize',
      // Submission
      'submit', 'cancel', 'abort', 'complete', 'finish',
      // Preparation
      'prepare', 'ready', 'preload', 'precache',
      // Extraction
      'extract', 'derive', 'obtain', 'acquire',
      // Replacement
      'replace', 'swap', 'substitute', 'override',
      // Binding
      'bind', 'unbind', 'attach', 'detach',
      // Notification
      'notify', 'alert', 'warn', 'inform',
      // Execution
      'execute', 'perform', 'process', 'run'
    ];

    // âš ï¸ VAGUE/GENERIC VERBS TO FLAG (should have more specific verbs)
    this.vagueVerbs = [
      'do', 'handle', 'manage', 'process', 'execute', 'perform',
      'something', 'stuff', 'thing', 'work', 'data', 'item'
    ];
  }

  async analyze(files, language, config) {
    const violations = [];

    if (config.verbose) {
      console.log(`ðŸ”§ [DEBUG] Starting Smart C006 Analysis on ${files.length} files...`);
    }

    for (const filePath of files) {
      try {
        const fileContent = fs.readFileSync(filePath, 'utf8');
        const fileViolations = await this.analyzeFile(filePath, fileContent, language, config);
        violations.push(...fileViolations);
      } catch (error) {
        if (config.verbose) {
          console.error(`âš ï¸ [DEBUG] Error analyzing file ${filePath}:`, error.message);
        }
      }
    }

    if (config.verbose) {
      console.log(`ðŸ”§ [DEBUG] Smart C006 Analysis complete: ${violations.length} violations found`);
    }

    return violations;
  }

  async analyzeFile(filePath, content, language, config) {
    if (language !== 'typescript' && language !== 'javascript') {
      return []; // Focus on TS/JS for now
    }

    const violations = [];
    const lines = content.split('\n');

    // ðŸ—ï¸ TIER 1: ARCHITECTURAL CONTEXT ANALYSIS
    const architecturalContext = this.analyzeArchitecturalContext(filePath, content);

    // Parse TypeScript/JavaScript code
    const sourceFile = ts.createSourceFile(
      filePath,
      content,
      ts.ScriptTarget.Latest,
      true
    );

    const visit = (node) => {
      // Analyze function declarations
      if (ts.isFunctionDeclaration(node) && node.name && node.body) {
        const analysis = this.smartAnalyzeFunctionName(
          node.name.text,
          node,
          sourceFile,
          architecturalContext,
          content
        );

        if (analysis.isViolation && analysis.confidence >= this.confidenceThresholds.LOW) {
          const namePosition = sourceFile.getLineAndCharacterOfPosition(node.name.getStart());
          const line = namePosition.line + 1;
          const column = namePosition.character + 1;
          const lineText = lines[line - 1]?.trim() || '';

          violations.push({
            ruleId: this.ruleId,
            file: filePath,
            line,
            column,
            message: analysis.reason,
            severity: this.getSeverityFromConfidence(analysis.confidence),
            code: lineText,
            type: analysis.type,
            confidence: analysis.confidence,
            suggestion: analysis.suggestion,
            context: analysis.context
          });
        }
      }

      // Analyze method declarations
      if (ts.isMethodDeclaration(node) && node.name) {
        const analysis = this.smartAnalyzeFunctionName(
          node.name.text,
          node,
          sourceFile,
          architecturalContext,
          content
        );

        if (analysis.isViolation && analysis.confidence >= this.confidenceThresholds.LOW) {
          const namePosition = sourceFile.getLineAndCharacterOfPosition(node.name.getStart());
          const line = namePosition.line + 1;
          const column = namePosition.character + 1;
          const lineText = lines[line - 1]?.trim() || '';

          violations.push({
            ruleId: this.ruleId,
            file: filePath,
            line,
            column,
            message: analysis.reason,
            severity: this.getSeverityFromConfidence(analysis.confidence),
            code: lineText,
            type: analysis.type,
            confidence: analysis.confidence,
            suggestion: analysis.suggestion,
            context: analysis.context
          });
        }
      }

      // Analyze arrow functions assigned to variables
      if (ts.isVariableDeclaration(node) && node.name && ts.isIdentifier(node.name) &&
          node.initializer && ts.isArrowFunction(node.initializer)) {
        const analysis = this.smartAnalyzeFunctionName(
          node.name.text,
          node.initializer,
          sourceFile,
          architecturalContext,
          content
        );

        if (analysis.isViolation && analysis.confidence >= this.confidenceThresholds.LOW) {
          const namePosition = sourceFile.getLineAndCharacterOfPosition(node.name.getStart());
          const line = namePosition.line + 1;
          const column = namePosition.character + 1;
          const lineText = lines[line - 1]?.trim() || '';

          violations.push({
            ruleId: this.ruleId,
            file: filePath,
            line,
            column,
            message: analysis.reason,
            severity: this.getSeverityFromConfidence(analysis.confidence),
            code: lineText,
            type: analysis.type,
            confidence: analysis.confidence,
            suggestion: analysis.suggestion,
            context: analysis.context
          });
        }
      }

      ts.forEachChild(node, visit);
    };

    visit(sourceFile);
    return violations;
  }

  /**
   * ðŸ—ï¸ TIER 1: ARCHITECTURAL CONTEXT ANALYSIS
   * Determines what type of file/module this is
   */
  analyzeArchitecturalContext(filePath, content) {
    const fileName = path.basename(filePath, path.extname(filePath)).toLowerCase();
    const fileDir = path.dirname(filePath).toLowerCase();

    // Detect architectural layer
    let layer = 'UNKNOWN';
    for (const [layerName, patterns] of Object.entries(this.architecturalLayers)) {
      if (patterns.some(pattern => fileName.includes(pattern) || fileDir.includes(pattern))) {
        layer = layerName;
        break;
      }
    }

    // Analyze imports for additional context
    const imports = this.extractImports(content);
    const isReactComponent = imports.some(imp => imp.includes('react')) || content.includes('JSX.Element');
    const isTestFile = fileName.includes('test') || fileName.includes('spec');

    return {
      layer,
      isReactComponent,
      isTestFile,
      fileName,
      imports
    };
  }

  /**
   * ðŸ§  TIER 2: SEMANTIC ANALYSIS
   * Analyzes function body to understand intent
   */
  analyzeSemanticIntent(functionNode, sourceFile, content) {
    if (!functionNode.body) return 'UNKNOWN';

    const functionText = content.substring(
      functionNode.body.getStart(),
      functionNode.body.getEnd()
    );

    // Check for different semantic patterns
    for (const [intent, patterns] of Object.entries(this.semanticPatterns)) {
      if (patterns.some(pattern => pattern.test(functionText))) {
        return intent;
      }
    }

    return 'UNKNOWN';
  }

  /**
   * ðŸŽ¯ ENHANCED VERB DETECTION - FIXED VERSION
   * Properly detects verbs including compound verbs
   */
  extractVerbFromName(functionName) {
    // Convert to lowercase for comparison
    const lowerName = functionName.toLowerCase();

    // Find the longest matching verb from the accepted verbs list
    let matchedVerb = null;
    let maxLength = 0;

    for (const verb of this.acceptedVerbs) {
      // Check if function name starts with this verb
      // Must be followed by uppercase letter, end of string, or be exact match
      const verbPattern = new RegExp(`^${verb}([A-Z].*|$)`);

      if (verbPattern.test(functionName) && verb.length > maxLength) {
        matchedVerb = verb;
        maxLength = verb.length;
      }
    }

    return matchedVerb;
  }

  /**
   * ðŸŽ¯ CHECK IF NAME FOLLOWS VERB-NOUN PATTERN
   */
  isVerbNounPattern(functionName) {
    // Strategy 1: Extract verb from accepted verbs list
    const verb = this.extractVerbFromName(functionName);

    if (verb) {
      // Check if it's a vague verb (should be flagged even if technically a verb)
      const isVagueVerb = this.vagueVerbs.some(vague => {
        const vaguePattern = new RegExp(`^${vague}([A-Z].*|$)`, 'i');
        return vaguePattern.test(functionName);
      });

      if (isVagueVerb) {
        return { isValid: false, verb: null, reason: 'vague_verb' };
      }

      // Valid verb found
      return { isValid: true, verb, reason: null };
    }

    // Strategy 2: Check for verb-like patterns (morphology)
    const verbSuffixes = ['ize', 'ise', 'fy', 'ate', 'en', 'ing', 'ed'];
    for (const suffix of verbSuffixes) {
      const suffixPattern = new RegExp(`^[a-z]+${suffix}([A-Z].*|$)`, 'i');
      if (suffixPattern.test(functionName)) {
        return { isValid: true, verb: 'morphological', reason: null };
      }
    }

    // Strategy 3: Check for verb prefixes (re-, un-, pre-, de-, dis-)
    const verbPrefixes = ['re', 'un', 'pre', 'de', 'dis', 'over', 'under', 'out', 'up'];
    for (const prefix of verbPrefixes) {
      // Must be followed by a known verb or capital letter
      const prefixPattern = new RegExp(`^${prefix}[A-Z]`, 'i');
      if (prefixPattern.test(functionName)) {
        // Check if the part after prefix is a known verb
        const remainder = functionName.substring(prefix.length);
        const remainderVerb = this.extractVerbFromName(remainder);
        if (remainderVerb) {
          return { isValid: true, verb: `${prefix}${remainderVerb}`, reason: null };
        }
      }
    }

    // No verb pattern found
    return { isValid: false, verb: null, reason: 'no_verb' };
  }

  /**
   * ðŸŽ­ TIER 4: CONTEXT-AWARE NAMING RULES
   * Different rules for different contexts
   */
  getContextSpecificRules(architecturalContext, semanticIntent) {
    const rules = {
      allowedPatterns: [],
      requiredPatterns: [],
      suggestions: []
    };

    // React components have different naming conventions
    if (architecturalContext.isReactComponent) {
      rules.allowedPatterns.push(/^[A-Z][a-zA-Z]*$/); // PascalCase components
      rules.allowedPatterns.push(/^use[A-Z][a-zA-Z]*$/); // React hooks
      rules.allowedPatterns.push(/^handle[A-Z][a-zA-Z]*$/); // Event handlers
    }

    // Test files have different patterns
    if (architecturalContext.isTestFile) {
      rules.allowedPatterns.push(/^(test|it|describe|should|expect)[A-Z]?/);
    }

    // Data layer functions often have CRUD patterns
    if (architecturalContext.layer === 'DATA') {
      rules.suggestions.push('Consider CRUD verbs: create, read, update, delete, fetch, save');
    }

    // UI layer functions often have interaction verbs
    if (architecturalContext.layer === 'UI') {
      rules.suggestions.push('Consider UI verbs: show, hide, toggle, render, display, handle');
    }

    return rules;
  }

  /**
   * ðŸŽ¯ TIER 5: COMPREHENSIVE SMART ANALYSIS
   * Combines all tiers for intelligent assessment
   */
  smartAnalyzeFunctionName(functionName, functionNode, sourceFile, architecturalContext, content) {
    // Skip special functions
    if (this.isSpecialFunction(functionName, architecturalContext)) {
      return { isViolation: false };
    }

    // Get semantic intent
    const semanticIntent = this.analyzeSemanticIntent(functionNode, sourceFile, content);

    // Get context-specific rules
    const contextRules = this.getContextSpecificRules(architecturalContext, semanticIntent);

    // Check if allowed by context-specific patterns
    if (contextRules.allowedPatterns.some(pattern => pattern.test(functionName))) {
      return { isViolation: false };
    }

    // Check if name follows verb-noun pattern
    const verbCheck = this.isVerbNounPattern(functionName);

    if (verbCheck.isValid) {
      return { isViolation: false };
    }

    // ðŸ§® CONFIDENCE CALCULATION
    let confidence = 0.5; // Base confidence
    let violationType = 'no_verb';

    if (verbCheck.reason === 'vague_verb') {
      violationType = 'vague_verb';
      confidence = 0.9; // High confidence for vague verbs
    } else if (verbCheck.reason === 'no_verb') {
      violationType = 'no_verb';

      // Check for obviously wrong patterns
      const commonNounPatterns = [
        /^(user|data|info|item|list|config|settings|options|params|args|props|state|value|result|response|request|error|message|event|callback|handler)([A-Z][a-z]*)*$/i,
        /^[a-z]+$/, // Simple lowercase words
        /^[a-z]+[A-Z][a-z]+$/ // Simple camelCase nouns
      ];

      if (commonNounPatterns.some(pattern => pattern.test(functionName))) {
        confidence = 0.8; // High confidence for obvious nouns
      }

      // Boost confidence for clearly generic patterns
      const vagueFunctionNames = [
        'something', 'stuff', 'thing', 'data', 'info', 'item',
        'work', 'task', 'job', 'action', 'operation'
      ];

      if (vagueFunctionNames.some(vague => functionName.toLowerCase().includes(vague.toLowerCase()))) {
        confidence = 0.95; // Very high confidence
      }
    }

    // Reduce confidence for complex names (might have hidden patterns)
    if (functionName.length > 20) {
      confidence -= 0.15;
    }

    // Reduce confidence for utils/helpers (more flexible naming)
    if (architecturalContext.layer === 'UTILS') {
      confidence -= 0.2;
    }

    // Reduce confidence for test files
    if (architecturalContext.isTestFile) {
      confidence -= 0.3;
    }

    // Cap confidence
    confidence = Math.min(Math.max(confidence, 0.1), 1.0);

    // ðŸ’¬ INTELLIGENT MESSAGING
    const context = {
      layer: architecturalContext.layer,
      intent: semanticIntent,
      isReactComponent: architecturalContext.isReactComponent,
      isTestFile: architecturalContext.isTestFile,
      violationType
    };

    let reason = '';
    let suggestion = '';

    if (violationType === 'vague_verb') {
      reason = `Function '${functionName}' uses vague verb. Use more specific action verbs (see C006 accepted verbs list)`;
      suggestion = this.generateSmartSuggestion(functionName, semanticIntent, architecturalContext, true);
    } else {
      reason = `Function '${functionName}' must start with a verb (verb-noun pattern required by C006)`;
      suggestion = this.generateSmartSuggestion(functionName, semanticIntent, architecturalContext, false);
    }

    if (architecturalContext.layer !== 'UNKNOWN') {
      reason += ` (${architecturalContext.layer} layer)`;
    }

    return {
      isViolation: true,
      reason,
      type: `smart_naming_violation_${violationType}`,
      confidence,
      suggestion,
      context
    };
  }

  /**
   * ðŸ’¡ SMART SUGGESTION GENERATOR
   */
  generateSmartSuggestion(functionName, semanticIntent, architecturalContext, isVagueVerb) {
    // If it's a vague verb, extract the noun part
    let baseNoun = functionName;

    if (isVagueVerb) {
      // Try to extract the noun part after the vague verb
      for (const vagueVerb of this.vagueVerbs) {
        const pattern = new RegExp(`^${vagueVerb}([A-Z].*)$`, 'i');
        const match = functionName.match(pattern);
        if (match) {
          baseNoun = match[1];
          break;
        }
      }
    }

    // Ensure first letter is capitalized for camelCase
    baseNoun = baseNoun.charAt(0).toUpperCase() + baseNoun.slice(1);

    const suggestions = [];

    switch (semanticIntent) {
      case 'GETTER':
        suggestions.push(`get${baseNoun}()`, `fetch${baseNoun}()`, `retrieve${baseNoun}()`);
        break;
      case 'SETTER':
        suggestions.push(`set${baseNoun}()`, `update${baseNoun}()`, `save${baseNoun}()`);
        break;
      case 'CHECKER':
        suggestions.push(`is${baseNoun}()`, `has${baseNoun}()`, `can${baseNoun}()`, `should${baseNoun}()`);
        break;
      case 'ACTION':
        suggestions.push(`process${baseNoun}()`, `handle${baseNoun}()`, `execute${baseNoun}()`);
        break;
      default:
        if (architecturalContext.layer === 'DATA') {
          suggestions.push(`fetch${baseNoun}()`, `create${baseNoun}()`, `save${baseNoun}()`, `load${baseNoun}()`);
        } else if (architecturalContext.layer === 'UI') {
          suggestions.push(`render${baseNoun}()`, `show${baseNoun}()`, `display${baseNoun}()`, `draw${baseNoun}()`);
        } else {
          suggestions.push(`get${baseNoun}()`, `set${baseNoun}()`, `process${baseNoun}()`, `handle${baseNoun}()`);
        }
    }

    return suggestions.slice(0, 3).join(' or ');
  }

  /**
   * ðŸ›¡ï¸ ENHANCED SPECIAL FUNCTION DETECTION
   */
  isSpecialFunction(name, architecturalContext) {
    const specialFunctions = [
      'constructor', 'toString', 'valueOf', 'toJSON',
      'main', 'init', 'setup', 'teardown', 'build',
      'onCreate', 'onDestroy', 'onStart', 'onStop',
      'onPause', 'onResume', 'onSaveInstanceState',
      'equals', 'hashCode', 'compareTo', 'clone',
      'finalize', 'notify', 'notifyAll', 'wait', 'bootstrap',
    ];

    // ignore by patterns
    const patternsToIgnore = [
      /^(setup|config|bootstrap).*/,
      /^_.*/,
      /Factory$/
    ];

    if (patternsToIgnore.some(pattern => pattern.test(name))) {
      return true;
    }

    // Basic special function check
    if (specialFunctions.includes(name) || name.startsWith('_') || name.startsWith('$')) {
      return true;
    }

    // React component names (PascalCase)
    if (architecturalContext.isReactComponent && /^[A-Z][a-zA-Z]*$/.test(name)) {
      return true;
    }

    // React hooks
    if (name.startsWith('use') && /^use[A-Z]/.test(name)) {
      return true;
    }

    // Test function names
    if (architecturalContext.isTestFile && /^(test|it|describe|should|expect)/.test(name)) {
      return true;
    }

    return false;
  }

  /**
   * ðŸŽ¯ UTILITY METHODS
   */
  extractImports(content) {
    const importRegex = /import\s+.*?\s+from\s+['"]([^'"]+)['"]/g;
    const imports = [];
    let match;

    while ((match = importRegex.exec(content)) !== null) {
      imports.push(match[1]);
    }

    return imports;
  }

  getSeverityFromConfidence(confidence) {
    if (confidence >= this.confidenceThresholds.HIGH) return 'warning';
    if (confidence >= this.confidenceThresholds.MEDIUM) return 'info';
    return 'hint';
  }
}

module.exports = new SmartC006Analyzer();
