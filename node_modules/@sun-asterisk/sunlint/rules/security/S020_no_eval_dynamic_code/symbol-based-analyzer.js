/**
 * S020 Symbol-Based Analyzer - Avoid using eval() or executing dynamic code
 * Enhanced to analyze function calls, constructor patterns, and dynamic code execution
 */

class S020SymbolBasedAnalyzer {
  constructor(semanticEngine) {
    this.ruleId = "S020";
    this.semanticEngine = semanticEngine;

    // Dangerous functions that execute dynamic code
    this.dangerousFunctions = ["eval", "Function", "execScript"];

    // Functions that can execute code when used with strings
    this.conditionallyDangerous = ["setTimeout", "setInterval", "setImmediate"];

    // Constructor patterns to detect
    this.dangerousConstructors = ["Function"];

    // Global object access patterns
    this.globalAccessPatterns = [
      "window.eval",
      "global.eval",
      "globalThis.eval",
      "self.eval",
    ];

    // Dynamic code indicators in variable names/strings
    this.dynamicCodeIndicators = [
      "code",
      "script",
      "expression",
      "formula",
      "template",
      "eval",
    ];
  }

  async initialize() {}

  analyze(sourceFile, filePath) {
    const violations = [];

    // Skip files that are unlikely to contain dynamic code execution
    const skipPatterns = [
      /\.d\.ts$/,
      /\.types\.ts$/,
      /\.interface\.ts$/,
      /\.constants?\.ts$/,
      /\.config\.ts$/,
      /\.spec\.ts$/,
      /\.test\.ts$/,
    ];

    const shouldSkip = skipPatterns.some((pattern) => pattern.test(filePath));
    if (shouldSkip) {
      return violations;
    }

    try {
      const { SyntaxKind } = require("ts-morph");

      // Find all call expressions for function calls
      const callExpressions = sourceFile.getDescendantsOfKind(
        SyntaxKind.CallExpression
      );

      for (const call of callExpressions) {
        try {
          const callViolations = this.analyzeCallExpression(call, filePath);
          violations.push(...callViolations);
        } catch (error) {
          console.warn(
            `⚠ [S020] Call expression analysis failed:`,
            error.message
          );
        }
      }

      // Find all new expressions for constructor calls
      const newExpressions = sourceFile.getDescendantsOfKind(
        SyntaxKind.NewExpression
      );

      for (const newExpr of newExpressions) {
        try {
          const newViolations = this.analyzeNewExpression(newExpr, filePath);
          violations.push(...newViolations);
        } catch (error) {
          console.warn(
            `⚠ [S020] New expression analysis failed:`,
            error.message
          );
        }
      }

      // Find property access expressions for global object access
      const propertyAccesses = sourceFile.getDescendantsOfKind(
        SyntaxKind.PropertyAccessExpression
      );

      for (const propAccess of propertyAccesses) {
        try {
          const propViolations = this.analyzePropertyAccess(
            propAccess,
            filePath
          );
          violations.push(...propViolations);
        } catch (error) {
          console.warn(
            `⚠ [S020] Property access analysis failed:`,
            error.message
          );
        }
      }
    } catch (error) {
      console.warn(
        `⚠ [S020] Symbol analysis failed for ${filePath}:`,
        error.message
      );
    }

    return violations;
  }

  analyzeCallExpression(call, filePath) {
    const violations = [];

    try {
      const { SyntaxKind } = require("ts-morph");

      const expression = call.getExpression();
      let functionName = null;

      // Direct function call: eval(), Function()
      if (expression.getKind() === SyntaxKind.Identifier) {
        functionName = expression.getText();
      }
      // Property access: window.eval(), global.Function()
      else if (expression.getKind() === SyntaxKind.PropertyAccessExpression) {
        const fullExpression = expression.getText();
        const propertyName = expression.getName();

        // Check for global access patterns
        if (
          this.globalAccessPatterns.some(
            (pattern) => fullExpression === pattern
          )
        ) {
          functionName = propertyName;
        } else if (this.dangerousFunctions.includes(propertyName)) {
          functionName = propertyName;
        }
      }
      // Type assertion / type casting: (setImmediate as any)("string")
      else if (expression.getKind() === SyntaxKind.ParenthesizedExpression) {
        const innerExpression = expression.getExpression();
        if (innerExpression.getKind() === SyntaxKind.AsExpression) {
          const asExpression = innerExpression;
          const leftExpression = asExpression.getExpression();
          if (leftExpression.getKind() === SyntaxKind.Identifier) {
            functionName = leftExpression.getText();
          }
        }
      }

      if (functionName) {
        // Check for dangerous functions
        if (this.dangerousFunctions.includes(functionName)) {
          const startLine = call.getStartLineNumber();
          violations.push({
            ruleId: this.ruleId,
            message: `Dangerous function '${functionName}()' can execute arbitrary code and poses security risks`,
            severity: "error",
            line: startLine,
            column: 1,
          });
        }
        // Check for conditionally dangerous functions (setTimeout/setInterval with string)
        else if (this.conditionallyDangerous.includes(functionName)) {
          const args = call.getArguments();
          if (args.length > 0) {
            const firstArg = args[0];

            // ONLY flag if first argument is a string literal
            // This is the only truly dangerous case for setTimeout/setInterval
            if (firstArg.getKind() === SyntaxKind.StringLiteral) {
              const startLine = call.getStartLineNumber();
              violations.push({
                ruleId: this.ruleId,
                message: `Function '${functionName}()' with string argument can execute dynamic code - use function reference instead`,
                severity: "warning",
                line: startLine,
                column: 1,
              });
            }
            // NOTE: Removed variable name checking as it causes too many false positives
            // Functions like setTimeout with arrow functions or function references are safe
          }
        }
      }
    } catch (error) {
      console.warn(`⚠ [S020] Call expression analysis failed:`, error.message);
    }

    return violations;
  }

  analyzeNewExpression(newExpr, filePath) {
    const violations = [];

    try {
      const { SyntaxKind } = require("ts-morph");

      const expression = newExpr.getExpression();

      if (expression.getKind() === SyntaxKind.Identifier) {
        const constructorName = expression.getText();

        if (this.dangerousConstructors.includes(constructorName)) {
          const startLine = newExpr.getStartLineNumber();
          violations.push({
            ruleId: this.ruleId,
            message: `Constructor 'new ${constructorName}()' can create functions from strings and execute dynamic code`,
            severity: "error",
            line: startLine,
            column: 1,
          });
        }
      }
    } catch (error) {
      console.warn(`⚠ [S020] New expression analysis failed:`, error.message);
    }

    return violations;
  }

  analyzePropertyAccess(propAccess, filePath) {
    const violations = [];

    try {
      const fullExpression = propAccess.getText();

      // Check for global eval access patterns
      if (this.globalAccessPatterns.includes(fullExpression)) {
        const startLine = propAccess.getStartLineNumber();
        violations.push({
          ruleId: this.ruleId,
          message: `Global eval access '${fullExpression}' can execute arbitrary code and poses security risks`,
          severity: "error",
          line: startLine,
          column: 1,
        });
      }
    } catch (error) {
      console.warn(`⚠ [S020] Property access analysis failed:`, error.message);
    }

    return violations;
  }

  cleanup() {}
}

module.exports = S020SymbolBasedAnalyzer;
