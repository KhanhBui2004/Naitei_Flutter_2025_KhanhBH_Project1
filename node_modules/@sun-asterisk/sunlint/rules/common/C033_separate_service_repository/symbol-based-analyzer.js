/**
 * C033 Symbol-Based Analyzer
 * Detect Service-Repository separation violations
 */

class C033SymbolBasedAnalyzer {
  constructor(semanticEngine = null) {
    this.ruleId = 'C033';
    this.semanticEngine = semanticEngine;
    this.verbose = false;
    
    // ============================================================
    // PATTERN DEFINITIONS - Organized by category
    // ============================================================
    
    // Database CRUD operations (TypeORM, Prisma, Sequelize, etc.)
    this.databaseOperations = [
      // Query operations
      'findOne', 'findById', 'findBy', 'findOneBy', 'findAndCount', 'findByIds',
      'find', 'findMany', 'findAll', 'findFirst', 'get', 'getMany', 'getOne',
      // Create operations
      'save', 'insert', 'upsert', 'persist', 'create', 'createMany',
      // Update operations
      'update', 'patch', 'merge', 'updateMany', 'set',
      // Delete operations
      'delete', 'remove', 'softDelete', 'destroy', 'deleteMany',
      // Query execution
      'query', 'exec', 'execute', 'run', 'rawQuery', 'raw',
      // ORM-specific
      'flush', 'clear', 'refresh', 'reload', 'count', 'aggregate'
    ];
    
    // Query builder methods
    this.queryBuilderMethods = [
      'createQueryBuilder', 'queryBuilder',
      'select', 'from', 'where', 'andWhere', 'orWhere',
      'innerJoin', 'leftJoin', 'rightJoin', 'join',
      'orderBy', 'groupBy', 'having', 'limit', 'offset', 'skip', 'take',
      'getMany', 'getOne', 'getRawMany', 'getRawOne', 'getCount'
    ];
    
    // Transaction and connection methods
    this.transactionMethods = [
      'transaction', 'beginTransaction', 'commit', 'rollback',
      'startTransaction', 'commitTransaction', 'rollbackTransaction',
      'createQueryRunner', 'getQueryRunner'
    ];
    
    // Schema and migration operations (should rarely be in Service)
    this.schemaOperations = [
      'synchronize', 'sync', 'dropDatabase', 'dropSchema',
      'runMigrations', 'undoLastMigration', 'showMigrations',
      'createTable', 'dropTable', 'alterTable', 'addColumn', 'dropColumn'
    ];
    
    // Database connection properties
    // NOTE: Removed generic 'client' to avoid false positives with httpClient, apiClient, etc.
    // Only specific database clients are included
    this.databaseProperties = [
      'dataSource', 'connection', 'entityManager', 'manager',
      'database', 'db', 
      // Specific database clients only
      'prismaClient', 'prismaService',
      'sequelizeClient', 'sequelizeConnection',
      'mongoClient', 'mongoConnection',
      'redisClient', 'redisConnection',
      'dbClient', 'databaseClient',
      // ORM instances
      'prisma', 'sequelize', 'knex', 'mongoose', 'typeorm'
    ];
    
    // ORM framework type indicators
    this.ormFrameworks = [
      'Repository', 'EntityRepository', 'EntityManager',
      'PrismaClient', 'PrismaService',
      'Model', 'Document', 'Schema',
      'Sequelize', 'QueryInterface',
      'Knex', 'QueryBuilder',
      'Connection', 'DataSource'
    ];
    
    // Business logic indicators (should NOT be in Repository)
    this.businessLogicPatterns = [
      // Calculation and computation
      'calculate', 'compute', 'sum', 'total', 'average', 'aggregate',
      // Validation and verification
      'validate', 'verify', 'check', 'ensure', 'confirm', 'assert',
      // Transformation and conversion
      'format', 'parse', 'serialize', 'deserialize', 'transform', 'convert',
      // Business operations
      'process', 'handle', 'execute', 'perform', 'apply',
      // Notifications and communications
      'notify', 'send', 'publish', 'trigger', 'broadcast',
      // Business rules
      'enforce', 'implement', 'authorize', 'approve', 'reject'
    ];
  }

  async initialize(semanticEngine = null) {
    if (semanticEngine) {
      this.semanticEngine = semanticEngine;
    }
    this.verbose = semanticEngine?.verbose || false;
  }

  // ============================================================
  // HELPER METHODS
  // ============================================================

  /**
   * Calculate exact line number from string index
   * @param {string} text - The method body text
   * @param {number} index - Index of match in text
   * @param {number} startLine - Starting line number of method
   * @returns {number} Exact line number of violation
   */
  calculateLineNumberFromIndex(text, index, startLine) {
    if (index === undefined || index === null) {
      return startLine; // Fallback to method start line
    }
    
    const textBeforeMatch = text.substring(0, index);
    const lineOffset = (textBeforeMatch.match(/\n/g) || []).length;
    
    // Method body starts after the opening brace, which is typically on the line
    // after method signature. getBodyText() returns content inside braces.
    // So we need to add lineOffset without additional adjustment.
    return startLine + lineOffset;
  }

  async analyze(files, language, options = {}) {
    const violations = [];
    
    for (const filePath of files) {
      const fileViolations = await this.analyzeFileWithSymbols(filePath, options);
      violations.push(...fileViolations);
    }
    
    return violations;
  }

  async analyzeFileWithSymbols(filePath, options = {}) {
    const violations = [];
    
    try {
      if (!this.semanticEngine?.project) {
        return violations;
      }

      const sourceFile = this.semanticEngine.project.getSourceFile(filePath);
      if (!sourceFile) {
        return violations;
      }

      // Determine file type
      const fileType = this.determineFileType(filePath, sourceFile);
      
      if (this.verbose) {
        console.log(`[C033] Analyzing ${filePath} as ${fileType}`);
      }

      // Analyze based on file type
      if (fileType === 'service') {
        violations.push(...this.analyzeServiceFile(sourceFile, filePath));
      } else if (fileType === 'repository') {
        violations.push(...this.analyzeRepositoryFile(sourceFile, filePath));
      } else if (fileType === 'controller') {
        violations.push(...this.analyzeControllerFile(sourceFile, filePath));
      } else if (fileType === 'mixed') {
        // Add file-level violation for mixing concerns
        violations.push({
          ruleId: this.ruleId,
          severity: 'warning',
          message: 'Service and Repository classes should be in separate files to maintain clear separation of concerns',
          file: filePath,
          line: 1,
          column: 1
        });
        
        // Also analyze individual Service and Repository classes for additional violations
        violations.push(...this.analyzeServiceFile(sourceFile, filePath));
        violations.push(...this.analyzeRepositoryFile(sourceFile, filePath));
      }

    } catch (error) {
      if (this.verbose) {
        console.warn(`[C033] Error analyzing ${filePath}:`, error.message);
      }
    }

    return violations;
  }

  determineFileType(filePath, sourceFile) {
    // Extract just the filename (not full path) to avoid false positives from directory names
    const path = require('path');
    const fileName = path.basename(filePath).toLowerCase();
    
    // Check filename patterns
    if (fileName.includes('service') && fileName.includes('repository')) {
      if (this.verbose) {
        console.log(`[C033-DEBUG] File ${fileName} detected as MIXED (filename has both service and repository)`);
      }
      return 'mixed';
    }
    if (fileName.includes('service')) {
      if (this.verbose) {
        console.log(`[C033-DEBUG] File ${fileName} detected as SERVICE (filename)`);
      }
      return 'service';
    }
    if (fileName.includes('repository')) {
      if (this.verbose) {
        console.log(`[C033-DEBUG] File ${fileName} detected as REPOSITORY (filename)`);
      }
      return 'repository';
    }
    if (fileName.includes('controller')) {
      if (this.verbose) {
        console.log(`[C033-DEBUG] File ${fileName} detected as CONTROLLER (filename)`);
      }
      return 'controller';
    }
    
    // Check class names in content
    const classes = sourceFile.getClasses();
    if (classes.length === 0) {
      if (this.verbose) {
        console.log(`[C033-DEBUG] File ${filePath} has no classes - UNKNOWN`);
      }
      return 'unknown';
    }
    
    const classNames = classes.map(cls => cls.getName() || 'Unnamed').join(', ');
    const hasService = classes.some(cls => cls.getName()?.toLowerCase().includes('service'));
    const hasRepository = classes.some(cls => cls.getName()?.toLowerCase().includes('repository'));
    
    if (this.verbose) {
      console.log(`[C033-DEBUG] File ${filePath} has classes: [${classNames}]`);
      console.log(`[C033-DEBUG] hasService=${hasService}, hasRepository=${hasRepository}`);
    }
    
    if (hasService && hasRepository) {
      if (this.verbose) {
        console.log(`[C033-DEBUG] File ${filePath} detected as MIXED (has both Service and Repository classes)`);
      }
      return 'mixed';
    }
    if (hasService) {
      if (this.verbose) {
        console.log(`[C033-DEBUG] File ${filePath} detected as SERVICE (class name)`);
      }
      return 'service';
    }
    if (hasRepository) {
      if (this.verbose) {
        console.log(`[C033-DEBUG] File ${filePath} detected as REPOSITORY (class name)`);
      }
      return 'repository';
    }
    
    if (this.verbose) {
      console.log(`[C033-DEBUG] File ${filePath} detected as UNKNOWN`);
    }
    return 'unknown';
  }

  // ============================================================
  // SERVICE FILE ANALYSIS
  // ============================================================

  analyzeServiceFile(sourceFile, filePath) {
    const violations = [];
    const classes = sourceFile.getClasses();
    
    for (const cls of classes) {
      const className = cls.getName() || 'UnnamedClass';
      
      // Skip if this is a Repository class (in mixed files)
      if (className.toLowerCase().includes('repository')) {
        continue;
      }
      
      // Check class-level patterns
      const hasRepositoryInjection = this.checkRepositoryInjection(cls);
      const hasDatabaseInjection = this.checkDatabaseInjection(cls);
      
      // VIOLATION: Service has both Repository and direct database access
      if (hasRepositoryInjection && hasDatabaseInjection) {
        violations.push({
          ruleId: this.ruleId,
          severity: 'warning',
          message: `Service class '${className}' has both Repository injection and direct database access (DataSource/Connection/EntityManager). This creates inconsistent patterns - use only Repository.`,
          file: filePath,
          line: cls.getStartLineNumber(),
          column: 1
        });
      }
      
      // VIOLATION: Service has direct database access without Repository
      if (!hasRepositoryInjection && hasDatabaseInjection) {
        violations.push({
          ruleId: this.ruleId,
          severity: 'warning',
          message: `Service class '${className}' should use dependency injection to inject Repository instead of direct database access.`,
          file: filePath,
          line: cls.getStartLineNumber(),
          column: 1
        });
      }
      
      // Analyze each method in the service
      const methods = cls.getMethods();
      for (const method of methods) {
        violations.push(...this.analyzeServiceMethod(method, className, filePath));
      }
    }
    
    return violations;
  }

  analyzeServiceMethod(method, className, filePath) {
    const violations = [];
    const methodName = method.getName();
    const methodBody = method.getBodyText() || '';
    
    // Get the actual body block start line (opening brace)
    const methodBodyNode = method.getBody();
    const bodyStartLine = methodBodyNode ? methodBodyNode.getStartLineNumber() + 1 : method.getStartLineNumber();
    
    // Check for different types of violations
    const directDbViolation = this.checkDirectDatabaseAccess_InMethod(methodBody);
    if (directDbViolation) {
      const violationLine = this.calculateLineNumberFromIndex(
        methodBody, 
        directDbViolation.matchIndex, 
        bodyStartLine
      );
      
      violations.push({
        ruleId: this.ruleId,
        severity: 'warning',
        message: `Service method '${methodName}' directly calls database operation '${directDbViolation.operation}'. Consider using Repository pattern to separate data access logic.`,
        file: filePath,
        line: violationLine,
        column: 1
      });
    }
    
    const transactionViolation = this.checkTransactionAccess_InMethod(methodBody);
    if (transactionViolation) {
      const violationLine = this.calculateLineNumberFromIndex(
        methodBody,
        transactionViolation.matchIndex,
        bodyStartLine
      );
      
      violations.push({
        ruleId: this.ruleId,
        severity: 'warning',
        message: `Service method '${methodName}' directly handles transactions using '${transactionViolation.operation}'. Consider delegating transaction logic to Repository or a dedicated transaction service.`,
        file: filePath,
        line: violationLine,
        column: 1
      });
    }
    
    const queryRunnerViolation = this.checkQueryRunnerAccess_InMethod(methodBody);
    if (queryRunnerViolation) {
      const violationLine = this.calculateLineNumberFromIndex(
        methodBody,
        queryRunnerViolation.matchIndex,
        bodyStartLine
      );
      
      violations.push({
        ruleId: this.ruleId,
        severity: 'warning',
        message: `Service method '${methodName}' directly uses QueryRunner. QueryRunner operations should be encapsulated in Repository layer.`,
        file: filePath,
        line: violationLine,
        column: 1
      });
    }
    
    const schemaViolation = this.checkSchemaOperations_InMethod(methodBody);
    if (schemaViolation) {
      const violationLine = this.calculateLineNumberFromIndex(
        methodBody,
        schemaViolation.matchIndex,
        bodyStartLine
      );
      
      violations.push({
        ruleId: this.ruleId,
        severity: 'error',
        message: `Service method '${methodName}' performs schema operations ('${schemaViolation.operation}'). Schema operations should not be in Service layer.`,
        file: filePath,
        line: violationLine,
        column: 1
      });
    }
    
    return violations;
  }

  // ============================================================
  // SERVICE METHOD VIOLATION CHECKERS
  // ============================================================

  checkDirectDatabaseAccess_InMethod(methodBody) {
    // Pattern 1: Direct access to dataSource/connection/manager
    const directAccessPatterns = [
      { regex: /this\.(dataSource|connection|entityManager|manager)\s*\.\s*createQueryBuilder/i, type: 'createQueryBuilder' },
      { regex: /this\.(dataSource|connection|entityManager|manager)\s*\.\s*getRepository/i, type: 'getRepository' },
      { regex: /this\.(dataSource|connection|entityManager|manager)\s*\.\s*query/i, type: 'query' },
    ];
    
    for (const pattern of directAccessPatterns) {
      const match = methodBody.match(pattern.regex);
      if (match) {
        return { operation: pattern.type, pattern: 'direct-access', matchIndex: match.index };
      }
    }
    
    // Pattern 2: Global ORM calls
    const globalPatterns = [
      { regex: /(?<!Repository\.)getRepository\s*\(/i, type: 'getRepository' },
      { regex: /\bgetConnection\s*\(/i, type: 'getConnection' },
      { regex: /\bgetManager\s*\(/i, type: 'getManager' },
    ];
    
    for (const pattern of globalPatterns) {
      const match = methodBody.match(pattern.regex);
      if (match) {
        return { operation: pattern.type, pattern: 'global-call', matchIndex: match.index };
      }
    }
    
    // Pattern 3: Database operations with context check
    for (const operation of this.databaseOperations) {
      const operationPattern = new RegExp(`\\b${operation}\\s*\\(`, 'gi');
      const matches = methodBody.matchAll(operationPattern);
      
      for (const match of matches) {
        const matchIndex = match.index;
        const contextStart = Math.max(0, matchIndex - 50);
        const context = methodBody.substring(contextStart, matchIndex);
        
        // Check if this is a call through repository (ALLOWED)
        const repositoryCallPattern = /this\.([\w]+Repository|[\w]+Repo)\s*\.\s*$/i;
        if (repositoryCallPattern.test(context)) {
          continue; // Skip - this is allowed
        }
        
        // Check if this is direct database call (VIOLATION)
        const directDbCallPattern = /this\.(dataSource|connection|entityManager|manager|database|db|client|prisma)\./i;
        const globalDbCallPattern = /(getRepository|getConnection|getManager|createQueryBuilder)\s*\([^)]*\)\s*\.?[\w.]*$/i;
        
        if (directDbCallPattern.test(context) || globalDbCallPattern.test(context)) {
          return { operation, pattern: 'context-detected', matchIndex };
        }
      }
    }
    
    return null;
  }

  checkTransactionAccess_InMethod(methodBody) {
    // Check for transaction method calls
    for (const txMethod of this.transactionMethods) {
      // Pattern: this.(dataSource|connection|manager).transaction(...)
      const txPattern = new RegExp(`this\\.(dataSource|connection|entityManager|manager|db)\\s*\\.\\s*${txMethod}\\s*\\(`, 'i');
      const match = methodBody.match(txPattern);
      if (match) {
        return { operation: txMethod, type: 'direct-transaction', matchIndex: match.index };
      }
      
      // Pattern: global transaction calls
      const globalTxPattern = new RegExp(`\\b${txMethod}\\s*\\(`, 'i');
      // Make sure it's not a repository method call
      const contextPattern = new RegExp(`this\\.(\\w+Repository|\\w+Repo)\\s*\\.\\s*${txMethod}\\s*\\(`, 'i');
      
      if (globalTxPattern.test(methodBody) && !contextPattern.test(methodBody)) {
        const globalMatch = methodBody.match(globalTxPattern);
        return { operation: txMethod, type: 'global-transaction', matchIndex: globalMatch.index };
      }
    }
    
    return null;
  }

  checkQueryRunnerAccess_InMethod(methodBody) {
    // Check for QueryRunner usage
    const queryRunnerPatterns = [
      /this\.(dataSource|connection)\s*\.\s*createQueryRunner\s*\(/i,
      /this\.(dataSource|connection)\s*\.\s*getQueryRunner\s*\(/i,
      /\bcreateQueryRunner\s*\(\s*\)/i,
      /queryRunner\s*\.\s*(connect|startTransaction|commitTransaction|rollbackTransaction|release)/i
    ];
    
    for (const pattern of queryRunnerPatterns) {
      const match = methodBody.match(pattern);
      if (match) {
        return { operation: 'QueryRunner', detected: true, matchIndex: match.index };
      }
    }
    
    return null;
  }

  checkSchemaOperations_InMethod(methodBody) {
    // Check for schema and migration operations
    for (const schemaOp of this.schemaOperations) {
      const schemaPattern = new RegExp(`this\\.(dataSource|connection|db)\\s*\\.\\s*${schemaOp}\\s*\\(`, 'i');
      const match = methodBody.match(schemaPattern);
      if (match) {
        return { operation: schemaOp, severity: 'error', matchIndex: match.index };
      }
    }
    
    return null;
  }

  // ============================================================
  // SERVICE CLASS-LEVEL CHECKERS
  // ============================================================

  checkRepositoryInjection(cls) {
    try {
      // Check constructor parameters
      const constructor = cls.getConstructors()[0];
      if (constructor) {
        const params = constructor.getParameters();
        for (const param of params) {
          const paramName = param.getName().toLowerCase();
          const paramType = param.getType().getText().toLowerCase();
          
          if (paramName.includes('repository') || 
              paramName.includes('repo') ||
              paramType.includes('repository')) {
            return true;
          }
        }
      }
      
      // Check class properties
      const properties = cls.getProperties();
      for (const prop of properties) {
        const propName = prop.getName().toLowerCase();
        const propType = prop.getType().getText().toLowerCase();
        
        if (propName.includes('repository') || 
            propName.includes('repo') ||
            propType.includes('repository')) {
          return true;
        }
      }
    } catch (error) {
      // Ignore errors
    }
    
    return false;
  }

  checkDatabaseInjection(cls) {
    try {
      // Check constructor parameters for database-related injections
      const constructor = cls.getConstructors()[0];
      if (constructor) {
        const params = constructor.getParameters();
        for (const param of params) {
          const paramName = param.getName().toLowerCase();
          const paramType = param.getType().getText().toLowerCase();
          
          // Check for database connection properties
          for (const dbProp of this.databaseProperties) {
            if (paramName.includes(dbProp) || paramType.includes(dbProp)) {
              return true;
            }
          }
          
          // Check for ORM framework types
          for (const framework of this.ormFrameworks) {
            if (paramType.includes(framework.toLowerCase())) {
              // Exclude Repository types - those are good
              if (framework.includes('Repository')) {
                continue;
              }
              return true;
            }
          }
        }
      }
      
      // Check class properties
      const properties = cls.getProperties();
      for (const prop of properties) {
        const propName = prop.getName().toLowerCase();
        
        for (const dbProp of this.databaseProperties) {
          if (propName.includes(dbProp)) {
            return true;
          }
        }
      }
    } catch (error) {
      // Ignore errors
    }
    
    return false;
  }

  checkDirectDatabaseAccess(cls) {
    try {
      const classText = cls.getText();
      
      // Check for ORM framework usage
      for (const framework of this.ormFrameworks) {
        if (classText.includes(framework)) {
          return true;
        }
      }
      
      // Check for database operations
      for (const operation of this.databaseOperations) {
        const pattern = new RegExp(`\\b${operation}\\s*\\(`, 'i');
        if (pattern.test(classText)) {
          return true;
        }
      }
    } catch (error) {
      // Ignore errors
    }
    
    return false;
  }

  // ============================================================
  // REPOSITORY FILE ANALYSIS
  // ============================================================

  analyzeRepositoryFile(sourceFile, filePath) {
    const violations = [];
    const classes = sourceFile.getClasses();
    
    for (const cls of classes) {
      const className = cls.getName() || 'UnnamedClass';
      
      // Skip if this is a Service class (in mixed files)
      if (className.toLowerCase().includes('service') && !className.toLowerCase().includes('repository')) {
        continue;
      }
      
      const methods = cls.getMethods();
      
      // Check if Repository follows CRUD pattern
      const hasCrudMethods = this.checkCrudPattern(cls);
      const hasBusinessLogic = this.checkBusinessLogicInRepository(cls);
      
      if (hasBusinessLogic) {
        violations.push({
          ruleId: this.ruleId,
          severity: 'warning',
          message: `Repository class '${className}' should contain only CRUD operations. Business logic detected - move to Service layer.`,
          file: filePath,
          line: cls.getStartLineNumber(),
          column: 1
        });
      }
      
      for (const method of methods) {
        const methodName = method.getName();
        
        // Check method name for business logic indicators
        for (const pattern of this.businessLogicPatterns) {
          if (methodName.toLowerCase().includes(pattern.toLowerCase())) {
            violations.push({
              ruleId: this.ruleId,
              severity: 'warning',
              message: `Repository method '${methodName}' in class '${className}' appears to contain business logic ('${pattern}'). Move business logic to Service layer.`,
              file: filePath,
              line: method.getStartLineNumber(),
              column: 1
            });
            break;
          }
        }
        
        // Check method complexity (too many control structures = business logic)
        const methodBody = method.getBodyText() || '';
        const ifCount = (methodBody.match(/\bif\s*\(/g) || []).length;
        const forCount = (methodBody.match(/\bfor\s*\(/g) || []).length;
        const whileCount = (methodBody.match(/\bwhile\s*\(/g) || []).length;
        const complexityCount = ifCount + forCount + whileCount;
        
        if (complexityCount > 2) {
          violations.push({
            ruleId: this.ruleId,
            severity: 'warning',
            message: `Repository method '${methodName}' is too complex (${complexityCount} control structures). Repository should contain only simple data access operations.`,
            file: filePath,
            line: method.getStartLineNumber(),
            column: 1
          });
        }
        
        // Check for business logic in method body
        const hasCalculation = /\b(calculate|compute|sum|total|average)\b/i.test(methodBody);
        const hasValidation = /\b(validate|verify|check|ensure|confirm)\b/i.test(methodBody);
        const hasTransformation = /\b(transform|convert|format|parse)\b/i.test(methodBody);
        
        if ((hasCalculation || hasValidation || hasTransformation) && complexityCount > 0) {
          violations.push({
            ruleId: this.ruleId,
            severity: 'warning',
            message: `Repository method '${methodName}' contains business logic operations. Repository should focus on data access only.`,
            file: filePath,
            line: method.getStartLineNumber(),
            column: 1
          });
        }
      }
    }
    
    return violations;
  }

  checkCrudPattern(cls) {
    try {
      const methods = cls.getMethods();
      const methodNames = methods.map(m => m.getName().toLowerCase());
      
      // Check for basic CRUD operations
      const hasCreate = methodNames.some(name => name.includes('create') || name.includes('save') || name.includes('insert'));
      const hasRead = methodNames.some(name => name.includes('find') || name.includes('get') || name.includes('select'));
      const hasUpdate = methodNames.some(name => name.includes('update') || name.includes('patch'));
      const hasDelete = methodNames.some(name => name.includes('delete') || name.includes('remove'));
      
      return hasCreate || hasRead || hasUpdate || hasDelete;
    } catch (error) {
      return false;
    }
  }

  checkBusinessLogicInRepository(cls) {
    try {
      const classText = cls.getText();
      
      // Check for business logic patterns
      for (const pattern of this.businessLogicPatterns) {
        const regex = new RegExp(`\\b${pattern}\\w*\\s*\\(`, 'i');
        if (regex.test(classText)) {
          return true;
        }
      }
    } catch (error) {
      // Ignore errors
    }
    
    return false;
  }

  // ============================================================
  // CONTROLLER FILE ANALYSIS
  // ============================================================

  analyzeControllerFile(sourceFile, filePath) {
    const violations = [];
    const classes = sourceFile.getClasses();

    for (const cls of classes) {
      const className = cls.getName() || 'UnnamedClass';
      const methods = cls.getMethods();

      for (const method of methods) {
        const methodBody = method.getBodyText() || '';

        // Controllers should not directly access database
        for (const operation of this.databaseOperations) {
          const operationPattern = new RegExp(`\\b${operation}\\s*\\(`, 'gi');
          const matches = methodBody.matchAll(operationPattern);

          for (const match of matches) {
            const matchIndex = match.index;
            const contextStart = Math.max(0, matchIndex - 50);
            const context = methodBody.substring(contextStart, matchIndex);

            // Check if this is a call through service (ALLOWED)
            // Matches: this.xxxService.method(), this.xxxUseCase.method(), this.xxxHandler.method()
            const serviceCallPattern = /this\.([\w]+Service|[\w]+UseCase|[\w]+Handler)\s*\.\s*$/i;
            if (serviceCallPattern.test(context)) {
              continue; // Skip - this is allowed
            }

            // Check if this is direct database call (VIOLATION)
            // Matches: this.repository, this.userRepository, this.entityManager, this.xxxClient, etc.
            const directDbCallPattern = /this\.([\w]*Repository|[\w]*Repo|dataSource|connection|entityManager|manager|database|db|[\w]*Client|prisma)\./i;
            const globalDbCallPattern = /(getRepository|getConnection|getManager|createQueryBuilder)\s*\([^)]*\)\s*\.?[\w.]*$/i;

            if (directDbCallPattern.test(context) || globalDbCallPattern.test(context)) {
              violations.push({
                ruleId: this.ruleId,
                severity: 'warning',
                message: `Controller class '${className}' should not directly access database with '${operation}'. Use Service layer instead.`,
                file: filePath,
                line: method.getStartLineNumber(),
                column: 1
              });
              break;
            }
          }
        }
      }
    }

    return violations;
  }
}

module.exports = C033SymbolBasedAnalyzer;
