const C019TsMorphAnalyzer = require('./ts-morph-analyzer.js');
const C019PatternAnalyzer = require('./pattern-analyzer.js');

class C019Analyzer {
  constructor(semanticEngine = null) {
    this.ruleId = 'C019';
    this.ruleName = 'Log Level Usage';
    this.description = 'Detect inappropriate ERROR log level for business logic errors';
    this.semanticEngine = semanticEngine;
    this.verbose = false;

    // Initialize analyzers - ts-morph primary, pattern fallback
    this.tsMorphAnalyzer = new C019TsMorphAnalyzer(semanticEngine);
    this.patternAnalyzer = new C019PatternAnalyzer();
    this.aiAnalyzer = null;
  }

  async initialize(semanticEngine = null) {
    if (semanticEngine) {
      this.semanticEngine = semanticEngine;
    }
    this.verbose = semanticEngine?.verbose || false;

    await this.tsMorphAnalyzer.initialize(semanticEngine);
    await this.patternAnalyzer.initialize({ verbose: this.verbose });
  }

  async analyzeFileBasic(filePath, options = {}) {
    const allViolations = [];

    try {
      // Use ts-morph analysis (Primary - AST) if semantic engine is available
      if (this.semanticEngine?.isSymbolEngineReady?.() && this.semanticEngine.project) {
        if (this.verbose) {
          console.log(`[DEBUG] ðŸŽ¯ C019: Using ts-morph analysis for ${filePath.split('/').pop()}`);
        }

        try {
          const tsMorphViolations = await this.tsMorphAnalyzer.analyzeFile(filePath, options);
          allViolations.push(...tsMorphViolations);

          if (this.verbose) {
            console.log(`[DEBUG] ðŸŽ¯ C019: ts-morph analysis found ${tsMorphViolations.length} violations`);
          }
          
          // Return ts-morph results (even if 0) - do NOT fall back to pattern analyzer
          // Pattern analyzer has no catch block detection and will produce false positives
          return this.deduplicateViolations(allViolations);
          
        } catch (tsMorphError) {
          if (this.verbose) {
            console.warn(`[DEBUG] âš ï¸ C019: ts-morph analysis failed: ${tsMorphError.message}`);
          }
          // Only fall through to pattern analyzer if ts-morph failed
        }
      }

      // Fall back to pattern-based analysis (Secondary - Regex) 
      // ONLY if semantic engine is not available or ts-morph failed
      if (this.verbose) {
        console.log(`[DEBUG] ðŸ”„ C019: Running pattern-based analysis for ${filePath.split('/').pop()}`);
      }

      const patternViolations = await this.patternAnalyzer.analyzeFileBasic(filePath, options);
      allViolations.push(...patternViolations);

      if (this.verbose) {
        console.log(`[DEBUG] ðŸ”„ C019: Pattern analysis found ${patternViolations.length} violations`);
      }

      return this.deduplicateViolations(allViolations);

    } catch (error) {
      if (this.verbose) {
        console.error(`[DEBUG] âŒ C019: Analysis failed: ${error.message}`);
      }
      throw new Error(`C019 analysis failed: ${error.message}`);
    }
  }

  deduplicateViolations(violations) {
    // Remove duplicates based on file, line, and type
    const seen = new Set();
    return violations.filter(violation => {
      const key = `${violation.filePath}:${violation.line}:${violation.type}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }

  async analyzeFiles(files, options = {}) {
    const allViolations = [];
    for (const filePath of files) {
      try {
        const violations = await this.analyzeFileBasic(filePath, options);
        allViolations.push(...violations);
      } catch (error) {
        console.warn(`C019: Skipping ${filePath}: ${error.message}`);
      }
    }
    return allViolations;
  }

  // Legacy method for backward compatibility
  async analyze(files, language, config = {}) {
    // Initialize AI analyzer if enabled
    if (config.ai && config.ai.enabled) {
      this.aiAnalyzer = new AIAnalyzer(config.ai);
      console.log('ðŸ¤– AI analysis enabled for C019');
    }

    const allViolations = [];

    for (const filePath of files) {
      try {
        const fileContent = require('fs').readFileSync(filePath, 'utf8');
        const fileViolations = await this.analyzeFile(filePath, fileContent, language, config);
        allViolations.push(...fileViolations);
      } catch (error) {
        console.error(`Error analyzing file ${filePath}:`, error.message);
      }
    }

    return allViolations;
  }

  async analyzeFile(filePath, content, language, config) {
    let violations = [];
    
    // Try AI analysis first if enabled
    if (this.aiAnalyzer) {
      try {
        console.log(`ðŸ¤– Running AI analysis on ${require('path').basename(filePath)}`);
        const aiViolations = await this.aiAnalyzer.analyzeWithAI(filePath, content, {
          name: this.ruleName,
          description: this.description,
          ruleId: this.ruleId
        });
        
        if (aiViolations && aiViolations.length > 0) {
          violations.push(...aiViolations);
          return violations;
        }
      } catch (error) {
        console.warn(`AI analysis failed for ${filePath}, falling back to heuristic analysis`);
      }
    }
    
    // Use the new analyzer architecture
    const heuristicViolations = await this.analyzeFileBasic(filePath, config);
    violations.push(...heuristicViolations);
    
    return violations;
  }
}

module.exports = C019Analyzer;
