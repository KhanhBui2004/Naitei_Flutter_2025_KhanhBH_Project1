# S020 - Avoid using eval() or executing dynamic code

## Overview

This rule detects and prevents the use of `eval()` and other dynamic code execution mechanisms that can lead to security vulnerabilities, particularly code injection attacks.

## Why This Rule Matters

Dynamic code execution through `eval()` and similar functions poses significant security risks:

1. **Code Injection Vulnerabilities**: Untrusted input can be executed as code
2. **Performance Issues**: Dynamic code execution is slower than static code
3. **Debugging Difficulties**: Dynamic code is harder to debug and analyze
4. **Security Auditing**: Static analysis tools cannot analyze dynamically generated code

## What This Rule Detects

### ❌ Dangerous Functions

- `eval()` - Direct code execution
- `new Function()` - Function constructor with string
- `setTimeout(string)` - Timer with string code
- `setInterval(string)` - Interval with string code
- `execScript()` - Legacy IE function
- `setImmediate(string)` - Immediate execution with string

### ❌ Global Access Patterns

- `window.eval()`
- `global.eval()`
- `globalThis.eval()`
- `self.eval()`

### ❌ Suspicious Variable Patterns

Variables containing dynamic code indicators:

- Variables named with `code`, `script`, `expression`, `formula`, `template`, `eval`

## Examples

### ❌ Violations

```javascript
// Direct eval usage
eval("console.log('Hello')"); // ERROR

// Function constructor
const fn = new Function("return 1 + 1"); // ERROR

// setTimeout with string
setTimeout("console.log('test')", 1000); // WARNING

// Global eval access
window.eval("alert('test')"); // ERROR

// Dynamic code variables
const userCode = req.body.code;
eval(userCode); // ERROR - code injection risk
```

### ✅ Safe Alternatives

```javascript
// Instead of eval(), use proper parsing and validation
const result = JSON.parse(jsonString);

// Instead of Function constructor, use proper function definitions
function add(a, b) {
  return a + b;
}

// Instead of setTimeout with string, use function reference
setTimeout(() => console.log("test"), 1000);

// Instead of dynamic code execution, use configuration objects
const actions = {
  add: (a, b) => a + b,
  multiply: (a, b) => a * b,
};
const result = actions[operation](x, y);

// For template engines, use safe templating libraries
const template = handlebars.compile(templateString);
const result = template(data);
```

## Configuration

The rule can be configured in `config.json`:

```json
{
  "validation": {
    "dangerousFunctions": ["eval", "Function", "setTimeout", "setInterval"],
    "dangerousPatterns": ["new Function", "window.eval", "global.eval"],
    "dynamicCodeIndicators": ["code", "script", "expression", "formula"]
  }
}
```

## Security Best Practices

1. **Input Validation**: Always validate and sanitize user input
2. **Use Safe Alternatives**: Prefer configuration objects over dynamic code
3. **Template Engines**: Use established, secure template libraries
4. **Content Security Policy**: Implement CSP headers to prevent code injection
5. **Code Review**: Carefully review any dynamic code patterns

## Related Rules

- **S023**: JSON Injection Protection
- **S025**: Server-side Validation
- **S056**: Log Injection Protection

## Severity Levels

- **ERROR**: Direct `eval()`, `Function()` constructor, global eval access
- **WARNING**: `setTimeout`/`setInterval` with strings, suspicious variable patterns

## Framework-Specific Notes

### Node.js

- Be especially careful with `vm` module usage
- Avoid `child_process.exec()` with user input

### Browser

- Consider Content Security Policy to prevent eval
- Be cautious with `innerHTML` and similar DOM manipulation

### React/Vue

- Avoid `dangerouslySetInnerHTML` with user content
- Use proper event handlers instead of inline scripts
