const fs = require('fs');

class S036Analyzer {
  constructor() {
    this.ruleId = 'S036';
    this.ruleName = 'LFI/RFI Protection';
  }

  async analyze(files, language, options = {}) {
    const violations = [];

    for (const filePath of files) {
      // Skip test files
      if (this.isTestFile(filePath)) {
        continue;
      }

      try {
        const content = fs.readFileSync(filePath, 'utf8');
        const fileViolations = this.analyzeFile(content, filePath);
        violations.push(...fileViolations);
      } catch (error) {
        if (options.verbose) {
          console.warn(`S036: Error analyzing ${filePath}:`, error.message);
        }
      }
    }

    return violations;
  }

  isTestFile(filePath) {
    const testPatterns = [
      /\.test\.(ts|tsx|js|jsx|php|py)$/,
      /\.spec\.(ts|tsx|js|jsx|php|py)$/,
      /__tests__\//,
      /__mocks__\//,
      /\/tests?\//,
    ];
    return testPatterns.some(p => p.test(filePath));
  }

  analyzeFile(content, filePath) {
    const violations = [];
    const lines = content.split(/\r?\n/);

    lines.forEach((line, index) => {
      const lineNumber = index + 1;
      const trimmed = line.trim();

      // Skip comments
      if (trimmed.startsWith('//') || trimmed.startsWith('#') || trimmed.startsWith('/*')) {
        return;
      }

      // Check for unsafe file operations
      violations.push(...this.checkUnsafeFileOperations(line, lineNumber, filePath));

      // Check for path traversal
      violations.push(...this.checkPathTraversal(line, lineNumber, filePath));

      // Check for remote file inclusion
      violations.push(...this.checkRemoteFileInclusion(line, lineNumber, filePath));
    });

    return violations;
  }

  checkUnsafeFileOperations(line, lineNumber, filePath) {
    const violations = [];

    // Unsafe file read/include patterns with user input
    const unsafePatterns = [
      // JavaScript/TypeScript
      {
        pattern: /(?:fs\.readFileSync|fs\.readFile|require|import)\s*\(\s*[^)]*(?:req\.|request\.|params\.|query\.|body\.)[^)]*\)/gi,
        message: 'Unsafe file operation with user input - validate and use allowlist',
      },
      {
        pattern: /(?:fs\.readFileSync|fs\.readFile|fs\.createReadStream)\s*\(\s*[`'"](.*?)(?:\$\{[^}]+\}|%s|%d)[^`'"]*[`'"]\s*\)/gi,
        message: 'File path uses string interpolation with potential user input - validate path',
      },

      // PHP
      {
        pattern: /(?:include|require|include_once|require_once|fopen|file_get_contents|readfile)\s*\(\s*\$_(?:GET|POST|REQUEST|COOKIE|SERVER)/gi,
        message: 'PHP: Direct use of superglobal in file operation - extreme LFI/RFI risk',
      },

      // Python
      {
        pattern: /(?:open|exec|execfile|compile|__import__)\s*\(\s*(?:request\.|params\.|args\.|form\.)/gi,
        message: 'Python: File operation with user input - validate and sanitize',
      },
    ];

    unsafePatterns.forEach(({ pattern, message }) => {
      if (pattern.test(line)) {
        violations.push({
          file: filePath,
          line: lineNumber,
          column: 1,
          message: message,
          severity: 2, // error
          ruleId: this.ruleId,
        });
      }
    });

    return violations;
  }

  checkPathTraversal(line, lineNumber, filePath) {
    const violations = [];

    // Skip import/require statements - these are safe module imports
    if (this.isImportStatement(line)) {
      return violations;
    }

    // Only check path traversal in actual file operations
    // Path traversal patterns in file operations
    const traversalPatterns = [
      {
        // Path traversal in file operations
        pattern: /(?:fs\.readFile|readFile|fopen|file_get_contents|open|sendFile|readFileSync|createReadStream)\s*\([^)]*\.\.\/[^)]*\)/gi,
        message: 'Path traversal in file operation (../) - normalize and validate paths',
      },
      {
        pattern: /(?:fs\.readFile|readFile|fopen|file_get_contents|open|sendFile|readFileSync|createReadStream)\s*\([^)]*\.\.\\[^)]*\)/gi,
        message: 'Path traversal in file operation (..\\) - normalize and validate paths',
      },
      {
        pattern: /(?:fs\.readFile|readFile|fopen|file_get_contents|open|sendFile|readFileSync|createReadStream)\s*\([^)]*\/etc\/passwd[^)]*\)/gi,
        message: 'Suspicious file path (/etc/passwd) - potential LFI attempt',
      },
      {
        pattern: /(?:fs\.readFile|readFile|fopen|file_get_contents|open|sendFile|readFileSync|createReadStream)\s*\([^)]*C:\\Windows\\system32[^)]*\)/gi,
        message: 'Suspicious file path (Windows system32) - potential LFI attempt',
      },
    ];

    traversalPatterns.forEach(({ pattern, message }) => {
      const match = line.match(pattern);
      if (match && !this.isSafeContext(line)) {
        violations.push({
          file: filePath,
          line: lineNumber,
          column: 1,
          message: message,
          severity: 2, // error
          ruleId: this.ruleId,
        });
      }
    });

    return violations;
  }

  checkRemoteFileInclusion(line, lineNumber, filePath) {
    const violations = [];

    // Remote file inclusion patterns
    const rfiPatterns = [
      {
        pattern: /(?:require|import|include|include_once|require_once)\s*\(\s*['"`]https?:\/\//gi,
        message: 'Remote File Inclusion (RFI) detected - never include remote URLs',
      },
      {
        pattern: /(?:fs\.readFile|file_get_contents|fopen|urllib\.request\.urlopen)\s*\(\s*[^)]*(?:http:\/\/|https:\/\/)[^)]*\)/gi,
        message: 'Loading remote file content - validate URL allowlist',
      },
      {
        pattern: /eval\s*\(\s*(?:fs\.readFileSync|file_get_contents|fetch|axios)\s*\(/gi,
        message: 'Eval with file content - extreme code injection risk',
      },
    ];

    rfiPatterns.forEach(({ pattern, message }) => {
      if (pattern.test(line)) {
        violations.push({
          file: filePath,
          line: lineNumber,
          column: 1,
          message: message,
          severity: 2, // error
          ruleId: this.ruleId,
        });
      }
    });

    return violations;
  }

  isImportStatement(line) {
    // Check if this is an import/require statement (safe module imports)
    const importPatterns = [
      /^\s*import\s+/,
      /^\s*export\s+.*from\s+/,
      /^\s*const\s+.*=\s*require\s*\(/,
      /^\s*let\s+.*=\s*require\s*\(/,
      /^\s*var\s+.*=\s*require\s*\(/,
      /^\s*import\s*\(/,  // dynamic import
    ];

    return importPatterns.some(p => p.test(line));
  }

  isSafeContext(line) {
    // Check if line is in a safe context (e.g., configuration, constants)
    const safePatterns = [
      /const\s+[A-Z_]+\s*=/,  // Constants
      /BASE_PATH|ROOT_DIR|PUBLIC_DIR|STATIC_DIR/,
      /path\.join\s*\(\s*__dirname/,  // Relative to current dir
      /\.resolve\s*\(/,  // path.resolve
    ];

    return safePatterns.some(p => p.test(line));
  }

  cleanup() {}
}

module.exports = S036Analyzer;
