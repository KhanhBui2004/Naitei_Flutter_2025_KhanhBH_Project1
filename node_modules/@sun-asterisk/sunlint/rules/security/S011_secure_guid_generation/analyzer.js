/**
 * S011 - Secure GUID Generation
 *
 * Main analyzer using symbol-based analysis to detect weak GUID/UUID generation
 * for security purposes.
 *
 * Based on:
 * - OWASP A02:2021 - Cryptographic Failures
 * - CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator
 */

// Command: node cli.js --rule=S011 --input=examples/rule-test-fixtures/rules/S011_secure_guid_generation --engine=heuristic

const S011SymbolBasedAnalyzer = require("./symbol-based-analyzer");

class S011Analyzer {
  constructor(options = {}) {
    this.ruleId = "S011";
    this.semanticEngine = options.semanticEngine || null;
    this.verbose = options.verbose || false;

    try {
      this.symbolAnalyzer = new S011SymbolBasedAnalyzer(this.semanticEngine);
    } catch (e) {
      console.warn(`⚠ [S011] Failed to create symbol analyzer: ${e.message}`);
    }
  }

  async initialize(semanticEngine) {
    this.semanticEngine = semanticEngine;
    if (this.symbolAnalyzer && this.symbolAnalyzer.initialize) {
      await this.symbolAnalyzer.initialize(semanticEngine);
    }
  }

  analyzeSingle(filePath, options = {}) {
    return this.analyze([filePath], "typescript", options);
  }

  async analyze(files, language, options = {}) {
    const violations = [];
    for (const filePath of files) {
      try {
        const vs = await this.analyzeFile(filePath, options);
        violations.push(...vs);
      } catch (e) {
        console.warn(`⚠ [S011] Analysis error for ${filePath}: ${e.message}`);
      }
    }
    return violations;
  }

  async analyzeFile(filePath, options = {}) {
    const violationMap = new Map();

    if (!this.symbolAnalyzer) {
      return [];
    }

    // Skip test files, build directories, and node_modules
    if (this.shouldSkipFile(filePath)) {
      return [];
    }

    try {
      let sourceFile = null;
      if (this.semanticEngine?.project) {
        sourceFile = this.semanticEngine.project.getSourceFile(filePath);
      }

      if (!sourceFile) {
        // Create temporary ts-morph source file
        const fs = require("fs");
        const path = require("path");
        const { Project } = require("ts-morph");
        if (!fs.existsSync(filePath)) {
          throw new Error(`File not found: ${filePath}`);
        }
        const content = fs.readFileSync(filePath, "utf8");
        const tmp = new Project({
          useInMemoryFileSystem: true,
          compilerOptions: { allowJs: true },
        });
        sourceFile = tmp.createSourceFile(path.basename(filePath), content);
      }

      if (sourceFile) {
        const symbolViolations = await this.symbolAnalyzer.analyze(
          sourceFile,
          filePath
        );
        symbolViolations.forEach((v) => {
          const key = `${v.line}:${v.column}:${v.message}`;
          if (!violationMap.has(key)) violationMap.set(key, v);
        });
      }
    } catch (e) {
      console.warn(`⚠ [S011] Symbol analysis failed: ${e.message}`);
    }

    return Array.from(violationMap.values()).map((v) => ({
      ...v,
      filePath,
      file: filePath,
    }));
  }

  shouldSkipFile(filePath) {
    const skipPatterns = [
      "test/",
      "tests/",
      "__tests__/",
      ".test.",
      ".spec.",
      "node_modules/",
      "build/",
      "dist/",
      ".next/",
      "coverage/",
      "vendor/",
      "mocks/",
      ".mock.",
    ];

    return skipPatterns.some((pattern) => filePath.includes(pattern));
  }

  cleanup() {
    if (this.symbolAnalyzer?.cleanup) {
      this.symbolAnalyzer.cleanup();
    }
  }
}

module.exports = S011Analyzer;
