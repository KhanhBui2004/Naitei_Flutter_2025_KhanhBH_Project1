# C033: Separate Service and Repository Logic

## Rule Description

**M·ª•c ti√™u:** T√°ch r√µ r√†ng business logic v√† data access logic trong ki·∫øn tr√∫c ·ª©ng d·ª•ng

### Nguy√™n t·∫Øc

- ‚úÖ **Repository** ch·ªâ ch·ª©a c√°c ph∆∞∆°ng th·ª©c truy v·∫•n d·ªØ li·ªáu c∆° b·∫£n (CRUD)
- ‚úÖ **Service** ch·ª©a business logic v√† s·ª≠ d·ª•ng Repository ƒë·ªÉ truy v·∫•n d·ªØ li·ªáu
- ‚úÖ M·ªói Service n√™n c√≥ m·ªôt Repository t∆∞∆°ng ·ª©ng
- ‚úÖ S·ª≠ d·ª•ng dependency injection ƒë·ªÉ inject Repository v√†o Service
- ‚ùå Tr√°nh vi·∫øt business logic trong Repository
- ‚ùå Service kh√¥ng n√™n tr·ª±c ti·∫øp g·ªçi database/ORM

### L·ª£i √≠ch

- üîÑ TƒÉng kh·∫£ nƒÉng t√°i s·ª≠ d·ª•ng v√† test
- üéØ T√°ch bi·ªát r√µ r√†ng gi·ªØa business logic v√† data access
- üîß D·ªÖ d√†ng thay ƒë·ªïi implementation c·ªßa data access layer
- üìà TƒÉng t√≠nh maintainable c·ªßa code
- ‚ú® Tu√¢n th·ªß nguy√™n t·∫Øc Single Responsibility

## Architecture

Rule n√†y s·ª≠ d·ª•ng **hybrid analysis approach**:

1. **Primary: Symbol-based Analysis** (ts-morph AST)
   - Ph√¢n t√≠ch semantic v√† symbol resolution
   - Ph√°t hi·ªán ch√≠nh x√°c database operations
   - Ki·ªÉm tra dependency injection patterns
   - Ph√°t hi·ªán business logic trong Repository

2. **Fallback: Regex-based Analysis**
   - Pattern matching khi symbol analysis kh√¥ng kh·∫£ d·ª•ng
   - X·ª≠ l√Ω edge cases v√† complex code structures

## Files Structure

```
C033_separate_service_repository/
‚îú‚îÄ‚îÄ analyzer.js              # Main hybrid orchestrator
‚îú‚îÄ‚îÄ symbol-based-analyzer.js # Primary AST-based analysis
‚îú‚îÄ‚îÄ regex-based-analyzer.js  # Fallback pattern matching
‚îú‚îÄ‚îÄ config.json             # Rule configuration
‚îî‚îÄ‚îÄ README.md               # This documentation
```

## What this rule detects

### üö´ Violations in Service files

- Direct database/ORM operations without Repository
  - `findOne()`, `save()`, `update()`, `delete()`, `query()`
  - `createQueryBuilder()`, `getRepository()`, `getConnection()`
- Service kh√¥ng inject Repository qua constructor
- Mixed business logic v·ªõi data access trong c√πng method

### üö´ Violations in Repository files

- Business logic trong Repository methods
  - Method names ch·ª©a: `validate`, `calculate`, `process`, `transform`
  - Logic ph·ª©c t·∫°p: nhi·ªÅu if/else, loops (>2 control structures)
- Business calculations, validations, transformations
- Complex workflows v√† business rules

### üö´ Violations in Controller files

- Controller tr·ª±c ti·∫øp g·ªçi database operations
- B·ªè qua Service layer

### üö´ Architecture violations

- Service v√† Repository c√πng trong m·ªôt file
- Kh√¥ng t√°ch bi·ªát concerns r√µ r√†ng

## Examples

### ‚ùå BAD: Service directly accessing database

```typescript
// service-bad.ts
class UserService {
  async getUser(id: string) {
    // VIOLATION: Direct database access in Service
    return await this.dataSource
      .getRepository(User)
      .findOne({ where: { id } });
  }
}
```

### ‚úÖ GOOD: Service uses Repository

```typescript
// user.service.ts
class UserService {
  constructor(
    private readonly userRepository: UserRepository  // DI
  ) {}
  
  async getUser(id: string) {
    return await this.userRepository.findById(id);
  }
  
  async validateAndCreateUser(data: CreateUserDto) {
    // Business logic in Service
    this.validate(data);
    const user = this.transform(data);
    return await this.userRepository.create(user);
  }
}

// user.repository.ts  
class UserRepository {
  // Only CRUD operations
  async findById(id: string) {
    return await this.db.users.findOne({ where: { id } });
  }
  
  async create(user: User) {
    return await this.db.users.save(user);
  }
}
```

### ‚ùå BAD: Repository with business logic

```typescript
// repository-bad.ts
class UserRepository {
  async validateAndSave(user: User) {
    // VIOLATION: Business logic in Repository
    if (user.age < 18) {
      throw new Error('User must be 18+');
    }
    
    if (!user.email.includes('@')) {
      throw new Error('Invalid email');
    }
    
    return await this.save(user);
  }
}
```

### ‚úÖ GOOD: Repository only handles data access

```typescript
// repository-good.ts
class UserRepository {
  // Simple CRUD - no business logic
  async save(user: User) {
    return await this.db.users.save(user);
  }
  
  async findByEmail(email: string) {
    return await this.db.users.findOne({ where: { email } });
  }
}

- **Violations**: `examples/rule-test-fixtures/rules/C033_separate_service_repository/violations/test-cases.js`
- **Clean code**: `examples/rule-test-fixtures/rules/C033_separate_service_repository/clean/good-examples.js`

## Usage

```bash
# Test violations
node cli.js --rule=C033 --input=examples/rule-test-fixtures/rules/C033_separate_service_repository/violations --engine=heuristic

# Test clean code
node cli.js --rule=C033 --input=examples/rule-test-fixtures/rules/C033_separate_service_repository/clean --engine=heuristic
```

## Technical Implementation

- **Primary Analysis**: Semantic analysis using ts-morph for AST traversal
- **Fallback**: Regex pattern matching for environments without ts-morph
- **Engine**: Heuristic engine (registered in enhanced-rules-registry.js)
- **File Detection**: Classifies files as Service/Repository based on naming patterns

## Philosophy

This rule enforces the Repository Pattern and Domain-Driven Design principles:

1. **Separation of Concerns**: Business logic in Services, data access in Repositories
2. **Testability**: Each layer can be tested independently
3. **Maintainability**: Changes to business rules don't affect data access code
4. **Flexibility**: Data storage can be changed without affecting business logic
