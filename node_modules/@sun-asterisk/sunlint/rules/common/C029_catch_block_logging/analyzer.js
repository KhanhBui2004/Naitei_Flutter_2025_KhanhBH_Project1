/**
 * C029 Analyzer - ts-morph based
 * 
 * Validates catch block logging with AST-based analysis:
 * 1. Detects empty catch blocks
 * 2. Validates logging presence and quality
 * 3. Checks log levels (error vs warn vs log)
 * 4. Validates error variable usage
 * 5. Checks stack trace inclusion
 * 6. Validates context data
 * 7. Supports delegation pattern (calling helper functions)
 */

const { Project, SyntaxKind, Node } = require('ts-morph');
const path = require('path');
const fs = require('fs');

class C029Analyzer {
  constructor(semanticEngine = null) {
    this.ruleId = 'C029';
    this.ruleName = 'Catch Block Logging Validation';
    this.description = 'Validates comprehensive error logging in catch blocks';
    this.semanticEngine = semanticEngine;
    this.project = null;
    this.verbose = false;

    // Logging patterns configuration
    this.config = {
      // Valid logging methods (console, logger, etc.)
      loggingMethods: [
        'console.error', 'console.warn', 'console.log', 'console.info', 'console.debug',
        'logger.error', 'logger.warn', 'logger.info', 'logger.debug', 'logger.log',
        'log.error', 'log.warn', 'log.info', 'log.debug',
        'this.logger.error', 'this.logger.warn', 'this.logger.info',
        'this.logError', 'this.logErrors', 'this.couponLogErrors',
        'Logger.error', 'Logger.warn', 'Logger.info'
      ],

      // Appropriate log levels for catch blocks (should use error/warn)
      appropriateLevels: ['error', 'warn'],
      
      // Inappropriate log levels (should avoid log/info/debug in catch)
      inappropriateLevels: ['log', 'info', 'debug'],

      // Error handling methods (throw, rethrow)
      errorHandlingMethods: [
        'throw', 'rethrow', 'handleError', 'processError', 
        'reportError', 'trackError', 'sendError'
      ],

      // Test file patterns (more lenient checking)
      testPatterns: ['__tests__', '.test.', '.spec.', '/test/', '/tests/', '.stories.', '-test.', '-spec.', 'test-fixtures']
    };
  }

  async initialize(semanticEngine = null) {
    if (semanticEngine) {
      this.semanticEngine = semanticEngine;
    }
    this.verbose = semanticEngine?.verbose || false;

    // Use semantic engine's project if available, otherwise create standalone
    if (this.semanticEngine?.project) {
      this.project = this.semanticEngine.project;
      if (this.verbose) {
        console.log('[DEBUG] ðŸŽ¯ C029: Using semantic engine project');
      }
    } else {
      this.project = new Project({
        compilerOptions: {
          target: 99, // Latest
          module: 99, // ESNext
          allowJs: true,
          checkJs: false,
        },
      });
      if (this.verbose) {
        console.log('[DEBUG] ðŸŽ¯ C029: Created standalone ts-morph project');
      }
    }
  }

  async analyze(files, language, options = {}) {
    this.verbose = options.verbose || this.verbose;
    
    if (!this.project) {
      await this.initialize();
    }

    const violations = [];

    for (const filePath of files) {
      try {
        const fileViolations = await this.analyzeFile(filePath, options);
        violations.push(...fileViolations);
      } catch (error) {
        if (this.verbose) {
          console.warn(`[C029] Error analyzing ${filePath}:`, error.message);
        }
      }
    }

    if (this.verbose) {
      console.log(`[C029] Total violations found: ${violations.length}`);
    }

    return violations;
  }

  async analyzeFile(filePath, options = {}) {
    const violations = [];

    // Get or add source file
    let sourceFile = this.project.getSourceFile(filePath);
    if (!sourceFile) {
      sourceFile = this.project.addSourceFileAtPath(filePath);
    }

    if (this.verbose) {
      console.log(`[C029] Analyzing ${path.basename(filePath)}...`);
    }

    // Find all try statements
    const tryStatements = sourceFile.getDescendantsOfKind(SyntaxKind.TryStatement);

    if (this.verbose) {
      console.log(`[C029] Found ${tryStatements.length} try statements`);
    }

    for (const tryStatement of tryStatements) {
      const catchClause = tryStatement.getCatchClause();
      
      if (catchClause) {
        const catchViolations = this.analyzeCatchClause(catchClause, filePath, sourceFile);
        violations.push(...catchViolations);
      }
    }

    return violations;
  }

  analyzeCatchClause(catchClause, filePath, sourceFile) {
    const violations = [];
    const block = catchClause.getBlock();
    const variableDeclaration = catchClause.getVariableDeclaration();
    
    // Get exception variable name (e, error, err, etc.)
    const exceptionVar = variableDeclaration 
      ? variableDeclaration.getName() 
      : null;

    const startLine = catchClause.getStartLineNumber();
    const startColumn = catchClause.getStart() - catchClause.getStartLinePos() + 1;

    // STAGE 1: Check if catch block is empty
    if (this.isEmptyCatchBlock(block)) {
      // Allow empty catch in test files if there's any comment explaining it
      const hasComment = this.hasAnyComment(catchClause);
      if (this.isTestFile(filePath) && hasComment) {
        // Test files with explanatory comments are OK
        return violations;
      }

      // Allow empty catch if there's a finally block with cleanup
      // Common pattern: try { } catch { } finally { setLoading(false); }
      const tryStatement = catchClause.getParent();
      if (tryStatement && tryStatement.getFinallyBlock()) {
        const finallyBlock = tryStatement.getFinallyBlock();
        const finallyText = finallyBlock.getText();

        // Check if finally block does cleanup (setState, setLoading, cleanup, etc.)
        const cleanupPatterns = [
          /set[A-Z]\w*\s*\(/,        // setLoading, setState, setError, etc.
          /cleanup/i,                 // cleanup function
          /reset/i,                   // reset function
          /\.close\s*\(/,            // close connections
          /\.disconnect\s*\(/,       // disconnect
          /finally/i                  // any finally-related code
        ];

        if (cleanupPatterns.some(pattern => pattern.test(finallyText))) {
          return violations; // Acceptable: empty catch with finally cleanup
        }
      }

      violations.push(this.createViolation(
        filePath,
        startLine,
        startColumn,
        'empty_catch',
        'Empty catch block - errors are silently ignored',
        'Add error logging or explicit comment explaining why error is ignored',
        0.95
      ));
      return violations; // No need to check further
    }

    // STAGE 2: Find logging calls in catch block
    const loggingInfo = this.findLoggingCalls(block, exceptionVar);

    if (loggingInfo.hasLogging) {
      // STAGE 3: Validate logging quality
      const qualityIssues = this.validateLoggingQuality(loggingInfo, exceptionVar, filePath);
      violations.push(...qualityIssues.map(issue => 
        this.createViolation(
          filePath,
          startLine,
          startColumn,
          issue.type,
          issue.message,
          issue.suggestion,
          issue.confidence
        )
      ));
    } else {
      // No logging found - check if there's valid error handling
      const hasErrorHandling = this.hasValidErrorHandling(block, exceptionVar);

      // Skip if underscore variable (intentional ignore) AND has error handling
      const isIntentionallyIgnored = exceptionVar && exceptionVar.startsWith('_');
      const shouldSkip = (isIntentionallyIgnored && hasErrorHandling) || this.isTestFile(filePath);

      if (!hasErrorHandling && !shouldSkip) {
        violations.push(this.createViolation(
          filePath,
          startLine,
          startColumn,
          'no_logging',
          exceptionVar
            ? `Catch block does not log exception '${exceptionVar}'`
            : 'Catch block does not log exception',
          'Add console.error() or logger.error() with error details',
          0.85
        ));
      }
    }

    // STAGE 4: Check for unused exception variable
    // Skip if variable name starts with underscore (conventional way to indicate intentional ignore)
    const isIntentionallyIgnored = exceptionVar && exceptionVar.startsWith('_');

    if (exceptionVar && !isIntentionallyIgnored && !this.isExceptionUsed(block, exceptionVar) && !this.hasExplicitIgnoreComment(catchClause)) {
      violations.push(this.createViolation(
        filePath,
        startLine,
        startColumn,
        'unused_exception',
        `Exception variable '${exceptionVar}' is declared but never used`,
        `Use '${exceptionVar}' in error logging or add comment explaining why it's ignored`,
        0.80
      ));
    }

    return violations;
  }

  /**
   * Check if catch block is empty
   */
  isEmptyCatchBlock(block) {
    const statements = block.getStatements();
    
    if (statements.length === 0) {
      return true;
    }

    // Check if only contains comments
    const text = block.getText()
      .replace(/\/\*[\s\S]*?\*\//g, '') // Remove block comments
      .replace(/\/\/.*$/gm, '')          // Remove line comments
      .replace(/\{|\}/g, '')             // Remove braces
      .trim();
    
    return text.length === 0;
  }

  /**
   * Find all logging calls in catch block
   */
  findLoggingCalls(block, exceptionVar) {
    const loggingInfo = {
      hasLogging: false,
      calls: [],
      usesExceptionVar: false,
      logLevels: [],
      hasStackTrace: false,
      hasContextData: false,
      loggingExpressions: [] // Track actual expressions used
    };

    // Find all call expressions
    const callExpressions = block.getDescendantsOfKind(SyntaxKind.CallExpression);

    for (const call of callExpressions) {
      const expression = call.getExpression();
      const expressionText = expression.getText();

      // Check if it's a logging call
      const isLogging = this.config.loggingMethods.some(method => 
        expressionText.includes(method.split('.')[0]) && 
        (expressionText.endsWith('.error') || 
         expressionText.endsWith('.warn') ||
         expressionText.endsWith('.log') ||
         expressionText.endsWith('.info') ||
         expressionText.endsWith('.debug') ||
         expressionText.includes('logError') ||
         expressionText.includes('logErrors'))
      );

      if (isLogging) {
        loggingInfo.hasLogging = true;

        // Extract log level
        const logLevel = this.extractLogLevel(expressionText);
        if (logLevel) {
          loggingInfo.logLevels.push(logLevel);
        }

        // Check if exception variable is used in arguments
        const args = call.getArguments();
        const argsText = args.map(arg => arg.getText()).join(' ');
        
        if (exceptionVar && argsText.includes(exceptionVar)) {
          loggingInfo.usesExceptionVar = true;

          // Check for stack trace
          if (argsText.includes(`${exceptionVar}.stack`) || 
              argsText.includes(`${exceptionVar}.message`)) {
            loggingInfo.hasStackTrace = true;
          }
        }

        // Check for context data (objects, multiple arguments)
        if (args.length > 1 || this.hasObjectLiteral(args)) {
          loggingInfo.hasContextData = true;
        }

        loggingInfo.calls.push({
          expression: expressionText,
          level: logLevel,
          arguments: argsText,
          line: call.getStartLineNumber()
        });

        // Track expression for better error messages
        loggingInfo.loggingExpressions.push(expressionText);
      }
    }

    return loggingInfo;
  }

  /**
   * Extract log level from expression (error, warn, log, info, debug)
   */
  extractLogLevel(expressionText) {
    if (expressionText.includes('.error') || expressionText.includes('logError')) return 'error';
    if (expressionText.includes('.warn')) return 'warn';
    if (expressionText.includes('.log')) return 'log';
    if (expressionText.includes('.info')) return 'info';
    if (expressionText.includes('.debug')) return 'debug';
    return null;
  }

  /**
   * Check if arguments contain object literals (context data)
   */
  hasObjectLiteral(args) {
    return args.some(arg => 
      arg.getKind() === SyntaxKind.ObjectLiteralExpression
    );
  }

  /**
   * Validate logging quality
   */
  validateLoggingQuality(loggingInfo, exceptionVar, filePath) {
    const issues = [];

    // Issue 1: Using inappropriate log level (log/info/debug instead of error/warn)
    // BUT only for console.xxx, not for logger.xxx (custom loggers may have different semantics)
    const hasInappropriateConsoleLevel = loggingInfo.calls.some(call => {
      const isConsole = call.expression.startsWith('console.');
      const isInappropriateLevel = this.config.inappropriateLevels.includes(call.level);
      return isConsole && isInappropriateLevel;
    });

    if (hasInappropriateConsoleLevel && !this.isTestFile(filePath)) {
      // Get only console calls with inappropriate levels
      const consoleLevels = loggingInfo.calls
        .filter(c => c.expression.startsWith('console.') && this.config.inappropriateLevels.includes(c.level))
        .map(c => c.level);

      issues.push({
        type: 'inappropriate_log_level',
        message: `Catch block uses console.${[...new Set(consoleLevels)].join('/')} instead of console.error or console.warn`,
        suggestion: 'Use console.error() or console.warn() for error logging in catch blocks',
        confidence: 0.75
      });
    }

    // Issue 2: Exception variable not included in logging
    // Skip if variable is underscore (intentional ignore - developer explicitly doesn't want error details)
    const isIntentionallyIgnored = exceptionVar && exceptionVar.startsWith('_');

    if (exceptionVar && !isIntentionallyIgnored && !loggingInfo.usesExceptionVar) {
      issues.push({
        type: 'exception_not_logged',
        message: `Exception variable '${exceptionVar}' is not included in logging`,
        suggestion: `Include '${exceptionVar}' in console.error() to preserve error details`,
        confidence: 0.85
      });
    }

    // REMOVED: Issue 3 & 4 (missing stack trace and context data)
    // These are optional best practices, not violations. They created too much noise.
    // Teams can enable them separately if desired through configuration.

    return issues;
  }

  /**
   * Check if catch block has valid error handling
   * Accepts: throw, return with error, error handlers, delegation to any function with exception
   */
  hasValidErrorHandling(block, exceptionVar) {
    const text = block.getText();

    // Pattern 1: Re-throwing error
    if (/\bthrow\b/.test(text)) {
      return true;
    }

    // Pattern 2: Return statement with exception variable
    // Accept: return error, return handleError(error), return {error}
    // Reject: return null, return false (no error info)
    if (exceptionVar && /\breturn\b/.test(text)) {
      const returnStatements = block.getDescendantsOfKind(SyntaxKind.ReturnStatement);
      for (const returnStmt of returnStatements) {
        const returnExpr = returnStmt.getExpression();
        if (returnExpr) {
          const returnText = returnExpr.getText();
          // Check if return expression includes exception variable
          if (new RegExp(`\\b${exceptionVar}\\b`).test(returnText)) {
            return true;
          }
        }
      }
    }

    // Pattern 2b: Return default value (defensive programming)
    // Common in frontend: catch { return []; } or catch { return null; }
    // This is acceptable - returning safe default instead of crashing
    if (/\breturn\b/.test(text)) {
      const returnStatements = block.getDescendantsOfKind(SyntaxKind.ReturnStatement);
      const statements = block.getStatements();

      // If catch block ONLY contains a return statement, it's defensive programming
      if (returnStatements.length === 1 && statements.length === 1) {
        return true; // Acceptable pattern: return default value
      }
    }

    // Pattern 3: Common error handler functions and external error trackers
    const errorHandlerPatterns = [
      /handleError\s*\(/,
      /processError\s*\(/,
      /reportError\s*\(/,
      /trackError\s*\(/,
      /sendError\s*\(/,
      /errorHandler\s*\(/,
      /externalErrorHandler\s*\(/,
      /logError\s*\(/,
      /captureError\s*\(/,
      /recordError\s*\(/,
      // External error tracking services
      /Sentry\.captureException\s*\(/,
      /Bugsnag\.notify\s*\(/,
      /Rollbar\.error\s*\(/,
      /Airbrake\.notify\s*\(/,
      /Raygun\.send\s*\(/,
      // Common utility patterns
      /sendToSentry\s*\(/,
      /utils?\.log/i,
      /helpers?\.log/i,
      /ErrorUtils/,
      /ErrorService/,
      // UI Feedback patterns (toast, notification, alert, etc.)
      /toast\.(error|failed|show|warning)\s*\(/,
      /notification\.(error|show|warning)\s*\(/,
      /message\.(error|show|warning)\s*\(/,
      /alert\s*\(/,
      /showError\s*\(/,
      /showMessage\s*\(/,
      // Fallback/recovery actions
      /window\.open\s*\(/,
      /window\.location/,
      /navigate\s*\(/,
      /redirect\s*\(/,
      /router\.(push|replace)\s*\(/
    ];

    if (errorHandlerPatterns.some(pattern => pattern.test(text))) {
      return true;
    }

    // Pattern 4: React/Vue state management (error stored in state)
    // Examples: setError(error), dispatch(setError(error)), setState({error})
    if (exceptionVar) {
      const stateManagementPatterns = [
        /set[A-Z]\w*\s*\(/,           // setState, setError, setLoading
        /dispatch\s*\(/,               // Redux dispatch
        /commit\s*\(/,                 // Vuex commit
        /this\.setState\s*\(/,         // Class component setState
        /useState/,                    // React hooks
        /useReducer/                   // React reducer hook
      ];

      if (stateManagementPatterns.some(pattern => pattern.test(text))) {
        // Check if error is passed to state function
        const callExpressions = block.getDescendantsOfKind(SyntaxKind.CallExpression);
        for (const call of callExpressions) {
          const args = call.getArguments();
          const argsText = args.map(arg => arg.getText()).join(' ');
          if (new RegExp(`\\b${exceptionVar}\\b`).test(argsText)) {
            return true; // Error stored in state
          }
        }
      }
    }

    // Pattern 5: Delegation - calling ANY function/helper with exception variable
    // Examples: handleApiError(error), utils.logException(err), sendToSentry(e)
    if (exceptionVar) {
      const callExpressions = block.getDescendantsOfKind(SyntaxKind.CallExpression);

      for (const call of callExpressions) {
        const args = call.getArguments();

        // Check if exception variable is passed to any function
        for (const arg of args) {
          const argText = arg.getText().trim();

          // Direct usage: someFunction(error)
          if (argText === exceptionVar) {
            return true;
          }

          // Property access: someFunction(error.message)
          if (argText.startsWith(exceptionVar + '.')) {
            return true;
          }

          // In object/array: someFunction({error: error})
          if (new RegExp(`\\b${exceptionVar}\\b`).test(argText)) {
            return true;
          }
        }
      }
    }

    return false;
  }

  /**
   * Check if exception variable is used anywhere in catch block
   */
  isExceptionUsed(block, exceptionVar) {
    const text = block.getText();
    
    // Simple regex to find usage of exception variable
    const usageRegex = new RegExp(`\\b${exceptionVar}\\b`, 'g');
    const matches = text.match(usageRegex) || [];
    
    // Exclude the catch declaration itself
    const catchDeclaration = new RegExp(`catch\\s*\\(\\s*${exceptionVar}\\s*\\)`, 'g');
    const declarationMatches = text.match(catchDeclaration) || [];
    
    return (matches.length - declarationMatches.length) > 0;
  }

  /**
   * Check if catch clause has any comment (for test files)
   */
  hasAnyComment(catchClause) {
    const text = catchClause.getText();

    // Check for any line or block comments
    const hasLineComment = /\/\/.*\S/.test(text);
    const hasBlockComment = /\/\*[\s\S]*?\*\//.test(text);

    return hasLineComment || hasBlockComment;
  }

  /**
   * Check if catch clause has explicit ignore comment
   */
  hasExplicitIgnoreComment(catchClause) {
    const text = catchClause.getText();

    const ignorePatterns = [
      /\/\/\s*ignore/i,
      /\/\/\s*TODO/i,
      /\/\/\s*FIXME/i,
      /\/\/\s*eslint-disable/i,
      /\/\*\s*ignore/i,
      /\/\*\s*TODO/i,
      /\/\*\s*FIXME/i,
      /\/\*\s*eslint-disable/i
    ];

    return ignorePatterns.some(pattern => pattern.test(text));
  }

  /**
   * Check if file is a test file (more lenient rules)
   */
  isTestFile(filePath) {
    return this.config.testPatterns.some(pattern => filePath.includes(pattern));
  }

  /**
   * Create violation object
   */
  createViolation(filePath, line, column, type, message, suggestion, confidence) {
    return {
      ruleId: this.ruleId,
      file: filePath,
      line: line,
      column: column,
      message: message,
      severity: this.getSeverity(type, confidence),
      type: type,
      confidence: confidence,
      suggestion: suggestion,
      analyzer: 'ts-morph'
    };
  }

  /**
   * Determine severity based on type and confidence
   */
  getSeverity(type, confidence) {
    // High severity violations
    const highSeverityTypes = ['empty_catch', 'no_logging', 'unused_exception'];
    if (highSeverityTypes.includes(type) && confidence > 0.8) {
      return 'error';
    }

    // Medium severity violations  
    const mediumSeverityTypes = ['exception_not_logged', 'inappropriate_log_level'];
    if (mediumSeverityTypes.includes(type) && confidence > 0.7) {
      return 'warning';
    }

    // Low severity violations (recommendations)
    return 'info';
  }
}

module.exports = C029Analyzer;
