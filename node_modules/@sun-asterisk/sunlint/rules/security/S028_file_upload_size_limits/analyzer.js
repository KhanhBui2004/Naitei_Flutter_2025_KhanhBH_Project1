/**
 * S028 Main Analyzer - Limit upload file size and number of files per user
 * Primary: Symbol-based analysis (when available)
 * Fallback: Regex-based for all other cases
 * Command: node cli.js --rule=S028 --input=examples/rule-test-fixtures/rules/S028_file_upload_size_limits --engine=heuristic
 */

const S028SymbolBasedAnalyzer = require("./symbol-based-analyzer.js");

class S028Analyzer {
  constructor(options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`ðŸ”§ [S028] Constructor called with options:`, !!options);
      console.log(
        `ðŸ”§ [S028] Options type:`,
        typeof options,
        Object.keys(options || {})
      );
    }

    this.ruleId = "S028";
    this.ruleName = "Limit upload file size and number of files per user";
    this.description =
      "File uploads must enforce size limits and file quantity limits to prevent resource exhaustion and DoS attacks. Both file size and number of files should be limited at the server-side.";
    this.semanticEngine = options.semanticEngine || null;
    this.verbose = options.verbose || false;

    // Configuration
    this.config = {
      useSymbolBased: true, // Primary approach
      maxFileSize: 10 * 1024 * 1024, // 10MB recommended
      maxFiles: 10, // 10 files recommended
      highRiskThreshold: 50 * 1024 * 1024, // 50MB
      mediumRiskThreshold: 20 * 1024 * 1024, // 20MB
    };

    // Initialize analyzer
    try {
      this.symbolAnalyzer = new S028SymbolBasedAnalyzer(this.semanticEngine);
      if (process.env.SUNLINT_DEBUG) {
        console.log(`ðŸ”§ [S028] Symbol analyzer created successfully`);
      }
    } catch (error) {
      console.error(`ðŸ”§ [S028] Error creating symbol analyzer:`, error);
    }
  }

  async initialize(semanticEngine = null) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`ðŸ”§ [S028] Initialize called`);
    }

    if (semanticEngine) {
      this.semanticEngine = semanticEngine;
      if (this.symbolAnalyzer) {
        await this.symbolAnalyzer.initialize(semanticEngine);
      }
    }

    return this;
  }

  /**
   * Analyze array of files (legacy interface)
   */
  async analyze(files, language, options = {}) {
    const violations = [];
    const fileArray = Array.isArray(files) ? files : [files];

    for (const filePath of fileArray) {
      try {
        const vs = await this.analyzeFile(filePath, options);
        violations.push(...vs);
      } catch (error) {
        console.warn(
          `âš ï¸ [S028] Analysis error for ${filePath}: ${error.message}`
        );
      }
    }

    return violations;
  }

  /**
   * Main analyze method - analyzes a single file
   */
  async analyzeFile(filePath, options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`ðŸ”§ [S028] Analyzing file:`, filePath);
    }

    // Skip test files, node_modules, etc.
    if (this.shouldSkipFile(filePath)) {
      return [];
    }

    try {
      if (!this.symbolAnalyzer) {
        console.warn(`âš ï¸ [S028] Symbol analyzer not initialized`);
        return [];
      }

      let sourceFile = null;

      // Try to get from semantic engine first
      if (this.semanticEngine?.project) {
        sourceFile = this.semanticEngine.project.getSourceFile(filePath);
      }

      // Fallback: create temporary ts-morph project
      if (!sourceFile) {
        const fs = require("fs");
        const path = require("path");
        const { Project } = require("ts-morph");

        if (!fs.existsSync(filePath)) {
          throw new Error(`File not found: ${filePath}`);
        }

        const content = fs.readFileSync(filePath, "utf8");
        const tmpProject = new Project({
          useInMemoryFileSystem: true,
          compilerOptions: { allowJs: true },
        });
        sourceFile = tmpProject.createSourceFile(
          path.basename(filePath),
          content
        );
      }

      if (!sourceFile) {
        console.warn(`âš ï¸ [S028] Could not load source file: ${filePath}`);
        return [];
      }

      // Analyze with symbol-based analyzer
      const violations = await this.symbolAnalyzer.analyze(
        sourceFile,
        filePath
      );

      if (process.env.SUNLINT_DEBUG) {
        console.log(
          `ðŸ”§ [S028] Found ${violations.length} violations in ${filePath}`
        );
      }

      return violations;
    } catch (error) {
      console.error(`âŒ [S028] Analysis error:`, error.message);
      if (process.env.SUNLINT_DEBUG) {
        console.error(error.stack);
      }
      return [];
    }
  }

  /**
   * Analyze a single file (compatibility method)
   */
  async analyzeSingle(filePath, options = {}) {
    return this.analyzeFile(filePath, options);
  }

  /**
   * Should skip file check
   */
  shouldSkipFile(filePath) {
    // Skip test files, node_modules, etc.
    const skipPatterns = [
      /node_modules/,
      /\.test\./,
      /\.spec\./,
      /test\//,
      /__tests__\//,
      /\.min\./,
      /\.bundle\./,
      /dist\//,
      /build\//,
    ];

    return skipPatterns.some((pattern) => pattern.test(filePath));
  }

  /**
   * Cleanup method
   */
  async cleanup() {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`ðŸ”§ [S028] Cleanup called`);
    }

    if (
      this.symbolAnalyzer &&
      typeof this.symbolAnalyzer.cleanup === "function"
    ) {
      await this.symbolAnalyzer.cleanup();
    }
  }
}

module.exports = S028Analyzer;
