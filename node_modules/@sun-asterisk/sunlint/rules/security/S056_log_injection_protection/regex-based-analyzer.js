/**
 * S056 Regex-Based Analyzer - Protect against Log Injection attacks  
 * Uses regular expressions for pattern-based analysis
 */

const fs = require("fs");

class S056RegexBasedAnalyzer {
  constructor() {
    this.ruleId = "S056";
    this.category = "security";

    // Regex patterns for detecting log injection vulnerabilities
    this.patterns = [
      // Direct concatenation with user input
      {
        pattern: /(logger\.|console\.)(log|info|warn|error|debug)\s*\(\s*['"`].*?\+\s*(req\.|request\.)/g,
        message: "Log injection vulnerability: Direct concatenation of user input in log statement"
      },
      // Template literals with user input
      {
        pattern: /(logger\.|console\.)(log|info|warn|error|debug)\s*\(\s*`.*?\$\{.*?(req\.|request\.)/g,
        message: "Log injection vulnerability: Template literal with user input in log statement"
      },
      // Winston/Bunyan/Pino with user input
      {
        pattern: /(winston\.|bunyan\.|pino\.)(log|info|warn|error|debug)\s*\(\s*['"`].*?\+\s*(req\.|request\.)/g,
        message: "Log injection vulnerability: User input concatenated in Winston/Bunyan/Pino log"
      },
      // JSON.stringify with user input in logs
      {
        pattern: /(logger\.|console\.)(log|info|warn|error|debug)\s*\(.*?JSON\.stringify\s*\(\s*(req\.|request\.|session)/g,
        message: "Log injection vulnerability: JSON.stringify with user input in log statement"
      },
      // User input sources in log calls
      {
        pattern: /(logger\.|console\.|winston\.|bunyan\.|pino\.)(log|info|warn|error|debug).*?(req\.body|req\.query|req\.params|req\.headers|req\.cookies|req\.session)/g,
        message: "Log injection vulnerability: User input source used in log statement without sanitization"
      },
      // CRLF injection patterns
      {
        pattern: /(logger\.|console\.)(log|info|warn|error|debug).*?(\\r|\\n|%0a|%0d)/g,
        message: "Log injection vulnerability: CRLF characters detected in log statement"
      }
    ];

    // Patterns that indicate secure usage (to reduce false positives)
    this.securePatterns = [
      /sanitize\s*\(/g,
      /escape\s*\(/g, 
      /clean\s*\(/g,
      /filter\s*\(/g,
      /validate\s*\(/g,
      /replace\s*\(/g,
      /strip\s*\(/g
    ];
  }

  async analyze(filePath) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`üîç [${this.ruleId}] Regex: Starting analysis for ${filePath}`);
    }

    try {
      const fileContent = fs.readFileSync(filePath, "utf8");
      const violations = [];
      const lines = fileContent.split('\n');

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const lineNumber = i + 1;

        // Skip if line contains secure patterns
        if (this.hasSecurePattern(line)) {
          continue;
        }

        // Check each vulnerability pattern
        for (const { pattern, message } of this.patterns) {
          const matches = [...line.matchAll(pattern)];
          
          for (const match of matches) {
            const column = match.index + 1;
            
            violations.push({
              ruleId: this.ruleId,
              message: message,
              line: lineNumber,
              column: column,
              severity: "error",
              category: this.category,
              code: line.trim()
            });
          }
        }
      }

      if (process.env.SUNLINT_DEBUG) {
        console.log(
          `üîç [${this.ruleId}] Regex: Analysis completed, ${violations.length} violations found`
        );
      }

      return violations;
    } catch (error) {
      console.warn(`‚ö† [${this.ruleId}] Regex analysis failed:`, error.message);
      return [];
    }
  }

  hasSecurePattern(line) {
    return this.securePatterns.some(pattern => pattern.test(line));
  }

  cleanup() {
    // Cleanup resources if needed
  }
}

module.exports = S056RegexBasedAnalyzer;