/**
 * S045 Main Analyzer - Brute-force Protection
 * Primary: Symbol-based analysis (when available)
 * Fallback: Regex-based for all other cases
 * Command: node cli.js --rule=S045 --input=examples/rule-test-fixtures/rules/S045_brute_force_protection --engine=heuristic
 */

const S045SymbolBasedAnalyzer = require("./symbol-based-analyzer.js");

class S045Analyzer {
  constructor(options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`ğŸ”§ [S045] Constructor called with options:`, !!options);
      console.log(
        `ğŸ”§ [S045] Options type:`,
        typeof options,
        Object.keys(options || {})
      );
    }

    this.ruleId = "S045";
    this.ruleName = "Brute-force Protection";
    this.description =
      "Implement protection against brute-force attacks on authentication endpoints. This rule detects missing rate limiting, account lockout mechanisms, and other brute-force protection measures in authentication flows.";
    this.semanticEngine = options.semanticEngine || null;
    this.verbose = options.verbose || false;

    // Configuration
    this.config = {
      useSymbolBased: true, // Primary approach
      fallbackToRegex: true, // Secondary approach
      regexBasedOnly: false, // Can be set to true for pure mode
    };

    // Initialize analyzers
    try {
      this.symbolAnalyzer = new S045SymbolBasedAnalyzer(this.semanticEngine);
      if (process.env.SUNLINT_DEBUG) {
        console.log(`ğŸ”§ [S045] Symbol analyzer created successfully`);
      }
    } catch (error) {
      console.error(`ğŸ”§ [S045] Error creating symbol analyzer:`, error);
    }
  }

  /**
   * Initialize analyzer with semantic engine
   */
  async initialize(semanticEngine) {
    this.semanticEngine = semanticEngine;

    if (process.env.SUNLINT_DEBUG) {
      console.log(`ğŸ”§ [S045] Main analyzer initializing...`);
    }

    // Initialize symbol analyzer
    if (this.symbolAnalyzer) {
      await this.symbolAnalyzer.initialize?.(semanticEngine);
    }

    if (process.env.SUNLINT_DEBUG) {
      console.log(`ğŸ”§ [S045] Main analyzer initialized successfully`);
    }
  }

  /**
   * Single file analysis method for testing
   */
  analyzeSingle(filePath, options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`ğŸ“Š [S045] analyzeSingle() called for: ${filePath}`);
    }

    // Return result using same format as analyze method
    return this.analyze([filePath], "typescript", options);
  }

  async analyze(files, language, options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(
        `ğŸ”§ [S045] analyze() method called with ${files.length} files, language: ${language}`
      );
    }

    const violations = [];

    for (const filePath of files) {
      try {
        if (process.env.SUNLINT_DEBUG) {
          console.log(`ğŸ”§ [S045] Processing file: ${filePath}`);
        }

        const fileViolations = await this.analyzeFile(filePath, options);
        violations.push(...fileViolations);

        if (process.env.SUNLINT_DEBUG) {
          console.log(
            `ğŸ”§ [S045] File ${filePath}: Found ${fileViolations.length} violations`
          );
        }
      } catch (error) {
        console.warn(
          `âš  [S045] Analysis failed for ${filePath}:`,
          error.message
        );
      }
    }

    if (process.env.SUNLINT_DEBUG) {
      console.log(`ğŸ”§ [S045] Total violations found: ${violations.length}`);
    }

    return violations;
  }

  async analyzeFile(filePath, options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`ğŸ” [S045] analyzeFile() called for: ${filePath}`);
    }

    // Create a Map to track unique violations and prevent duplicates
    const violationMap = new Map();

    // 1. Try Symbol-based analysis first (primary)
    if (
      this.config.useSymbolBased &&
      this.semanticEngine?.project &&
      this.semanticEngine?.initialized
    ) {
      try {
        if (process.env.SUNLINT_DEBUG) {
          console.log(`ğŸ”§ [S045] Trying symbol-based analysis...`);
        }
        const sourceFile = this.semanticEngine.project.getSourceFile(filePath);
        if (sourceFile) {
          if (process.env.SUNLINT_DEBUG) {
            console.log(`ğŸ”§ [S045] Source file found, analyzing...`);
          }
          const symbolViolations = await this.symbolAnalyzer.analyze(
            sourceFile,
            filePath
          );

          // Add to violation map with deduplication
          symbolViolations.forEach((violation) => {
            const key = `${violation.line}:${violation.column}:${violation.message}`;
            if (!violationMap.has(key)) {
              violationMap.set(key, violation);
            }
          });

          if (process.env.SUNLINT_DEBUG) {
            console.log(
              `ğŸ”§ [S045] Symbol analysis completed: ${symbolViolations.length} violations`
            );
          }
        } else {
          if (process.env.SUNLINT_DEBUG) {
            console.log(`ğŸ”§ [S045] Source file not found, falling back...`);
          }
        }
      } catch (error) {
        console.warn(`âš  [S045] Symbol analysis failed:`, error.message);
      }
    }

    // 2. Fallback to regex-based analysis if needed
    if (this.config.fallbackToRegex || this.config.regexBasedOnly) {
      try {
        if (process.env.SUNLINT_DEBUG) {
          console.log(`ğŸ”§ [S045] Trying regex-based analysis...`);
        }
        const regexViolations = await this.analyzeWithRegex(filePath);

        // Add to violation map with deduplication
        regexViolations.forEach((violation) => {
          const key = `${violation.line}:${violation.column}:${violation.message}`;
          if (!violationMap.has(key)) {
            violationMap.set(key, violation);
          }
        });

        if (process.env.SUNLINT_DEBUG) {
          console.log(
            `ğŸ”§ [S045] Regex analysis completed: ${regexViolations.length} violations`
          );
        }
      } catch (error) {
        console.warn(`âš  [S045] Regex analysis failed:`, error.message);
      }
    }

    // Convert Map values to array and add filePath to each violation
    const finalViolations = Array.from(violationMap.values()).map(
      (violation) => ({
        ...violation,
        filePath: filePath,
        file: filePath, // Also add 'file' for compatibility
      })
    );

    if (process.env.SUNLINT_DEBUG) {
      console.log(
        `ğŸ”§ [S045] File analysis completed: ${finalViolations.length} unique violations`
      );
    }

    return finalViolations;
  }

  async analyzeWithRegex(filePath) {
    const fs = require('fs');
    const violations = [];

    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const lines = content.split('\n');

      // Authentication endpoint patterns - simplified and more specific
      const authEndpointPatterns = [
        { pattern: /@Post\(['"`](.*login.*)['"`]\)/gi, type: 'nestjs' },
        { pattern: /@Post\(['"`](.*signin.*)['"`]\)/gi, type: 'nestjs' },
        { pattern: /@Post\(['"`](.*auth.*)['"`]\)/gi, type: 'nestjs' },
        { pattern: /@Post\(['"`](.*password.*)['"`]\)/gi, type: 'nestjs' },
        { pattern: /@Post\(['"`](.*reset.*)['"`]\)/gi, type: 'nestjs' },
        { pattern: /@Post\(['"`](.*signup.*)['"`]\)/gi, type: 'nestjs' },
        { pattern: /app\.post\(['"`](.*login.*)['"`]/gi, type: 'express' },
        { pattern: /app\.post\(['"`](.*signin.*)['"`]/gi, type: 'express' },
        { pattern: /app\.post\(['"`](.*auth.*)['"`]/gi, type: 'express' },
        { pattern: /app\.post\(['"`](.*password.*)['"`]/gi, type: 'express' },
        { pattern: /app\.post\(['"`](.*reset.*)['"`]/gi, type: 'express' },
        { pattern: /app\.post\(['"`](.*signup.*)['"`]/gi, type: 'express' },
        { pattern: /router\.post\(['"`](.*login.*)['"`]/gi, type: 'express' },
        { pattern: /router\.post\(['"`](.*signin.*)['"`]/gi, type: 'express' },
        { pattern: /router\.post\(['"`](.*auth.*)['"`]/gi, type: 'express' },
        { pattern: /router\.post\(['"`](.*password.*)['"`]/gi, type: 'express' },
        { pattern: /router\.post\(['"`](.*reset.*)['"`]/gi, type: 'express' },
        { pattern: /router\.post\(['"`](.*signup.*)['"`]/gi, type: 'express' }
      ];

      // Protection patterns - more comprehensive
      const protectionPatterns = [
        /@Throttle/gi,
        /@RateLimit/gi,
        /@UseGuards.*ThrottlerGuard/gi,
        /rateLimit/gi,
        /throttle/gi,
        /express-rate-limit/gi,
        /@nestjs\/throttler/gi,
        /lockout/gi,
        /maxAttempts/gi,
        /cooldown/gi,
        /brute.*force.*protection/gi,
        /windowMs/gi,
        /max.*requests/gi,
        /express-slow-down/gi,
        /rate-limiter-flexible/gi,
        /Limiter/gi,
        /limiter/gi,
        /RateLimit/gi,
        /Throttle/gi
      ];

      // Check if file has any protection mechanisms at all
      const hasGlobalProtection = protectionPatterns.some(pattern => {
        pattern.lastIndex = 0;
        return pattern.test(content);
      });
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const lineNumber = i + 1;

        // Check for authentication endpoints
        for (const { pattern, type } of authEndpointPatterns) {
          // Reset regex lastIndex to avoid issues with global flag
          pattern.lastIndex = 0;
          const match = pattern.exec(line);
          if (match) {
            // Check if this specific endpoint has protection
            const hasProtection = this.checkProtectionInContext(lines, i, protectionPatterns);
            
            // Always flag violations if no protection is found
            if (!hasProtection) {
              violations.push({
                rule: this.ruleId,
                source: filePath,
                category: "security",
                line: lineNumber,
                column: 1,
                message: `Authentication endpoint '${match[1]}' lacks brute-force protection (rate limiting, account lockout, or CAPTCHA)`,
                severity: "error",
              });
            }
          }
        }
      }

      return violations;
    } catch (error) {
      if (this.verbose) {
        console.log(`ğŸ” [${this.ruleId}] Regex analysis error:`, error.message);
      }
      return [];
    }
  }

  checkProtectionInContext(lines, currentLineIndex, protectionPatterns) {
    // Check current line and surrounding context (10 lines before and after)
    const start = Math.max(0, currentLineIndex - 10);
    const end = Math.min(lines.length, currentLineIndex + 11);
    
    for (let i = start; i < end; i++) {
      const line = lines[i];
      for (const pattern of protectionPatterns) {
        pattern.lastIndex = 0;
        if (pattern.test(line)) {
          return true;
        }
      }
    }
    
    return false;
  }

  /**
   * Clean up resources
   */
  cleanup() {
    if (this.symbolAnalyzer?.cleanup) {
      this.symbolAnalyzer.cleanup();
    }
  }
}

module.exports = S045Analyzer;
