/**
 * Rule S012: Hardcoded Secrets Detection - Analyzer Wrapper
 *
 * This analyzer wraps the symbol-based analyzer to provide a consistent
 * interface for the SunLint engine.
 */
// Command: node cli.js --rule=S012 --input=examples/rule-test-fixtures/rules/S012_hardcoded_secrets --engine=heuristic

const fs = require("fs");
const path = require("path");
const { Project } = require("ts-morph");
const S012SymbolBasedAnalyzer = require("./symbol-based-analyzer");

class S012Analyzer {
  constructor(options = {}) {
    this.ruleId = "S012";
    this.semanticEngine = options.semanticEngine || null;
    this.symbolAnalyzer = new S012SymbolBasedAnalyzer(this.semanticEngine);
  }

  /**
   * Analyze multiple files
   */
  async analyze(files, language, options = {}) {
    const violations = [];

    for (const filePath of files) {
      try {
        const fileViolations = await this.analyzeFile(filePath, options);
        violations.push(...fileViolations);
      } catch (error) {
        console.error(
          `[S012] Error analyzing file ${filePath}:`,
          error.message
        );
      }
    }

    return violations;
  }

  /**
   * Analyze a single file
   */
  async analyzeFile(filePath, options = {}) {
    // Skip files that shouldn't be analyzed
    if (this.shouldSkipFile(filePath)) {
      return [];
    }

    try {
      // Check if file exists
      if (!fs.existsSync(filePath)) {
        return [];
      }

      const content = fs.readFileSync(filePath, "utf-8");

      // Try to get source file from semantic engine
      let sourceFile = this.semanticEngine?.project?.getSourceFile(filePath);

      // If not available, create a temporary ts-morph source file
      if (!sourceFile) {
        const tempProject = new Project({
          useInMemoryFileSystem: true,
          compilerOptions: {
            allowJs: true,
            noLib: true,
            target: 99, // ESNext
          },
        });

        sourceFile = tempProject.createSourceFile(
          path.basename(filePath),
          content
        );
      }

      // Run the symbol-based analyzer
      const symbolViolations = await this.symbolAnalyzer.analyze(
        sourceFile,
        filePath
      );

      // Add file path to each violation
      return symbolViolations.map((violation) => ({
        ...violation,
        filePath,
        file: filePath,
      }));
    } catch (error) {
      console.error(
        `[S012] Error in analyzeFile for ${filePath}:`,
        error.message
      );
      return [];
    }
  }

  /**
   * Check if file should be skipped
   */
  shouldSkipFile(filePath) {
    const skipPatterns = [
      /test\//i,
      /tests\//i,
      /__tests__\//i,
      /\.test\./i,
      /\.spec\./i,
      /node_modules\//i,
      /dist\//i,
      /build\//i,
      /\.next\//i,
      /\.nuxt\//i,
      /coverage\//i,
      /\.d\.ts$/i,
      /\.min\.js$/i,
      /\.bundle\.js$/i,
      /\.example\./i,
      /\.sample\./i,
      /\.template\./i,
      /vendor\//i,
      /third[_-]party\//i,
      /\.git\//i,
    ];

    return skipPatterns.some((pattern) => pattern.test(filePath));
  }

  /**
   * Get rule metadata
   */
  getRuleMetadata() {
    const configPath = path.join(__dirname, "config.json");
    if (fs.existsSync(configPath)) {
      const config = JSON.parse(fs.readFileSync(configPath, "utf-8"));
      return config;
    }
    return {
      ruleId: this.ruleId,
      name: "Hardcoded Secrets Protection",
      description: "Detects hardcoded secrets in source code",
      category: "security",
      severity: "error",
    };
  }
}

module.exports = S012Analyzer;
