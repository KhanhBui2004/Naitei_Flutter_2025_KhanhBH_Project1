/**
 * S014 Symbol-Based Analyzer - Enforce TLS 1.2 or 1.3 only
 *
 * Uses AST analysis via ts-morph to detect insecure TLS/SSL versions
 * in server configurations, client agents, and framework settings.
 */

class S014SymbolBasedAnalyzer {
  constructor(semanticEngine) {
    this.ruleId = "S014";
    this.semanticEngine = semanticEngine;

    // Insecure TLS/SSL versions to detect
    this.insecureVersions = [
      /SSLv2/i,
      /SSLv3/i,
      /TLSv1(?!\.2|\.3|_2|_3)/i, // TLS 1.0 (but not 1.2 or 1.3)
      /TLSv1\.0/i,
      /TLSv1_method/i,
      /TLSv1\.1/i,
      /TLSv1_1_method/i,
    ];

    // Configuration keys that specify TLS version
    this.versionKeys = [
      "minVersion",
      "maxVersion",
      "secureProtocol",
      "protocol",
      "tlsVersion",
      "sslVersion",
    ];
  }

  async initialize() {}

  analyze(sourceFile, filePath) {
    const violations = [];

    try {
      const { SyntaxKind } = require("ts-morph");

      // Check all object literal expressions for TLS version configs
      const objLits = sourceFile.getDescendantsOfKind(
        SyntaxKind.ObjectLiteralExpression
      );

      for (const obj of objLits) {
        try {
          const properties = obj.getProperties();

          for (const prop of properties) {
            if (prop.getKind() !== SyntaxKind.PropertyAssignment) continue;

            const propAssignment = prop;
            const propName = propAssignment.getName();

            // Check if this is a TLS version configuration key
            if (this.versionKeys.includes(propName)) {
              const initializer = propAssignment.getInitializer();
              if (!initializer) continue;

              let value = "";
              const kind = initializer.getKind();

              if (kind === SyntaxKind.StringLiteral) {
                value = initializer.getLiteralValue();
              } else if (kind === SyntaxKind.NoSubstitutionTemplateLiteral) {
                value = initializer.getLiteralText().slice(1, -1); // Remove backticks
              } else if (kind === SyntaxKind.TemplateExpression) {
                // Template literal with expressions: `TLSv${version}`
                // We can't know the runtime value, but we can detect potential issues
                const templateText = initializer.getText();
                // Check if template contains TLS/SSL patterns that might result in insecure versions
                if (/TLSv|SSLv/i.test(templateText)) {
                  // This is potentially insecure - warn about dynamic TLS version
                  violations.push({
                    ruleId: this.ruleId,
                    message: `Dynamic TLS/SSL version detected in '${propName}' - ensure it uses TLS 1.2 or 1.3 only`,
                    severity: "error",
                    line: propAssignment.getStartLineNumber(),
                    column:
                      propAssignment.getStartLinePos() -
                      propAssignment.getStartLinePos(true) +
                      1,
                    filePath: filePath,
                  });
                  continue; // Skip further checking for this property
                }
                value = templateText;
              } else if (kind === SyntaxKind.Identifier) {
                // Handle variable reference
                value = initializer.getText();
              } else {
                value = initializer.getText().replace(/['"]/g, "");
              }

              // Check if value contains insecure version
              for (const insecurePattern of this.insecureVersions) {
                if (insecurePattern.test(value)) {
                  violations.push({
                    ruleId: this.ruleId,
                    message: `Insecure TLS/SSL version '${value}' detected in '${propName}' - use TLS 1.2 or 1.3 only`,
                    severity: "error",
                    line: propAssignment.getStartLineNumber(),
                    column:
                      propAssignment.getStartLinePos() -
                      propAssignment.getStartLinePos(true) +
                      1,
                    filePath: filePath,
                  });
                  break;
                }
              }
            }
          }
        } catch (e) {
          // Skip problematic objects
        }
      }

      // Check standalone variable declarations (only for simple string assignments)
      // This catches cases like: const tlsVersion = "TLSv1"
      const varDecls = sourceFile.getDescendantsOfKind(
        SyntaxKind.VariableDeclaration
      );

      for (const varDecl of varDecls) {
        try {
          const init = varDecl.getInitializer();
          if (!init) continue;

          const kind = init.getKind();

          // Only check simple string literals or template literals (not objects/calls)
          // This prevents duplicate detection with ObjectLiteral properties
          if (
            kind !== SyntaxKind.StringLiteral &&
            kind !== SyntaxKind.NoSubstitutionTemplateLiteral &&
            kind !== SyntaxKind.TemplateExpression
          ) {
            continue; // Skip complex expressions
          }

          let value = "";
          if (kind === SyntaxKind.StringLiteral) {
            value = init.getLiteralValue();
          } else if (kind === SyntaxKind.NoSubstitutionTemplateLiteral) {
            value = init.getLiteralText().slice(1, -1);
          } else if (kind === SyntaxKind.TemplateExpression) {
            // For template expressions, get the static parts
            value = init.getText();
          } else {
            value = init.getText().replace(/['"]/g, "");
          }

          // Check for insecure versions in variable values
          for (const insecurePattern of this.insecureVersions) {
            if (insecurePattern.test(value)) {
              violations.push({
                ruleId: this.ruleId,
                message: `Insecure TLS/SSL version '${value}' assigned to variable - use TLS 1.2 or 1.3 only`,
                severity: "error",
                line: varDecl.getStartLineNumber(),
                column:
                  varDecl.getStartLinePos() - varDecl.getStartLinePos(true) + 1,
                filePath: filePath,
              });
              break;
            }
          }
        } catch (e) {
          // Skip problematic variables
        }
      }

      // Note: CallExpression checking is not needed because getDescendantsOfKind
      // for ObjectLiteralExpression already captures all objects including those
      // passed as arguments to function calls (e.g., https.createServer({...}))
      // This prevents duplicate violations.
    } catch (err) {
      console.warn(
        `âš  [S014] Symbol analysis failed for ${filePath}:`,
        err.message
      );
    }

    return violations;
  }

  cleanup() {}
}

module.exports = S014SymbolBasedAnalyzer;
