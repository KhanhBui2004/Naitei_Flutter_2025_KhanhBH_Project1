# S045 - Brute-force Protection

## Overview

This rule enforces protection against brute-force attacks on authentication endpoints. It detects missing rate limiting, account lockout mechanisms, and other brute-force protection measures in authentication flows to prevent unauthorized access attempts.

## Description

Brute-force protection is a critical security measure that helps prevent:

- **Brute-force attacks** on login and authentication endpoints
- **Credential stuffing** attacks using stolen credentials
- **Automated attacks** that attempt to guess passwords
- **Account takeover** through systematic password attempts
- **System overload** from excessive authentication requests

## Rule Details

**Rule ID**: S045  
**Category**: Security  
**Severity**: Error  
**Type**: Hybrid Analysis (Symbol-based + Regex-based)

## Examples

### ❌ Violations

```typescript
// NestJS - Login endpoint without rate limiting
@Post('login')
async login(@Body() loginDto: LoginDto) {
  return this.authService.validateUser(loginDto);
}

// Express.js - Authentication without rate limiting
app.post('/auth/login', (req, res) => {
  const { username, password } = req.body;
  // No rate limiting or lockout mechanism
  authenticateUser(username, password);
});

// Password reset without protection
@Post('reset-password')
async resetPassword(@Body() resetDto: ResetPasswordDto) {
  // No rate limiting or captcha
  return this.authService.resetPassword(resetDto);
}

// Sign-in endpoint without throttling
app.post('/signin', async (req, res) => {
  const { email, password } = req.body;
  // Missing brute-force protection
  const user = await User.findOne({ email });
  if (user && await bcrypt.compare(password, user.password)) {
    res.json({ token: generateToken(user) });
  }
});

// Authentication handler without lockout
function authenticateUser(username, password) {
  // No attempt counting or lockout mechanism
  return validateCredentials(username, password);
}

// Forgot password without protection
@Post('forgot-password')
async forgotPassword(@Body() body: { email: string }) {
  // No rate limiting for password reset requests
  return this.authService.sendResetEmail(body.email);
}
```

### ✅ Correct Usage

```typescript
// NestJS - Login with rate limiting
@Post('login')
@Throttle(5, 60) // 5 attempts per minute
async login(@Body() loginDto: LoginDto) {
  return this.authService.validateUser(loginDto);
}

// Express.js - Authentication with rate limiting middleware
const rateLimit = require('express-rate-limit');

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // limit each IP to 5 requests per windowMs
  message: 'Too many login attempts, please try again later'
});

app.post('/auth/login', loginLimiter, (req, res) => {
  const { username, password } = req.body;
  authenticateUser(username, password);
});

// NestJS with ThrottlerModule configuration
@Module({
  imports: [
    ThrottlerModule.forRoot([{
      ttl: 60000, // 1 minute
      limit: 5,   // 5 requests per minute
    }]),
  ],
})
export class AuthModule {}

// Express with rate-limiter-flexible
const { RateLimiterMemory } = require('rate-limiter-flexible');

const rateLimiter = new RateLimiterMemory({
  points: 5, // Number of attempts
  duration: 900, // Per 15 minutes
});

app.post('/login', async (req, res) => {
  try {
    await rateLimiter.consume(req.ip);
    // Process login
  } catch (rejRes) {
    res.status(429).send('Too Many Requests');
  }
});

// Password reset with rate limiting and captcha
@Post('reset-password')
@Throttle(3, 3600) // 3 attempts per hour
async resetPassword(
  @Body() resetDto: ResetPasswordDto,
  @Body('captcha') captcha: string
) {
  // Verify captcha first
  await this.captchaService.verify(captcha);
  return this.authService.resetPassword(resetDto);
}

// Account lockout implementation
const accountLockout = new Map();

app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  const attempts = accountLockout.get(username) || 0;
  
  if (attempts >= 5) {
    return res.status(423).json({ 
      error: 'Account locked due to too many failed attempts' 
    });
  }
  
  const isValid = await validateCredentials(username, password);
  if (!isValid) {
    accountLockout.set(username, attempts + 1);
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Reset attempts on successful login
  accountLockout.delete(username);
  res.json({ token: generateToken(username) });
});

// Express Brute for progressive delays
const ExpressBrute = require('express-brute');
const store = new ExpressBrute.MemoryStore();

const bruteforce = new ExpressBrute(store, {
  freeRetries: 3,
  minWait: 5 * 60 * 1000, // 5 minutes
  maxWait: 60 * 60 * 1000, // 1 hour
});

app.post('/auth/login', bruteforce.prevent, (req, res) => {
  // Login logic with brute-force protection
});
```

## Configuration

### Detected Patterns

This rule detects brute-force protection issues in multiple scenarios:

### Authentication Endpoints

- `login`, `signin`, `authenticate`, `auth` endpoints without protection
- `password`, `reset`, `forgot` endpoints without rate limiting
- Authentication handlers without throttling mechanisms

### Rate Limiting Libraries

**Supported Libraries:**
- `express-rate-limit`
- `express-slow-down`
- `@nestjs/throttler`
- `rate-limiter-flexible`
- `bottleneck`
- `limiter`

### Account Lockout Libraries

**Supported Libraries:**
- `express-slow-down`
- `rate-limiter-flexible`
- `express-brute`
- `express-brute-mongo`

### CAPTCHA Libraries

**Supported Libraries:**
- `recaptcha`
- `hcaptcha`
- `turnstile`
- `captcha`

### Protection Patterns

**Required Protection Indicators:**
- Rate limiting: `rate.*limit`, `throttle`, `@Throttle()`
- Account lockout: `lockout`, `max.*attempts`, `brute.*force.*protection`
- Progressive delays: `cooldown`, `progressive.*delay`
- CAPTCHA verification: `captcha`, `recaptcha`, `hcaptcha`

### Vulnerable Patterns

**Detected Anti-patterns:**
- Authentication endpoints without rate limiting
- Login handlers without throttling
- Password reset without protection
- Sign-in without attempt limits

## Security Benefits

1. **Attack Prevention**: Blocks automated brute-force attacks
2. **Resource Protection**: Prevents system overload from excessive requests
3. **Account Security**: Protects user accounts from unauthorized access
4. **Service Availability**: Maintains service availability under attack
5. **Compliance**: Meets security standards and regulations

## Analysis Approach

### Symbol-based Analysis (Primary)

- Uses TypeScript AST for semantic analysis
- Detects authentication endpoints and decorators
- Analyzes middleware usage and rate limiting
- Provides precise line/column positions

### Regex-based Analysis (Fallback)

- Pattern-based detection for complex cases
- Handles string-based endpoint definitions
- Covers edge cases missed by AST analysis
- Maintains line number accuracy

## Best Practices

1. **Implement rate limiting** on all authentication endpoints
2. **Use progressive delays** for repeated failed attempts
3. **Enable account lockout** after multiple failed attempts
4. **Add CAPTCHA verification** for sensitive operations
5. **Monitor and log** authentication attempts
6. **Use IP-based rate limiting** to prevent distributed attacks
7. **Implement proper error messages** that don't reveal user existence
8. **Set appropriate time windows** for rate limiting (15-60 minutes)
9. **Configure reasonable attempt limits** (3-5 attempts before lockout)
10. **Use established libraries** rather than custom implementations

## Configuration Options

### Default Settings

- **Max Attempts Threshold**: 5 attempts
- **Time Window**: 15 minutes
- **Enable Rate Limit Detection**: true
- **Enable Account Lockout Detection**: true
- **Enable CAPTCHA Detection**: true

### Customizable Parameters

```json
{
  "maxAttemptsThreshold": 5,
  "timeWindowMinutes": 15,
  "checkAuthenticationEndpoints": [
    "login", "signin", "authenticate", "auth",
    "password", "reset", "forgot"
  ]
}
```

## Testing

Run the rule on test fixtures:

```bash
# Test violations
node cli.js --rule=S045 --input=examples/rule-test-fixtures/rules/S045_brute_force_protection/violations --engine=heuristic

# Test clean examples
node cli.js --rule=S045 --input=examples/rule-test-fixtures/rules/S045_brute_force_protection/clean --engine=heuristic

# Test all examples
node cli.js --rule=S045 --input=examples/rule-test-fixtures/rules/S045_brute_force_protection --engine=heuristic

# Framework-specific testing
# Test with ESLint engine (fast)
node cli.js --rule=S045 --input=path/to/your/files

# Test with heuristic engine (comprehensive)
node cli.js --rule=S045 --input=path/to/your/files --engine=heuristic
```

## Framework Compatibility

- **Node.js**: All versions
- **Frameworks**: Express.js, NestJS, Fastify, Koa
- **Languages**: JavaScript, TypeScript
- **Analysis Engines**: ESLint (fast), Heuristic (comprehensive)

## Related Rules

- **S031**: Set Secure flag for Session Cookies
- **S032**: Set HttpOnly attribute for Session Cookies
- **S041**: Session Tokens must be invalidated after logout or expiration
- **S044**: Re-authentication Required for Sensitive Operations
- **S048**: No Current Password in Password Reset

Together, these rules provide comprehensive authentication security.

## OWASP References

- [OWASP Brute Force Attack](https://owasp.org/www-community/attacks/Brute_force_attack)
- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
- [OWASP Blocking Brute Force Attacks](https://owasp.org/www-community/controls/Blocking_Brute_Force_Attacks)
- [PortSwigger Web Security - Brute Force](https://portswigger.net/web-security/authentication/password-based/brute-force)

## Implementation Notes

This rule uses a hybrid analysis approach:

1. **Symbol-based analysis** detects decorator usage (`@Throttle()`) and middleware patterns
2. **Regex-based analysis** catches string-based configurations and complex patterns
3. **Library detection** identifies known rate limiting and protection libraries
4. **Context awareness** distinguishes between authentication and other endpoints

The rule maintains high accuracy while minimizing false positives through careful pattern matching and context analysis.