# S011 - Secure GUID Generation

## Overview

Quy tắc này phát hiện việc sử dụng các phương pháp yếu hoặc có thể dự đoán được để tạo GUIDs/UUIDs cho mục đích bảo mật. GUIDs dùng cho session tokens, API keys, reset tokens, hoặc các mục đích bảo mật khác phải được tạo theo chuẩn UUID v4 với CSPRNG (Cryptographically Secure Pseudo-Random Number Generator).

## OWASP Classification

- **Category**: A02:2021 - Cryptographic Failures
- **CWE**: CWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)
- **Severity**: Error
- **Impact**: High (Session hijacking, token prediction, unauthorized access)

## Vấn đề

Khi sử dụng các phương pháp yếu để tạo GUIDs cho mục đích bảo mật:

1. **Dễ dự đoán**: Kẻ tấn công có thể dự đoán GUIDs tiếp theo
2. **Session hijacking**: Session tokens yếu có thể bị đoán và chiếm quyền
3. **Token collision**: Xác suất trùng lặp cao hơn với PRNG yếu
4. **Brute force attacks**: Tokens dễ bị tấn công brute force

## Các trường hợp vi phạm

### 1. Sử dụng Math.random()

```javascript
// ❌ Vi phạm - Math.random() không an toàn cho mục đích bảo mật
const sessionId = Math.random().toString(36).substring(2, 15);
const apiKey = Math.random().toString(36) + Math.random().toString(36);
const resetToken = `${Date.now()}-${Math.random()}`;

// ❌ Vi phạm - Timestamp-based không đủ random
const token = Date.now().toString(36);
const userId = new Date().getTime();
```

### 2. Sử dụng UUID v1 (time-based)

```javascript
// ❌ Vi phạm - UUID v1 sử dụng timestamp và MAC address
import { v1 as uuidv1 } from "uuid";

const sessionToken = uuidv1(); // Time-based, có thể dự đoán
const apiKey = uuidv1(); // Không an toàn cho security purposes
```

### 3. Custom GUID generation yếu

```javascript
// ❌ Vi phạm - Custom implementation không sử dụng CSPRNG
function generateGuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0; // Math.random() không an toàn
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

const resetToken = generateGuid();
const sessionId = generateGuid();
```

### 4. Sử dụng cho security-critical purposes

```javascript
// ❌ Vi phạm - Weak GUID cho authentication
app.post("/login", (req, res) => {
  const sessionToken = Math.random().toString(36);
  req.session.token = sessionToken;
});

// ❌ Vi phạm - Weak GUID cho password reset
const resetToken = Date.now() + "-" + Math.random();
await sendPasswordResetEmail(user.email, resetToken);

// ❌ Vi phạm - Weak GUID cho API key
const apiKey = uuidv1(); // Time-based UUID
await saveApiKey(userId, apiKey);
```

## Giải pháp an toàn

### 1. Sử dụng crypto.randomUUID() (Node.js 14.17+)

```javascript
// ✅ An toàn - crypto.randomUUID() sử dụng CSPRNG
import { randomUUID } from "crypto";

const sessionId = randomUUID();
const apiKey = randomUUID();
const resetToken = randomUUID();
```

### 2. Sử dụng uuid v4 library

```javascript
// ✅ An toàn - uuid v4 sử dụng CSPRNG
import { v4 as uuidv4 } from "uuid";

const sessionToken = uuidv4();
const apiKey = uuidv4();
const resetToken = uuidv4();
```

### 3. Sử dụng crypto.randomBytes()

```javascript
// ✅ An toàn - crypto.randomBytes() cho custom implementation
import { randomBytes } from "crypto";

const sessionId = randomBytes(16).toString("hex");
const apiKey = randomBytes(32).toString("base64url");
const resetToken = randomBytes(48).toString("base64url");
```

### 4. Best practices cho security tokens

```javascript
// ✅ An toàn - Session management
import { randomUUID } from "crypto";

app.post("/login", async (req, res) => {
  const sessionToken = randomUUID();
  await redis.set(`session:${sessionToken}`, userId, "EX", 3600);
  res.cookie("sessionId", sessionToken, { httpOnly: true, secure: true });
});

// ✅ An toàn - Password reset token
import { randomBytes } from "crypto";

async function generateResetToken() {
  const token = randomBytes(32).toString("hex");
  const hashedToken = await bcrypt.hash(token, 10);
  await saveToDatabase({ token: hashedToken, expiresAt: Date.now() + 3600000 });
  return token;
}

// ✅ An toàn - API key generation
import { v4 as uuidv4 } from "uuid";

const apiKey = `sk_${uuidv4().replace(/-/g, "")}`;
const hashedKey = await bcrypt.hash(apiKey, 10);
await saveApiKey(userId, hashedKey);
```

## Phương pháp phát hiện

Rule này sử dụng symbol-based analysis để phát hiện:

1. **Math.random() usage**: Detect `Math.random()` trong context tạo tokens/IDs
2. **Timestamp-based IDs**: Detect `Date.now()`, `new Date().getTime()` cho security purposes
3. **UUID v1 usage**: Detect `uuidv1()` hoặc `uuid.v1()` cho authentication/authorization
4. **Weak GUID patterns**: Detect custom implementations không sử dụng CSPRNG
5. **Variable naming context**: Phân tích tên biến như `sessionId`, `token`, `apiKey`, `resetToken`

### Detection patterns:

- Variable names: `session`, `token`, `api`, `key`, `reset`, `auth`, `secret`
- Unsafe methods: `Math.random()`, `Date.now()`, `getTime()`, `uuidv1()`
- Secure methods: `crypto.randomUUID()`, `crypto.randomBytes()`, `uuidv4()`

## Safe contexts (không báo lỗi)

```javascript
// ✅ OK - Sử dụng Math.random() cho non-security purposes
const displayId = Math.random().toString(36); // UI display ID
const tempId = Date.now(); // Temporary client-side ID
const orderId = `ORD-${Date.now()}`; // Business identifier, not security token

// ✅ OK - UUID v1 cho non-security purposes
const recordId = uuidv1(); // Database record ID (không dùng cho authentication)
const traceId = uuidv1(); // Distributed tracing ID
```

## Cấu hình

```json
{
  "S011": {
    "enabled": true,
    "severity": "error",
    "excludePatterns": ["test/**", "**/*.test.js", "**/*.spec.js"],
    "securityKeywords": [
      "session",
      "token",
      "api",
      "key",
      "reset",
      "auth",
      "secret",
      "credential"
    ]
  }
}
```

## Best Practices

1. **Luôn dùng CSPRNG**: Sử dụng `crypto.randomUUID()` hoặc `crypto.randomBytes()` cho security tokens
2. **UUID v4 only**: Chỉ sử dụng UUID v4 cho security purposes, tránh UUID v1
3. **Sufficient entropy**: Đảm bảo đủ entropy (ít nhất 128 bits cho tokens)
4. **No predictable patterns**: Tránh patterns có thể dự đoán (timestamp, sequential IDs)
5. **Token expiration**: Luôn set thời hạn cho security tokens
6. **Hash before storage**: Hash tokens trước khi lưu vào database

## Platform-specific implementations

### Node.js

```javascript
import { randomUUID, randomBytes } from "crypto";
const token = randomUUID(); // UUID v4 với CSPRNG
const key = randomBytes(32).toString("hex");
```

### Python

```python
import secrets
import uuid

token = str(uuid.uuid4())  # UUID v4 với CSPRNG
key = secrets.token_urlsafe(32)  # Secure random token
```

### Java

```java
import java.security.SecureRandom;
import java.util.UUID;

UUID token = UUID.randomUUID(); // UUID v4 với CSPRNG
SecureRandom random = new SecureRandom();
byte[] bytes = new byte[32];
random.nextBytes(bytes);
```

### .NET/C#

```csharp
using System;
using System.Security.Cryptography;

var token = Guid.NewGuid(); // GUID với CSPRNG
var bytes = RandomNumberGenerator.GetBytes(32); // Secure random
```

## Tài liệu tham khảo

- [OWASP A02:2021 - Cryptographic Failures](https://owasp.org/Top10/A02_2021-Cryptographic_Failures/)
- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)
- [RFC 4122: UUID Standard](https://www.rfc-editor.org/rfc/rfc4122)
- [Node.js Crypto Documentation](https://nodejs.org/api/crypto.html)
- [NIST SP 800-90A: Random Number Generation](https://csrc.nist.gov/publications/detail/sp/800-90a/rev-1/final)
