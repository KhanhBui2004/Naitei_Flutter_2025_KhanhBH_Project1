/**
 * S013 Symbol-Based Analyzer - Enforce TLS for all connections
 */

class S013SymbolBasedAnalyzer {
  constructor(semanticEngine) {
    this.ruleId = "S013";
    this.semanticEngine = semanticEngine;
    this.httpIndicators = [
      /http:\/\//i,
      /ws:\/\//i, // WebSocket insecure protocol
      /http\.createServer/,
      /require\(['\"]http['\"]\)/,
    ];
    this.tlsModules = ["https", "tls"];
    this.clientCallMethods = [
      "fetch",
      "axios",
      "request",
      "http.request",
      "http.get",
    ];
  }

  async initialize() {}

  analyze(sourceFile, filePath) {
    const violations = [];
    try {
      const { SyntaxKind } = require("ts-morph");

      // Skip test files - they use http:// for mocking
      if (
        filePath.includes('.test.') ||
        filePath.includes('.spec.') ||
        filePath.includes('__tests__/') ||
        filePath.includes('__mocks__/')
      ) {
        return violations; // Skip test files
      }

      // Check for imports/requires of 'http' module
      const importDecls = sourceFile.getImportDeclarations();
      for (const imp of importDecls) {
        const moduleName = imp.getModuleSpecifierValue();
        if (moduleName === "http") {
          // Check if it's only used for typing (e.g., http.IncomingMessage)
          const namedImports = imp.getNamedImports();
          const namespaceImport = imp.getNamespaceImport();

          // Skip if it's a namespace import used only for types
          if (namespaceImport) {
            const importName = namespaceImport.getText();
            const sourceText = sourceFile.getFullText();
            // Check if only used for typing (e.g., import * as http for http.IncomingMessage type)
            const usagePattern = new RegExp(`${importName}\\.(?:IncomingMessage|ServerResponse|Server)`, 'g');
            const actualUsagePattern = new RegExp(`${importName}\\.(?:createServer|get|request)\\s*\\(`, 'g');

            if (usagePattern.test(sourceText) && !actualUsagePattern.test(sourceText)) {
              continue; // Only used for typing, not actual HTTP calls
            }
          }

          const startLine = imp.getStartLineNumber();
          violations.push({
            ruleId: this.ruleId,
            message: `Import of insecure 'http' module detected - prefer 'https' or TLS-wrapped server`,
            severity: "error",
            line: startLine,
            column: 1,
          });
        }
      }

      // Check for require('http') style and variable assignments with insecure URLs
      const varDecls = sourceFile.getDescendantsOfKind(
        SyntaxKind.VariableDeclaration
      );
      for (const v of varDecls) {
        const init = v.getInitializer();
        if (init && init.getText) {
          const initText = init.getText();

          // Check for require('http')
          if (/require\(['\"]http['\"]\)/.test(initText)) {
            violations.push({
              ruleId: this.ruleId,
              message: `CommonJS require of insecure 'http' module detected - prefer 'https'`,
              severity: "error",
              line: v.getStartLineNumber(),
              column: 1,
            });
          }

          // Check for template literals with http:// or ws:// in variable assignments
          const kind = init.getKind && init.getKind();
          if (
            kind === SyntaxKind.TemplateExpression ||
            kind === SyntaxKind.NoSubstitutionTemplateLiteral
          ) {
            if (/http:\/\//i.test(initText)) {
              violations.push({
                ruleId: this.ruleId,
                message: `Variable assigned insecure URL in template literal - use 'https://'`,
                severity: "error",
                line: v.getStartLineNumber(),
                column: 1,
              });
            } else if (/ws:\/\//i.test(initText)) {
              violations.push({
                ruleId: this.ruleId,
                message: `Variable assigned insecure WebSocket URL in template literal - use 'wss://'`,
                severity: "error",
                line: v.getStartLineNumber(),
                column: 1,
              });
            }
          }
        }
      }

      // Check for http.createServer or server.listen on port 80
      const calls = sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression);
      for (const call of calls) {
        const expr = call.getExpression();
        const text = expr.getText();

        // Check for 'new' expressions (like new WebSocket('ws://...'))
        const parent = call.getParent();
        const isNewExpression =
          parent &&
          parent.getKind &&
          parent.getKind() === SyntaxKind.NewExpression;

        // http.createServer(...)
        if (/http\.createServer/.test(text)) {
          violations.push({
            ruleId: this.ruleId,
            message: `Insecure server created with http.createServer - use TLS (https.createServer)`,
            severity: "error",
            line: call.getStartLineNumber(),
            column: 1,
          });
        }

        // app.listen(80) or server.listen(80)
        if (/\.listen/.test(text)) {
          const args = call.getArguments();
          if (args.length > 0) {
            const first = args[0];
            try {
              const val = first.getText();
              if (/\b80\b/.test(val) || /['\"]http:\/\//.test(val)) {
                violations.push({
                  ruleId: this.ruleId,
                  message: `Server listening on insecure port or http endpoint (${val}) - configure TLS (443) or use HTTPS`,
                  severity: "error",
                  line: call.getStartLineNumber(),
                  column: 1,
                });
              }
            } catch (e) {
              // ignore
            }
          }
        }

        // client calls with http:// or ws:// in literal args (fetch('http://...'))
        const args = call.getArguments();
        for (const a of args) {
          try {
            const kind = a.getKind && a.getKind();

            // Check StringLiteral
            if (kind === SyntaxKind.StringLiteral) {
              const lit = a.getLiteralValue();
              if (/^http:\/\//i.test(lit)) {
                // Skip if it's a string check in utility functions (e.g., startsWith('http://'))
                if (lit === 'http://' || lit === 'https://') {
                  const callText = call.getParent().getText();
                  // Check if it's used in string manipulation (startsWith, replace, includes, etc.)
                  if (
                    /\.(?:startsWith|replace|includes|indexOf|match|test)\s*\(/.test(callText) ||
                    /case\s+.*startsWith/.test(callText)
                  ) {
                    continue; // Skip utility functions that convert http -> https
                  }
                }

                // Skip localhost URLs used as base URL for parsing (e.g., new URL(path, 'http://localhost'))
                if (lit === 'http://localhost' && args.length >= 2) {
                  // This is likely used as base URL for URL constructor
                  continue;
                }

                // Skip Swagger .addServer() with localhost in development
                const callExprText = expr.getText();
                if (/\.addServer/.test(callExprText) && /localhost/.test(lit)) {
                  continue; // Swagger config for local development
                }

                const msgPrefix = isNewExpression
                  ? "Constructor"
                  : "Insecure client call";
                violations.push({
                  ruleId: this.ruleId,
                  message: `${msgPrefix} to '${lit}' detected - use 'https://'`,
                  severity: "error",
                  line: call.getStartLineNumber(),
                  column: 1,
                });
              } else if (/^ws:\/\//i.test(lit)) {
                violations.push({
                  ruleId: this.ruleId,
                  message: `Insecure WebSocket connection to '${lit}' detected - use 'wss://'`,
                  severity: "error",
                  line: call.getStartLineNumber(),
                  column: 1,
                });
              }
            }

            // Check TemplateExpression and NoSubstitutionTemplateLiteral
            if (
              kind === SyntaxKind.TemplateExpression ||
              kind === SyntaxKind.NoSubstitutionTemplateLiteral
            ) {
              const text = a.getText();
              if (/http:\/\//i.test(text)) {
                // Skip Firebase Emulator configuration (local development only)
                const callExprText = expr.getText();
                if (
                  /connect.*Emulator/i.test(callExprText) ||
                  (text.includes('localhost') || text.includes('EMULATOR_HOST') || text.includes('127.0.0.1'))
                ) {
                  // Firebase/local emulator config - safe for development
                  continue;
                }

                violations.push({
                  ruleId: this.ruleId,
                  message: `Insecure URL in template literal detected - use 'https://'`,
                  severity: "error",
                  line: a.getStartLineNumber(),
                  column: 1,
                });
              } else if (/ws:\/\//i.test(text)) {
                violations.push({
                  ruleId: this.ruleId,
                  message: `Insecure WebSocket in template literal detected - use 'wss://'`,
                  severity: "error",
                  line: a.getStartLineNumber(),
                  column: 1,
                });
              }
            }
          } catch (e) {
            // ignore
          }
        }
      }

      // Check NewExpression separately for WebSocket and similar constructors
      const newExprs = sourceFile.getDescendantsOfKind(
        SyntaxKind.NewExpression
      );
      for (const newExpr of newExprs) {
        try {
          const args = newExpr.getArguments();
          for (const a of args) {
            const kind = a.getKind && a.getKind();

            if (kind === SyntaxKind.StringLiteral) {
              const lit = a.getLiteralValue();
              if (/^ws:\/\//i.test(lit)) {
                violations.push({
                  ruleId: this.ruleId,
                  message: `Insecure WebSocket connection to '${lit}' detected - use 'wss://'`,
                  severity: "error",
                  line: newExpr.getStartLineNumber(),
                  column: 1,
                });
              } else if (/^http:\/\//i.test(lit)) {
                // Skip localhost URLs used as base URL for URL constructor (e.g., new URL(path, 'http://localhost'))
                if (lit === 'http://localhost' && args.length >= 2) {
                  continue; // Used as base URL for parsing
                }

                violations.push({
                  ruleId: this.ruleId,
                  message: `Constructor with insecure URL '${lit}' detected - use 'https://'`,
                  severity: "error",
                  line: newExpr.getStartLineNumber(),
                  column: 1,
                });
              }
            }
          }
        } catch (e) {
          // ignore
        }
      }

      // Check framework config objects for https: false or tls disabled
      const objLits = sourceFile.getDescendantsOfKind(
        SyntaxKind.ObjectLiteralExpression
      );
      for (const obj of objLits) {
        const text = obj.getText();
        if (/https\s*:\s*false/.test(text) || /tls\s*:\s*false/.test(text)) {
          violations.push({
            ruleId: this.ruleId,
            message: `Framework configuration disables TLS (https: false) - enable TLS for production`,
            severity: "error",
            line: obj.getStartLineNumber(),
            column: 1,
          });
        }
      }

      // Check object property assignments for insecure URLs
      const properties = sourceFile.getDescendantsOfKind(
        SyntaxKind.PropertyAssignment
      );
      for (const prop of properties) {
        try {
          const initializer = prop.getInitializer();
          if (initializer) {
            const kind = initializer.getKind && initializer.getKind();

            // Check string literal property values
            if (kind === SyntaxKind.StringLiteral) {
              const value = initializer.getLiteralValue();
              if (/^http:\/\//i.test(value)) {
                // Skip API documentation examples
                if (value === 'http://example.com' || value === 'http://localhost') {
                  // Check if this is inside @ApiProperty decorator
                  const propertyName = prop.getName && prop.getName();
                  const parent = prop.getParent();
                  const grandParent = parent && parent.getParent();

                  // Check for @ApiProperty({ example: 'http://...' })
                  if (grandParent) {
                    const decorators = grandParent.getDecorators && grandParent.getDecorators();
                    if (decorators && decorators.some(d => d.getText().includes('ApiProperty'))) {
                      continue; // Skip API documentation examples
                    }
                  }

                  // Also check if property name is 'example'
                  if (propertyName === 'example') {
                    continue; // Skip example values
                  }
                }

                violations.push({
                  ruleId: this.ruleId,
                  message: `Object property contains insecure URL '${value}' - use 'https://'`,
                  severity: "error",
                  line: prop.getStartLineNumber(),
                  column: 1,
                });
              } else if (/^ws:\/\//i.test(value)) {
                violations.push({
                  ruleId: this.ruleId,
                  message: `Object property contains insecure WebSocket URL '${value}' - use 'wss://'`,
                  severity: "error",
                  line: prop.getStartLineNumber(),
                  column: 1,
                });
              }
            }
          }
        } catch (e) {
          // ignore
        }
      }

      // Check array literals for insecure URLs
      const arrayLits = sourceFile.getDescendantsOfKind(
        SyntaxKind.ArrayLiteralExpression
      );
      for (const arr of arrayLits) {
        const elements = arr.getElements();
        for (const elem of elements) {
          try {
            const kind = elem.getKind && elem.getKind();
            if (kind === SyntaxKind.StringLiteral) {
              const value = elem.getLiteralValue();
              if (/^http:\/\//i.test(value)) {
                violations.push({
                  ruleId: this.ruleId,
                  message: `Array element contains insecure URL '${value}' - use 'https://'`,
                  severity: "error",
                  line: elem.getStartLineNumber(),
                  column: 1,
                });
              } else if (/^ws:\/\//i.test(value)) {
                violations.push({
                  ruleId: this.ruleId,
                  message: `Array element contains insecure WebSocket URL '${value}' - use 'wss://'`,
                  severity: "error",
                  line: elem.getStartLineNumber(),
                  column: 1,
                });
              }
            }
          } catch (e) {
            // ignore
          }
        }
      }
    } catch (err) {
      console.warn(
        `âš  [S013] Symbol analysis failed for ${filePath}:`,
        err.message
      );
    }

    return violations;
  }

  cleanup() {}
}

module.exports = S013SymbolBasedAnalyzer;
