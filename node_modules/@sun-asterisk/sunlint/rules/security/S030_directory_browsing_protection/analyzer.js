/**
 * S030 Main Analyzer - Disable directory browsing and protect sensitive metadata files
 * Primary: Symbol-based analysis (when available)
 * Fallback: Regex-based for all other cases
 * Command: node cli.js --rule=S030 --input=examples/rule-test-fixtures/rules/S030_directory_browsing_protection --engine=heuristic
 */

const S030SymbolBasedAnalyzer = require("./symbol-based-analyzer.js");
const S030RegexBasedAnalyzer = require("./regex-based-analyzer.js");

class S030Analyzer {
  constructor(options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`ðŸ”§ [S030] Constructor called with options:`, !!options);
      console.log(
        `ðŸ”§ [S030] Options type:`,
        typeof options,
        Object.keys(options || {})
      );
    }

    this.ruleId = "S030";
    this.ruleName =
      "Disable directory browsing and protect sensitive metadata files";
    this.description =
      "Disable directory browsing and protect sensitive metadata files (.git/, .env, config files, etc.) to prevent information disclosure and potential security vulnerabilities.";
    this.semanticEngine = options.semanticEngine || null;
    this.verbose = options.verbose || false;

    this.config = {
      useSymbolBased: true,
      fallbackToRegex: true,
      regexBasedOnly: false,
      prioritizeSymbolic: true, // Prefer symbol-based when available
      fallbackToSymbol: true, // Allow symbol analysis even without semantic engine
    };

    try {
      this.symbolAnalyzer = new S030SymbolBasedAnalyzer(this.semanticEngine);
      if (process.env.SUNLINT_DEBUG)
        console.log(`ðŸ”§ [S030] Symbol analyzer created successfully`);
    } catch (error) {
      console.error(`ðŸ”§ [S030] Error creating symbol analyzer:`, error);
    }

    try {
      this.regexAnalyzer = new S030RegexBasedAnalyzer(this.semanticEngine);
      if (process.env.SUNLINT_DEBUG)
        console.log(`ðŸ”§ [S030] Regex analyzer created successfully`);
    } catch (error) {
      console.error(`ðŸ”§ [S030] Error creating regex analyzer:`, error);
    }
  }

  async initialize(semanticEngine) {
    this.semanticEngine = semanticEngine;
    if (process.env.SUNLINT_DEBUG)
      console.log(`ðŸ”§ [S030] Main analyzer initializing...`);

    if (this.symbolAnalyzer)
      await this.symbolAnalyzer.initialize?.(semanticEngine);
    if (this.regexAnalyzer)
      await this.regexAnalyzer.initialize?.(semanticEngine);
    if (this.regexAnalyzer) this.regexAnalyzer.cleanup?.();

    if (process.env.SUNLINT_DEBUG)
      console.log(`ðŸ”§ [S030] Main analyzer initialized successfully`);
  }

  analyzeSingle(filePath, options = {}) {
    if (process.env.SUNLINT_DEBUG)
      console.log(`ðŸ” [S030] analyzeSingle() called for: ${filePath}`);
    return this.analyze([filePath], "typescript", options);
  }

  async analyze(files, language, options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(
        `ðŸ”§ [S030] analyze() method called with ${files.length} files, language: ${language}`
      );
    }

    const violations = [];
    for (const filePath of files) {
      try {
        if (process.env.SUNLINT_DEBUG)
          console.log(`ðŸ”§ [S030] Processing file: ${filePath}`);
        const fileViolations = await this.analyzeFile(filePath, options);
        violations.push(...fileViolations);
        if (process.env.SUNLINT_DEBUG)
          console.log(
            `ðŸ”§ [S030] File ${filePath}: Found ${fileViolations.length} violations`
          );
      } catch (error) {
        console.warn(
          `âš  [S030] Analysis failed for ${filePath}:`,
          error.message
        );
      }
    }

    if (process.env.SUNLINT_DEBUG)
      console.log(`ðŸ”§ [S030] Total violations found: ${violations.length}`);
    return violations;
  }

  async analyzeFile(filePath, options = {}) {
    if (process.env.SUNLINT_DEBUG)
      console.log(`ðŸ” [S030] analyzeFile() called for: ${filePath}`);
    const violationMap = new Map();

    // Try symbol-based analysis first when semantic engine is available OR when explicitly enabled
    if (process.env.SUNLINT_DEBUG) {
      console.log(
        `ðŸ”§ [S030] Symbol check: useSymbolBased=${
          this.config.useSymbolBased
        }, semanticEngine=${!!this.semanticEngine}, project=${!!this
          .semanticEngine?.project}, initialized=${!!this.semanticEngine
          ?.initialized}`
      );
    }

    const canUseSymbol =
      this.config.useSymbolBased &&
      ((this.semanticEngine?.project && this.semanticEngine?.initialized) ||
        (!this.semanticEngine && this.config.fallbackToSymbol !== false));

    if (canUseSymbol) {
      try {
        if (process.env.SUNLINT_DEBUG)
          console.log(`ðŸ”§ [S030] Trying symbol-based analysis...`);

        let sourceFile = null;
        if (this.semanticEngine?.project) {
          sourceFile = this.semanticEngine.project.getSourceFile(filePath);
          if (process.env.SUNLINT_DEBUG) {
            console.log(
              `ðŸ”§ [S030] Checked existing semantic engine project: sourceFile=${!!sourceFile}`
            );
          }
        }

        if (!sourceFile) {
          // Create a minimal ts-morph project for this analysis
          if (process.env.SUNLINT_DEBUG)
            console.log(
              `ðŸ”§ [S030] Creating temporary ts-morph project for: ${filePath}`
            );
          try {
            const fs = require("fs");
            const path = require("path");
            const { Project } = require("ts-morph");

            // Check if file exists and read content
            if (!fs.existsSync(filePath)) {
              throw new Error(`File not found: ${filePath}`);
            }

            const fileContent = fs.readFileSync(filePath, "utf8");
            const fileName = path.basename(filePath);

            const tempProject = new Project({
              useInMemoryFileSystem: true,
              compilerOptions: {
                allowJs: true,
                allowSyntheticDefaultImports: true,
              },
            });

            // Add file content to in-memory project
            sourceFile = tempProject.createSourceFile(fileName, fileContent);
            if (process.env.SUNLINT_DEBUG)
              console.log(
                `ðŸ”§ [S030] Temporary project created successfully with file: ${fileName}`
              );
          } catch (projectError) {
            if (process.env.SUNLINT_DEBUG)
              console.log(
                `ðŸ”§ [S030] Failed to create temporary project:`,
                projectError.message
              );
            throw projectError;
          }
        }

        if (sourceFile) {
          const symbolViolations = await this.symbolAnalyzer.analyze(
            sourceFile,
            filePath
          );
          symbolViolations.forEach((v) => {
            const key = `${v.line}:${v.column}:${v.message}`;
            if (!violationMap.has(key)) violationMap.set(key, v);
          });
          if (process.env.SUNLINT_DEBUG)
            console.log(
              `ðŸ”§ [S030] Symbol analysis completed: ${symbolViolations.length} violations`
            );

          // If symbol-based found violations AND prioritizeSymbolic is true, skip regex
          // But still run regex if symbol-based didn't find any violations
          if (this.config.prioritizeSymbolic && symbolViolations.length > 0) {
            const finalViolations = Array.from(violationMap.values()).map(
              (v) => ({
                ...v,
                filePath,
                file: filePath,
              })
            );
            if (process.env.SUNLINT_DEBUG)
              console.log(
                `ðŸ”§ [S030] Symbol-based analysis prioritized: ${finalViolations.length} violations`
              );
            return finalViolations;
          }
        } else {
          if (process.env.SUNLINT_DEBUG)
            console.log(
              `ðŸ”§ [S030] No source file found, skipping symbol analysis`
            );
        }
      } catch (error) {
        console.warn(`âš  [S030] Symbol analysis failed:`, error.message);
      }
    }

    // Fallback to regex-based analysis
    if (this.config.fallbackToRegex || this.config.regexBasedOnly) {
      try {
        if (process.env.SUNLINT_DEBUG)
          console.log(`ðŸ”§ [S030] Trying regex-based analysis...`);
        const regexViolations = await this.regexAnalyzer.analyze(filePath);
        regexViolations.forEach((v) => {
          const key = `${v.line}:${v.column}:${v.message}`;
          if (!violationMap.has(key)) violationMap.set(key, v);
        });
        if (process.env.SUNLINT_DEBUG)
          console.log(
            `ðŸ”§ [S030] Regex analysis completed: ${regexViolations.length} violations`
          );
      } catch (error) {
        console.warn(`âš  [S030] Regex analysis failed:`, error.message);
      }
    }

    const finalViolations = Array.from(violationMap.values()).map((v) => ({
      ...v,
      filePath,
      file: filePath,
    }));
    if (process.env.SUNLINT_DEBUG)
      console.log(
        `ðŸ”§ [S030] File analysis completed: ${finalViolations.length} unique violations`
      );
    return finalViolations;
  }

  cleanup() {
    if (this.symbolAnalyzer?.cleanup) this.symbolAnalyzer.cleanup();
    if (this.regexAnalyzer?.cleanup) this.regexAnalyzer.cleanup();
  }
}

module.exports = S030Analyzer;
