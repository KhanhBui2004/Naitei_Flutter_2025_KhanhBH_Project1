/**
 * C024 Symbol-based Analyzer - Advanced Do not scatter hardcoded constants throughout the logic
 * Purpose: The rule prevents scattering hardcoded constants throughout the logic. Instead, constants should be defined in a single place to improve maintainability and readability.
 */

const { SyntaxKind } = require('ts-morph');

class C024SymbolBasedAnalyzer {
  constructor(semanticEngine = null) {
    this.ruleId = 'C024';
    this.ruleName = 'Error Scatter hardcoded constants throughout the logic (Symbol-Based)';
    this.semanticEngine = semanticEngine;
    this.verbose = false;

    // === Files to ignore (constant/config files) ===
    this.ignoredFilePatterns = [
      /const/i,
      /constants/i,
      /enum/i,
      /enums/i,
      /interface/i,
      /interfaces/i,
      /type/i,
      /types/i,
      /dto/i,
      /model/i,
      /response/i,
      /request/i,
      /\.res\./i,
      /\.req\./i,
      /schema/i,
      /definition/i,
      /config/i,
      /configuration/i,
      // Test files
      /test\//,
      /tests\//,
      /__tests__\//,
      /\.test\./,
      /\.spec\./,
      /node_modules\//,
      /mock/i,
      /fixture/i,
    ];

    // === Safe numeric values (not magic numbers) ===
    this.safeNumbers = new Set([
      -1, 0, 1, 2, 10, 100, 1000,  // Common values
      24, 60,                       // Time-related
      100,                          // Percentages
    ]);

    // === Contexts where constants are acceptable ===
    this.acceptableContexts = [
      SyntaxKind.EnumDeclaration,
      SyntaxKind.InterfaceDeclaration,
      SyntaxKind.TypeAliasDeclaration,
      SyntaxKind.VariableDeclaration,  // Top-level constants are OK
      SyntaxKind.PropertyDeclaration,  // Class properties
    ];

    // === Frontend-specific JSX/Vue attributes to ignore ===
    this.frontendIgnoredAttributes = [
      'className',
      'class',
      'style',
      'id',
      'key',
      'ref',
      'data-testid',
      'data-cy',
      'aria-label',
      'aria-labelledby',
      'aria-describedby',
      'role',
      'placeholder',
      'title',
      'alt',
      'src',
      'href',
      'type',  // for input type="text", button type="submit"
      'name',  // form input names
      'value', // when used as JSX prop
      'defaultValue',
      'label',
      'htmlFor',
      'for',
    ];

    // === Common form/state management function names to ignore ===
    this.frontendIgnoredFunctions = [
      'setValue',
      'getValue',
      'setFieldValue',
      'getFieldValue',
      'register',
      'unregister',
      'watch',
      'reset',
      'resetField',
      'setError',
      'clearErrors',
      'trigger',
      'control',
      'handleSubmit',
      // Vue specific
      'defineProps',
      'defineEmits',
      'ref',
      'computed',
      'reactive',
      // State management
      'dispatch',
      'commit',
      'useState',
      'useReducer',
    ];

    // === String patterns that are acceptable (not magic strings) ===
    this.acceptableStringPatterns = [
      // Empty or very short strings (1-3 chars only)
      /^$/,
      /^.$/,
      /^..$/,
      /^...$/,

      // Common delimiters and formatting
      /^[,;:\.\-_\/\\|]+$/,
      /^\s+$/,
      /^[\r\n]+$/,

      // HTML/XML tags
      /^<[^>]+>$/,

      // Common boolean-like words (exact match only)
      /^(true|false|yes|no|ok|error|success|fail|null|undefined)$/i,

      // Property access patterns
      /^\./,
      /^\[.*\]$/,

      // SQL/Query patterns - table.column notation
      /^[a-z_][a-z0-9_]*\.[a-z_][a-z0-9_]*$/i,  // table.column
      /\.[a-z_][a-z0-9_]*$/i,                    // .column_name
      /^[a-z_][a-z0-9_]*\.[a-z_][a-z0-9_]*\s+(LIKE|=|>|<|!=|IS)/i, // SQL conditions
      /^[a-z_][a-z0-9_]*\.[a-z_][a-z0-9_]*\s+is\s+(null|not null)/i, // IS NULL checks

      // table.column AS alias
      /^[a-z_][a-z0-9_]*\.[a-z_][a-z0-9_]*\s+as\s+[a-z_][a-z0-9_]*$/i,

      // table.column alias (implicit alias)
      /^[a-z_][a-z0-9_]*\.[a-z_][a-z0-9_]*\s+[a-z_][a-z0-9_]*$/i,

      // SQL keywords
      /^(SELECT|INSERT|UPDATE|DELETE|FROM|WHERE|AND|OR|JOIN|ON|AS|LIKE|IN|NOT|IS|NULL)\s/i,
      /\s+(is null|is not null)$/i,  // NULL checks

      // TypeScript typeof checks
      /^(string|number|boolean|object|function|symbol|bigint|undefined)$/,

      // Common file extensions
      /^\.[a-z]{2,4}$/i,

      // HTTP methods and REST paths
      /^(GET|POST|PUT|PATCH|DELETE|HEAD|OPTIONS)$/i,
      /^\/[a-z0-9\-_\/]*$/i,  // URL paths: /api/users, /search

      // Event names (kebab-case or camelCase with common prefixes)
      /^(on|handle|click|change|submit|load|error|success)/i,
      /-activity$/i,
      /-service$/i,
      /-handler$/i,
      /-event$/i,

      // Status codes (lowercase or kebab-case only, not SCREAMING_CASE)
      /^(pending|active|inactive|completed|failed|success|error)$/i,
      /^[a-z]+(-[a-z]+)*$/,  // kebab-case only

      // Common paths
      /^[\.\/]/,

      // Variable interpolation
      /\$\{.*\}/,

      // Error messages (human-readable sentences with spaces)
      /^[A-Z][a-z]+\s+.+/,  // "User not found", "Invalid parameter" (must have space and more text)
      /Exception$/,
      /Error$/,

      // SQL parameter placeholders
      /^:[a-zA-Z_][a-zA-Z0-9_]*$/,  // :empNo, :userId
      /^@[a-zA-Z_][a-zA-Z0-9_]*$/,  // @param, @userId

      // ===== FRONTEND CSS CLASS PATTERNS =====

      // Tailwind CSS utility classes - comprehensive patterns
      /^[a-z]+-\d+$/,                           // w-40, h-12, p-4, m-8, text-lg, space-x-4
      /^[a-z]+-\d+\/\d+$/,                      // w-1/2, w-3/4, col-span-2/3
      /^[a-z]+-\[\d+(\.\d+)?(px|em|rem|%|vh|vw)\]$/, // w-[100px], h-[50vh], p-[1.5rem]
      /^[a-z]+-(xs|sm|md|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/,  // text-sm, rounded-lg, shadow-xl
      /^(sm|md|lg|xl|2xl):[a-z]+-\d+$/,         // md:w-40, lg:p-8 (responsive)
      /^(sm|md|lg|xl|2xl):[a-z]+-[a-z0-9]+$/,   // md:flex, lg:hidden (responsive variants)
      /^hover:[a-z]+-[a-z0-9]+$/,               // hover:bg-blue-500, hover:text-white
      /^focus:[a-z]+-[a-z0-9]+$/,               // focus:ring-2, focus:outline-none
      /^active:[a-z]+-[a-z0-9]+$/,              // active:bg-gray-700
      /^disabled:[a-z]+-[a-z0-9]+$/,            // disabled:opacity-50
      /^dark:[a-z]+-[a-z0-9]+$/,                // dark:bg-gray-800, dark:text-white
      /^(bg|text|border|ring|from|to|via)-[a-z]+-\d{2,3}$/,   // bg-blue-500, text-gray-700
      /^-?[a-z]+-\d+$/,                         // -m-4, -top-2 (negative values)
      /^(flex|grid|inline|block|hidden|relative|absolute|fixed|sticky|static)$/i,
      /^justify-(start|end|center|between|around|evenly)$/,
      /^items-(start|end|center|baseline|stretch)$/,
      /^col-span-\d+$/,
      /^row-span-\d+$/,
      /^gap-\d+$/,
      /^space-[xy]-\d+$/,
      /^(min|max)-(w|h)-\d+$/,
      /^(min|max)-(w|h)-(full|screen|fit|min|max)$/,
      /^flex-(row|col|wrap|nowrap|1|auto|initial|none)$/,
      /^grid-(cols|rows)-\d+$/,
      /^overflow-(auto|hidden|visible|scroll|x-auto|y-auto|x-hidden|y-hidden)$/,
      /^cursor-(pointer|default|wait|text|move|not-allowed|help|none|auto)$/,
      /^select-(none|text|all|auto)$/,
      /^pointer-events-(none|auto)$/,
      /^resize-(none|both|x|y)$/,
      /^outline-(none|white|black|\d+)$/,
      /^opacity-\d+$/,
      /^z-\d+$/,
      /^order-\d+$/,
      /^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/,
      /^tracking-(tighter|tight|normal|wide|wider|widest)$/,
      /^leading-(none|tight|snug|normal|relaxed|loose|\d+)$/,
      /^(top|right|bottom|left|inset)-(0|auto|\d+)$/,
      /^(rounded|border)-(t|r|b|l|tl|tr|br|bl)-\d+$/,
      /^divide-(x|y)-\d+$/,
      /^whitespace-(normal|nowrap|pre|pre-line|pre-wrap)$/,
      /^break-(normal|words|all|keep)$/,
      /^truncate$/,
      /^line-clamp-\d+$/,
      /^(uppercase|lowercase|capitalize|normal-case)$/,
      /^(underline|overline|line-through|no-underline)$/,
      /^(italic|not-italic)$/,
      /^placeholder-[a-z]+-\d{3}$/,
      /^caret-[a-z]+-\d{3}$/,
      /^accent-[a-z]+-\d{3}$/,
      /^aspect-(auto|square|video)$/,
      /^columns-\d+$/,
      /^break-(before|after|inside)-(auto|avoid|all|avoid-page|page|left|right|column)$/,

      // Multiple CSS classes in one string (space-separated)
      /^([a-z\-]+\s+)+[a-z\-]+$/,               // "flex gap-2", "text-sm font-bold"

      // Bootstrap classes
      /^(container|row|col)(-[a-z]{2})?(-\d+)?$/,
      /^(btn|alert|badge|card|modal|navbar|dropdown|form|input|table|nav|pagination|breadcrumb|tooltip|popover)(-[a-z]+)*$/,
      /^[a-z]+-\d$/,
      /^(d|p|m|pt|pb|pl|pr|px|py|mt|mb|ml|mr|mx|my)-(0|1|2|3|4|5|auto)$/,
      /^text-(left|center|right|justify|primary|secondary|success|danger|warning|info|light|dark|muted|white|body)$/,
      /^bg-(primary|secondary|success|danger|warning|info|light|dark|white|transparent|body)$/,
      /^border-(primary|secondary|success|danger|warning|info|light|dark|white|0)$/,
      /^rounded(-top|-bottom|-left|-right|-circle|-pill|-\d+)?$/,
      /^shadow(-sm|-lg|-none)?$/,
      /^(w|h)-(25|50|75|100|auto)$/,
      /^(float|clearfix)-(left|right|none|start|end)$/,
      /^position-(static|relative|absolute|fixed|sticky)$/,
      /^(show|hide|visible|invisible|sr-only)$/,

      // Vue.js specific (scoped classes, v-bind classes)
      /^v-[a-z]+(-[a-z]+)*$/,
      /^_[a-z0-9]+_\d+$/,
      /^data-v-[a-f0-9]{8}$/,

      // React/Vue conditional classes
      /^\{.*\?\.*:.*\}$/,

      // Common CSS framework patterns
      /^is-[a-z]+$/,
      /^has-[a-z]+$/,
      /^(show|hide|visible|invisible|disabled|enabled|loading|active|inactive)$/i,

      // Icon classes
      /^(icon|fa|fas|far|fab|fal|fad|material-icons|mi|mdi|bi|ri)(-[a-z0-9]+)*$/,

      // Animation and transition classes
      /^(animate|animation|transition|transform|duration|delay|ease)(-[a-z0-9]+)*$/,
      /^(fade|slide|zoom|bounce|rotate|scale|spin|ping|pulse)(-[a-z]+)*$/,

      // Common Japanese/localized placeholders (for your use case)
      /^[„ÅÅ-„Çì„Ç°-„É∂„Éº‰∏Ä-Èæ†„ÄÖ„ÄÜ„Ä§]+„Çí[ÈÅ∏ÊäûÂÖ•ÂäõË®òÂÖ•]/,  // ÂßîË®óÂÖÉ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ
      /^[„ÅÅ-„Çì„Ç°-„É∂„Éº‰∏Ä-Èæ†„ÄÖ„ÄÜ„Ä§]+„Åó„Å¶„Åè„Å†„Åï„ÅÑ$/,     // „Åó„Å¶„Åè„Å†„Åï„ÅÑ patterns
      /^[„ÅÅ-„Çì„Ç°-„É∂„Éº‰∏Ä-Èæ†„ÄÖ„ÄÜ„Ä§\s]+$/,              // Japanese text (UI labels)
    ];

    // === Minimum thresholds ===
    this.minStringLength = 4;      // Strings shorter than this are ignored
    this.minNumberValue = 1000;    // Numbers less than this need more context
    this.minOccurrences = 5;       // Need to appear at least this many times
  }

  async initialize(semanticEngine = null) {
    if (semanticEngine) {
      this.semanticEngine = semanticEngine;
    }
    this.verbose = semanticEngine?.verbose || false;

    if (process.env.SUNLINT_DEBUG) {
      console.log(`üîß [C024 Symbol-Based] Analyzer initialized, verbose: ${this.verbose}`);
    }
  }

  async analyzeFileBasic(filePath, options = {}) {
    return await this.analyzeFileWithSymbols(filePath, options);
  }

  async analyzeFileWithSymbols(filePath, options = {}) {
    const violations = [];

    const verbose = options.verbose || this.verbose;

    if (!this.semanticEngine?.project) {
      if (verbose) {
        console.warn('[C024 Symbol-Based] No semantic engine available, skipping analysis');
      }
      return violations;
    }

    if (this.shouldIgnoreFile(filePath)) {
      if (verbose) console.log(`[${this.ruleId}] Ignoring ${filePath}`);
      return violations;
    }

    if (verbose) {
      console.log(`üîç [C024 Symbol-Based] Starting analysis for ${filePath}`);
    }

    try {
      const sourceFile = this.semanticEngine.project.getSourceFile(filePath);
      if (!sourceFile) {
        if (verbose) {
          console.log(`‚ö†Ô∏è  [C024] Could not load source file: ${filePath}`);
        }
        return violations;
      }

      const constantUsage = new Map();

      this.checkNumericLiterals(sourceFile, violations, constantUsage);
      this.checkStringLiterals(sourceFile, violations, constantUsage);
      this.checkDuplicateConstants(constantUsage, sourceFile, violations);

      if (verbose) {
        console.log(`‚úÖ [C024] Found ${violations.length} violations in ${filePath}`);
      }

      if (verbose) {
        console.log(`üîç [C024 Symbol-Based] Total violations found: ${violations.length}`);
      }

      return violations;
    } catch (error) {
      if (verbose) {
        console.warn(`[C024 Symbol-Based] Analysis failed for ${filePath}:`, error.message);
      }

      return violations;
    }
  }

  createViolation(node, sourceFile, message, type, value) {
    return {
      ruleId: this.ruleId,
      severity: 'medium',
      message: message,
      source: this.ruleId,
      file: sourceFile.getFilePath(),
      line: node.getStartLineNumber(),
      column: node.getStart() - node.getStartLinePos() + 1,
      description:
        "[SYMBOL-BASED] Hardcoded constants should be defined in a single place to improve maintainability.",
      category: "maintainability",
      suggestion: `Define the ${type} '${value}' in a dedicated constants file or section`,
    };
  }

  checkNumericLiterals(sourceFile, violations, constantUsage) {
    const numericLiterals = sourceFile.getDescendantsOfKind(SyntaxKind.NumericLiteral);

    numericLiterals.forEach(literal => {
      const value = literal.getLiteralValue();
      const text = literal.getText();

      if (this.safeNumbers.has(value)) {
        return;
      }

      if (this.isInAcceptableContext(literal)) {
        return;
      }

      if (this.isArrayIndexOrLoopCounter(literal)) {
        return;
      }

      this.trackConstant(constantUsage, `number:${value}`, literal);

      if (Math.abs(value) >= this.minNumberValue || this.isLikelyMagicNumber(literal)) {
        violations.push(this.createViolation(
          literal,
          sourceFile,
          `Magic number '${text}' should be extracted as a named constant`,
          'magic-number',
          value
        ));
      }
    });
  }

  checkStringLiterals(sourceFile, violations, constantUsage) {
    const stringLiterals = sourceFile.getDescendantsOfKind(SyntaxKind.StringLiteral);

    stringLiterals.forEach(literal => {
      const value = literal.getLiteralValue();
      const text = literal.getText();

      if (value.length < this.minStringLength) {
        return;
      }

      if (this.isAcceptableString(value)) {
        return;
      }

      if (this.isInAcceptableContext(literal)) {
        return;
      }

      // NEW: Skip if it's a JSX/Vue attribute value (className, placeholder, etc.)
      if (this.isJsxAttributeValue(literal)) {
        return;
      }

      // NEW: Skip if it's inside a spread operator (...placeholder)
      if (this.isSpreadElement(literal)) {
        return;
      }

      // NEW: Skip if it's a common frontend function argument
      if (this.isFrontendFunctionArgument(literal)) {
        console.log('Skipping frontend function argument:', literal.getText());
        return;
      }

      if (this.isPropertyKey(literal)) {
        return;
      }

      if (this.isQueryBuilderPattern(literal)) {
        return;
      }

      if (this.isTemplateWithVariables(literal)) {
        return;
      }

      this.trackConstant(constantUsage, `string:${value}`, literal);

      if (this.isInLogicContext(literal) || this.isInComparison(literal)) {
        violations.push(this.createViolation(
          literal,
          sourceFile,
          `Magic string '${this.truncate(value, 50)}' should be extracted as a named constant`,
          'magic-string',
          value
        ));
      }
    });
  }

  checkDuplicateConstants(constantUsage, sourceFile, violations) {
    for (const [key, locations] of constantUsage.entries()) {
      if (locations.length >= this.minOccurrences) {
        const [type, value] = key.split(':', 2);
        const firstLocation = locations[0];

        // NEW: Skip if the first location is in a frontend/JSX context
        if (this.isJsxAttributeValue(firstLocation)) {
          continue;
        }

        if (this.isSpreadElement(firstLocation)) {
          continue;
        }

        if (this.isFrontendFunctionArgument(firstLocation)) {
          continue;
        }

        // NEW: Filter out locations that are in frontend contexts
        const validLocations = locations.filter(loc => {
          return !this.isJsxAttributeValue(loc) &&
                 !this.isSpreadElement(loc) &&
                 !this.isFrontendFunctionArgument(loc);
        });

        // Only flag if there are still enough valid occurrences after filtering
        if (validLocations.length < this.minOccurrences) {
          continue;
        }

        const alreadyFlagged = violations.some(v =>
          v.line === firstLocation.getStartLineNumber() &&
          v.column === firstLocation.getStart() - firstLocation.getStartLinePos() + 1
        );

        if (!alreadyFlagged) {
          violations.push(this.createViolation(
            firstLocation,
            sourceFile,
            `Duplicate constant '${this.truncate(value, 50)}' used ${validLocations.length} times. Extract to a named constant.`,
            'duplicate-constant',
            value
          ));
        }
      }
    }
  }

  /**
   * NEW: Check if string literal is a JSX/Vue attribute value
   * Example: <div className="flex gap-2"> or placeholder="ÂßîË®óÂÖÉ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ"
   */
  isJsxAttributeValue(node) {
    let parent = node.getParent();
    let depth = 0;
    const maxDepth = 5;

    while (parent && depth < maxDepth) {
      const kind = parent.getKind();

      // Direct JsxAttribute: <Component attribute="value" />
      if (kind === SyntaxKind.JsxAttribute) {
        const attrName = parent.getName?.()?.getText();
        // Always ignore ANY JSX attribute value (not just specific ones)
        // This handles className, id, style, data-*, aria-*, etc.
        return true;

        // Or if you want to be selective:
        // if (this.frontendIgnoredAttributes.includes(attrName) ||
        //     attrName.startsWith('data-') ||
        //     attrName.startsWith('aria-')) {
        //   return true;
        // }
      }

      // JsxExpression: <Component className={variable} />
      if (kind === SyntaxKind.JsxExpression) {
        const jsxParent = parent.getParent();
        if (jsxParent && jsxParent.getKind() === SyntaxKind.JsxAttribute) {
          return true;
        }
      }

      // PropertyAssignment in object literal: { className: "flex gap-3" }
      if (kind === SyntaxKind.PropertyAssignment) {
        const propName = parent.getName?.()?.getText();
        if (this.frontendIgnoredAttributes.includes(propName)) {
          // Check if this is inside JSX context or props object
          if (this.isInsideJsxElement(parent) || this.isInsidePropsObject(parent)) {
            return true;
          }
        }
      }

      // Template literal in JSX: className={`flex gap-${size}`}
      if (kind === SyntaxKind.TemplateExpression || kind === SyntaxKind.TemplateSpan) {
        if (this.isInsideJsxElement(parent)) {
          return true;
        }
      }

      // ConditionalExpression in JSX: className={isActive ? "active" : "inactive"}
      if (kind === SyntaxKind.ConditionalExpression) {
        if (this.isInsideJsxElement(parent)) {
          return true;
        }
      }

      // Binary expression in JSX: className={"flex" + " gap-3"}
      if (kind === SyntaxKind.BinaryExpression) {
        const binaryParent = parent.getParent();
        if (binaryParent &&
            (binaryParent.getKind() === SyntaxKind.JsxExpression ||
             binaryParent.getKind() === SyntaxKind.JsxAttribute)) {
          return true;
        }
      }

      // ObjectLiteralExpression that's passed as props
      if (kind === SyntaxKind.ObjectLiteralExpression) {
        const objParent = parent.getParent();
        if (objParent) {
          // Check if this object is spread into JSX: <Component {...props} />
          if (objParent.getKind() === SyntaxKind.JsxSpreadAttribute) {
            return true;
          }
          // Check if this object is assigned to a props variable
          if (objParent.getKind() === SyntaxKind.VariableDeclaration) {
            const varName = objParent.getName?.()?.getText();
            if (varName && /props|attributes|attrs|componentProps/i.test(varName)) {
              return true;
            }
          }
        }
      }

      parent = parent.getParent();
      depth++;
    }

    return false;
  }

  /**
   * Helper: Check if node is inside a props object being passed to a component
   */
  isInsidePropsObject(node) {
    let parent = node.getParent();
    let depth = 0;
    const maxDepth = 5;

    while (parent && depth < maxDepth) {
      const kind = parent.getKind();

      // Variable declaration with props-like name
      if (kind === SyntaxKind.VariableDeclaration) {
        const varName = parent.getName?.()?.getText();
        if (varName && /props|attributes|attrs|config|options|settings/i.test(varName)) {
          return true;
        }
      }

      // Object being returned or passed as argument
      if (kind === SyntaxKind.ObjectLiteralExpression) {
        const objParent = parent.getParent();
        if (objParent) {
          // Return statement in component
          if (objParent.getKind() === SyntaxKind.ReturnStatement) {
            return true;
          }
          // Call expression argument (passing props to component)
          if (objParent.getKind() === SyntaxKind.CallExpression) {
            return true;
          }
        }
      }

      // Arrow function or function that likely returns JSX props
      if (kind === SyntaxKind.ArrowFunction || kind === SyntaxKind.FunctionExpression) {
        const funcName = this.getFunctionName(parent);
        if (funcName && /props|attributes|config|get.*Props/i.test(funcName)) {
          return true;
        }
      }

      parent = parent.getParent();
      depth++;
    }

    return false;
  }

  /**
   * Helper: Get function name from various function types
   */
  getFunctionName(functionNode) {
    const parent = functionNode.getParent();
    if (!parent) return null;

    // Variable declaration: const getProps = () => {}
    if (parent.getKind() === SyntaxKind.VariableDeclaration) {
      return parent.getName?.()?.getText();
    }

    // Function declaration: function getProps() {}
    if (functionNode.getKind() === SyntaxKind.FunctionDeclaration) {
      return functionNode.getName?.()?.getText();
    }

    // Method: { getProps() {} }
    if (parent.getKind() === SyntaxKind.MethodDeclaration) {
      return parent.getName?.()?.getText();
    }

    // Property assignment: { getProps: () => {} }
    if (parent.getKind() === SyntaxKind.PropertyAssignment) {
      return parent.getName?.()?.getText();
    }

    return null;
  }

  /**
   * NEW: Check if node is inside JSX element
   */
  isInsideJsxElement(node) {
    let parent = node.getParent();
    let depth = 0;
    const maxDepth = 5;

    while (parent && depth < maxDepth) {
      const kind = parent.getKind();
      if (kind === SyntaxKind.JsxElement ||
          kind === SyntaxKind.JsxSelfClosingElement ||
          kind === SyntaxKind.JsxFragment) {
        return true;
      }
      parent = parent.getParent();
      depth++;
    }

    return false;
  }

  /**
   * NEW: Check if string is inside spread element
   * Example: {...field} or {...placeholder}
   */
  isSpreadElement(node) {
    let parent = node.getParent();
    let depth = 0;
    const maxDepth = 5;

    while (parent && depth < maxDepth) {
      const kind = parent.getKind();
      if (kind === SyntaxKind.SpreadElement ||
          kind === SyntaxKind.SpreadAssignment ||
          kind === SyntaxKind.JsxSpreadAttribute) {
        return true;
      }
      parent = parent.getParent();
      depth++;
    }

    return false;
  }

  /**
   * NEW: Check if string is argument to common frontend functions
   * Example: setValue('invoiceSendFlg', false), resetField('leaseInspectionType')
   */
  isFrontendFunctionArgument(node) {
    let parent = node.getParent();
    let depth = 0;
    const maxDepth = 5; // Increased depth to handle nested calls

    while (parent && depth < maxDepth) {
      // Check if current parent is a CallExpression
      if (parent.getKind() === SyntaxKind.CallExpression) {
        const callExpr = parent;
        const expression = callExpr.getExpression();
        const funcName = expression.getText();

        // Check if it's one of the ignored frontend functions
        const matchesFrontendFunc = this.frontendIgnoredFunctions.some(ignoredFunc =>
          funcName.includes(ignoredFunc) || funcName.endsWith(ignoredFunc)
        );

        if (matchesFrontendFunc) {
          // For most functions, check if the string is the first argument
          const args = callExpr.getArguments();

          // Special handling for array arguments (like trigger(['field1', 'field2']))
          if (args.length > 0) {
            const firstArg = args[0];

            // Check if node is the first argument directly
            if (firstArg === node) {
              return true;
            }

            // Check if node is inside an array that is the first argument
            // Example: trigger(['userEmail', 'userFax'])
            if (firstArg.getKind() === SyntaxKind.ArrayLiteralExpression) {
              const arrayElements = firstArg.getElements();
              if (arrayElements.some(el => el === node || this.isDescendantOf(node, el))) {
                return true;
              }
            }

            // Check if node is anywhere in the arguments for certain functions
            // This handles cases like: onChange: (event) => { setValue('aprch', null); }
            if (args.some(arg => arg === node || this.isDescendantOf(node, arg))) {
              // Only return true if it's a direct argument, not nested deep in logic
              const directArgIndex = args.findIndex(arg => arg === node);
              if (directArgIndex !== -1) {
                return true;
              }
            }
          }
        }
      }

      // Special case: Check if we're inside an object literal passed to a frontend function
      // Example: register('aprchFlg', { onChange: ... })
      if (parent.getKind() === SyntaxKind.ObjectLiteralExpression) {
        const objectParent = parent.getParent();
        if (objectParent && objectParent.getKind() === SyntaxKind.CallExpression) {
          const callExpr = objectParent;
          const expression = callExpr.getExpression();
          const funcName = expression.getText();

          const matchesFrontendFunc = this.frontendIgnoredFunctions.some(ignoredFunc =>
            funcName.includes(ignoredFunc) || funcName.endsWith(ignoredFunc)
          );

          // If we're in an options object for a frontend function, check nested calls
          if (matchesFrontendFunc) {
            // Continue checking - we might be in a callback
            parent = parent.getParent();
            depth++;
            continue;
          }
        }
      }

      // Special case: Inside arrow function or function expression (callbacks)
      // Example: onChange: (event) => { trigger(['field']) }
      if (parent.getKind() === SyntaxKind.ArrowFunction ||
          parent.getKind() === SyntaxKind.FunctionExpression) {
        // Check if this function is a callback for a frontend function
        const funcParent = parent.getParent();
        if (funcParent && funcParent.getKind() === SyntaxKind.PropertyAssignment) {
          const propName = funcParent.getName?.()?.getText();
          // Common callback property names in React/Vue forms
          if (['onChange', 'onBlur', 'onFocus', 'onClick', 'onSubmit', 'validator', 'transform'].includes(propName)) {
            // Continue up the tree to find the actual frontend function call
            parent = parent.getParent();
            depth++;
            continue;
          }
        }
      }

      parent = parent.getParent();
      depth++;
    }

    return false;
  }

  /**
   * Helper function to check if node is a descendant of parent
   */
  isDescendantOf(node, parent) {
    if (!node || !parent) return false;

    let current = node.getParent();
    let depth = 0;
    const maxDepth = 10;

    while (current && depth < maxDepth) {
      if (current === parent) {
        return true;
      }
      current = current.getParent();
      depth++;
    }

    return false;
  }

  isInAcceptableContext(node) {
    let parent = node.getParent();
    let depth = 0;
    const maxDepth = 5;

    while (parent && depth < maxDepth) {
      const kind = parent.getKind();

      if (kind === SyntaxKind.VariableDeclaration) {
        const varDecl = parent;
        const varStatement = varDecl.getParent()?.getParent();
        if (varStatement && varStatement.getKind() === SyntaxKind.VariableStatement) {
          const isConst = varStatement.getDeclarationKind() === 'const';
          if (isConst) {
            return true;
          }
        }
      }

      if (this.acceptableContexts.includes(kind)) {
        return true;
      }

      if (kind === SyntaxKind.ObjectLiteralExpression) {
        const objectParent = parent.getParent();
        if (objectParent?.getKind() === SyntaxKind.VariableDeclaration) {
          return true;
        }
      }

      if (kind === SyntaxKind.ArrayLiteralExpression) {
        const arrayParent = parent.getParent();
        if (arrayParent?.getKind() === SyntaxKind.VariableDeclaration) {
          return true;
        }
      }

      if (kind === SyntaxKind.Decorator) {
        return true;
      }

      if (kind === SyntaxKind.CallExpression) {
        const callParent = parent.getParent();
        if (callParent?.getKind() === SyntaxKind.Decorator) {
          return true;
        }
      }

      if (kind === SyntaxKind.TypeOfExpression) {
        return true;
      }

      if (kind === SyntaxKind.BinaryExpression) {
        const binaryExpr = parent;
        const left = binaryExpr.getLeft();
        if (left.getKind() === SyntaxKind.TypeOfExpression) {
          return true;
        }
      }

      parent = parent.getParent();
      depth++;
    }

    return false;
  }

  isArrayIndexOrLoopCounter(node) {
    const parent = node.getParent();
    if (!parent) return false;

    const kind = parent.getKind();

    if (kind === SyntaxKind.ElementAccessExpression) {
      return true;
    }

    if (kind === SyntaxKind.BinaryExpression ||
        kind === SyntaxKind.PostfixUnaryExpression ||
        kind === SyntaxKind.PrefixUnaryExpression) {
      return true;
    }

    return false;
  }

  isLikelyMagicNumber(node) {
    const parent = node.getParent();
    if (!parent) return false;

    if (parent.getKind() === SyntaxKind.BinaryExpression) {
      const binaryExpr = parent;
      const operator = binaryExpr.getOperatorToken().getText();
      if (['>', '<', '>=', '<=', '===', '!==', '==', '!='].includes(operator)) {
        return true;
      }
    }

    if (parent.getKind() === SyntaxKind.BinaryExpression) {
      const binaryExpr = parent;
      const operator = binaryExpr.getOperatorToken().getText();
      if (['*', '/', '%'].includes(operator)) {
        return true;
      }
    }

    return false;
  }

  isAcceptableString(value) {
    return this.acceptableStringPatterns.some(pattern => pattern.test(value));
  }

  isPropertyKey(node) {
    const parent = node.getParent();
    if (!parent) return false;

    if (parent.getKind() === SyntaxKind.PropertyAssignment) {
      const prop = parent;
      return prop.getInitializer() !== node;
    }

    if (parent.getKind() === SyntaxKind.PropertyAccessExpression) {
      return true;
    }

    if (parent.getKind() === SyntaxKind.CallExpression) {
      const callParent = parent.getParent();
      if (callParent?.getKind() === SyntaxKind.Decorator) {
        return true;
      }
    }

    return false;
  }

  isQueryBuilderPattern(node) {
    let parent = node.getParent();
    let depth = 0;
    const maxDepth = 5;

    while (parent && depth < maxDepth) {
      const kind = parent.getKind();

      if (kind === SyntaxKind.CallExpression) {
        const callExpr = parent;
        const expression = callExpr.getExpression();
        const exprText = expression.getText();

        if (/\.(where|andWhere|orWhere|having|andHaving|orHaving|select|addSelect|leftJoin|innerJoin|join|orderBy|groupBy|setParameter)$/i.test(exprText)) {
          return true;
        }

        if (/(queryBuilder|qb|query)\.(where|andWhere|orWhere)/i.test(exprText)) {
          return true;
        }
      }

      if (kind === SyntaxKind.ConditionalExpression) {
        parent = parent.getParent();
        depth++;
        continue;
      }

      parent = parent.getParent();
      depth++;
    }

    return false;
  }

  isTemplateWithVariables(node) {
    const parent = node.getParent();
    if (!parent) return false;

    if (parent.getKind() === SyntaxKind.TemplateExpression) {
      return true;
    }

    return false;
  }

  isInLogicContext(node) {
    let parent = node.getParent();
    let depth = 0;
    const maxDepth = 5;

    while (parent && depth < maxDepth) {
      const kind = parent.getKind();

      if (kind === SyntaxKind.ElementAccessExpression) {
        return false;
      }

      if (kind === SyntaxKind.FunctionDeclaration ||
          kind === SyntaxKind.MethodDeclaration ||
          kind === SyntaxKind.ArrowFunction ||
          kind === SyntaxKind.FunctionExpression) {
        return true;
      }

      if (kind === SyntaxKind.IfStatement ||
          kind === SyntaxKind.SwitchStatement ||
          kind === SyntaxKind.ForStatement ||
          kind === SyntaxKind.WhileStatement ||
          kind === SyntaxKind.DoStatement) {
        return true;
      }

      parent = parent.getParent();
      depth++;
    }

    return false;
  }

  isInComparison(node) {
    const parent = node.getParent();
    if (!parent) return false;

    if (parent.getKind() === SyntaxKind.BinaryExpression) {
      const binaryExpr = parent;
      const operator = binaryExpr.getOperatorToken().getText();
      if (['===', '!==', '==', '!=', '>', '<', '>=', '<='].includes(operator)) {
        return true;
      }
    }

    if (parent.getKind() === SyntaxKind.CaseClause) {
      return true;
    }

    return false;
  }

  trackConstant(constantUsage, key, node) {
    if (!constantUsage.has(key)) {
      constantUsage.set(key, []);
    }
    constantUsage.get(key).push(node);
  }

  truncate(str, maxLength) {
    if (str.length <= maxLength) return str;
    return str.substring(0, maxLength) + '...';
  }

  shouldIgnoreFile(filePath) {
    return this.ignoredFilePatterns.some((pattern) => pattern.test(filePath));
  }
}

module.exports = C024SymbolBasedAnalyzer;
