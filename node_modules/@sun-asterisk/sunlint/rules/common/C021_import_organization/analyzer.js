const C021TsMorphAnalyzer = require('./ts-morph-analyzer.js');

class C021Analyzer {
  constructor(semanticEngine = null) {
    this.ruleId = 'C021';
    this.ruleName = 'Import Organization';
    this.description = 'Enforce organized imports with grouping and sorting';
    this.semanticEngine = semanticEngine;
    this.verbose = false;

    // Initialize ts-morph analyzer
    this.tsMorphAnalyzer = new C021TsMorphAnalyzer(semanticEngine);
  }

  async initialize(semanticEngine = null) {
    if (semanticEngine) {
      this.semanticEngine = semanticEngine;
    }
    this.verbose = semanticEngine?.verbose || false;

    await this.tsMorphAnalyzer.initialize(semanticEngine);
  }

  async analyzeFileBasic(filePath, options = {}) {
    const allViolations = [];

    try {
      // Use ts-morph analysis
      if (this.semanticEngine?.isSymbolEngineReady?.() && this.semanticEngine.project) {
        if (this.verbose) {
          console.log(`[DEBUG] üéØ C021: Using ts-morph analysis for ${filePath.split('/').pop()}`);
        }

        try {
          const tsMorphViolations = await this.tsMorphAnalyzer.analyzeFile(filePath, options);
          allViolations.push(...tsMorphViolations);

          if (this.verbose) {
            console.log(`[DEBUG] üéØ C021: ts-morph analysis found ${tsMorphViolations.length} violations`);
          }
        } catch (tsMorphError) {
          if (this.verbose) {
            console.warn(`[DEBUG] ‚ö†Ô∏è C021: ts-morph analysis failed: ${tsMorphError.message}`);
          }
        }
      }

      return allViolations;

    } catch (error) {
      if (this.verbose) {
        console.error(`[DEBUG] ‚ùå C021: Analysis failed: ${error.message}`);
      }
      throw new Error(`C021 analysis failed: ${error.message}`);
    }
  }

  async analyzeFiles(files, options = {}) {
    const allViolations = [];
    for (const filePath of files) {
      try {
        const violations = await this.analyzeFileBasic(filePath, options);
        allViolations.push(...violations);
      } catch (error) {
        console.warn(`C021: Skipping ${filePath}: ${error.message}`);
      }
    }
    return allViolations;
  }

  // Legacy method for backward compatibility
  async analyze(files, language, config = {}) {
    const allViolations = [];

    for (const filePath of files) {
      try {
        const fileViolations = await this.analyzeFileBasic(filePath, config);
        allViolations.push(...fileViolations);
      } catch (error) {
        console.error(`Error analyzing file ${filePath}:`, error.message);
      }
    }

    return allViolations;
  }
}

module.exports = C021Analyzer;
