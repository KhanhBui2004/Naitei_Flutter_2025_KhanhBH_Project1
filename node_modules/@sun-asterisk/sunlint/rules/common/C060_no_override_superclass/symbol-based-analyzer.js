/**
 * C060 Symbol-based Analyzer - Advanced Do not scatter hardcoded constants throughout the logic
 * Purpose: The rule prevents scattering hardcoded constants throughout the logic. Instead, constants should be defined in a single place to improve maintainability and readability.
 */

const { SyntaxKind } = require('ts-morph');

class C060SymbolBasedAnalyzer {
  constructor(semanticEngine = null) {
    this.ruleId = 'C060';
    this.ruleName = 'Do not override superclass methods (Symbol-Based)';
    this.semanticEngine = semanticEngine;
    this.verbose = false;

    // === Ignore Configuration ===
    this.ignoredClasses = [
      "React.Component",   // React components
      "React.PureComponent",
      "BaseMock",          // Custom test mocks
    ];

    this.ignoredMethods = [
      "render",            // React render
      "componentDidMount", // Some lifecycle hooks
      "componentWillUnmount",
    ];

    this.ignoredFilePatterns = [
      /node_modules/,
      /\.d\.ts$/,
      /\.test\.ts$/,
    ];
  }

  async initialize(semanticEngine = null) {
    if (semanticEngine) {
      this.semanticEngine = semanticEngine;
    }
    this.verbose = semanticEngine?.verbose || false;

    if (process.env.SUNLINT_DEBUG) {
      console.log(`ðŸ”§ [C060 Symbol-Based] Analyzer initialized, verbose: ${this.verbose}`);
    }
  }

  async analyzeFileBasic(filePath, options = {}) {
    // This is the main entry point called by the hybrid analyzer
    return await this.analyzeFileWithSymbols(filePath, options);
  }

  async analyzeFileWithSymbols(filePath, options = {}) {
    const violations = [];

    // Enable verbose mode if requested
    const verbose = options.verbose || this.verbose;

    if (!this.semanticEngine?.project) {
      if (verbose) {
        console.warn('[C060 Symbol-Based] No semantic engine available, skipping analysis');
      }
      return violations;
    }

    if (this.shouldIgnoreFile(filePath)) {
      if (verbose) console.log(`[${this.ruleId}] Ignoring ${filePath}`);
      return violations;
    }

    if (verbose) {
      console.log(`ðŸ” [C060 Symbol-Based] Starting analysis for ${filePath}`);
    }

    try {
      const sourceFile = this.semanticEngine.project.getSourceFile(filePath);
      if (!sourceFile) {
        return violations;
      }

      const classDeclarations = sourceFile.getClasses();
      for (const classDeclaration of classDeclarations) {
        const classViolations = this.analyzeClass(classDeclaration, filePath, verbose);
        violations.push(...classViolations);
      }

      if (verbose) {
        console.log(`ðŸ” [C060 Symbol-Based] Total violations found: ${violations.length}`);
      }

      return violations;
    } catch (error) {
      if (verbose) {
        console.warn(`[C060 Symbol-Based] Analysis failed for ${filePath}:`, error.message);
      }

      return violations;
    }
  }

  /**
   * Analyze one class for override violations
   */
  analyzeClass(classDeclaration, filePath, verbose) {
    const violations = [];
    const baseClass = classDeclaration.getBaseClass();
    if (!baseClass) return violations;

    // Check if this class should be ignored
    if (this.shouldIgnoreClass(baseClass)) {
      if (verbose) {
        console.log(`[${this.ruleId}] Skipping ignored base class: ${baseClass.getName()}`);
      }
      return violations;
    }

    const baseMethods = this.collectBaseMethods(baseClass);

    for (const method of classDeclaration.getMethods()) {
      // Skip ignored methods
      if (this.shouldIgnoreMethod(method)) {
        if (verbose) {
          console.log(`[${this.ruleId}] Skipping ignored method: ${method.getName()}`);
        }
        continue;
      }

      if (baseMethods.has(method.getName())) {
        const violation = this.checkMethodOverride(method, classDeclaration, filePath, verbose);
        if (violation) {
          violations.push(violation);
        }
      }
    }

    return violations;
  }

  /**
   * Collect all method names from base class
   */
  collectBaseMethods(baseClass) {
    return new Set(baseClass.getMethods().map((method) => method.getName()));
  }

  /**
   * Check if overridden method properly calls super.method()
   */
  checkMethodOverride(method, classDeclaration, filePath, verbose) {
    const body = method.getBodyText();
    if (!body) return null;

    const methodName = method.getName();
    const baseClass = classDeclaration.getBaseClass();
    if (!baseClass) return null;
    const baseClassName = baseClass.getName();

    // 1 Get all CallExpressions in the method body
    const calls = method.getDescendantsOfKind(SyntaxKind.CallExpression);

    // 2 Check for super.method() or BaseClass.prototype.method.call(this)
    const hasSuperCall = calls.some((call) => {
      const expression = call.getExpression().getText();
      return expression === `super.${methodName}`;
    });

    const hasBaseCall = calls.some((call) => {
      const expression = call.getExpression().getText();
      return expression === `${baseClassName}.prototype.${methodName}.call`;
    });

    if (!hasSuperCall && !hasBaseCall) {
      const violation = {
        ruleId: this.ruleId,
        severity: 'warning',
        message: `Overridden method '${method.getName()}' in '${classDeclaration.getName()}' does not call 'super.${method.getName()}()', potentially skipping lifecycle/resource logic.`,
        source: this.ruleId,
        file: filePath,
        line: method.getStartLineNumber(),
        column: method.getStart() - method.getStartLinePos(),
        description: `[SYMBOL-BASED] Overriding methods should call the superclass implementation to ensure proper behavior.`,
        suggestion: `Add a call to 'super.${method.getName()}()' within the method body.`,
        category: 'best-practices',
      };

      if (verbose) {
        console.log(
          `âš ï¸ [${this.ruleId}] Violation in ${filePath}: Method '${method.getName()}' overrides superclass method but does not call super.`
        );
      }

      return violation;
    }

    return null;
  }

  /**
   * Ignore logic for classes
   */
  shouldIgnoreClass(baseClass) {
    const baseName = baseClass.getName();
    return this.ignoredClasses.includes(baseName);
  }

  /**
   * Ignore logic for methods
   */
  shouldIgnoreMethod(method) {
    const methodName = method.getName();
    return this.ignoredMethods.includes(methodName);
  }

  /**
   * Ignore files based on patterns
   */
  shouldIgnoreFile(filePath) {
    return this.ignoredFilePatterns.some((pattern) => pattern.test(filePath));
  }
}

module.exports = C060SymbolBasedAnalyzer;
