/**
 * C020 ts-morph Analyzer - Unused Imports
 *
 * Detects imports that are declared but never used in the code.
 * Supports default imports, named imports, and namespace imports.
 *
 * Following Rule C005: Single responsibility - unused import detection only
 * Following Rule C006: Verb-noun naming
 */

const { Project, SyntaxKind, Node } = require('ts-morph');
const fs = require('fs');
const path = require('path');

class C020TsMorphAnalyzer {
  constructor(semanticEngine = null, options = {}) {
    this.ruleId = 'C020';
    this.ruleName = 'Unused Imports';
    this.description = 'Detect unused imports';
    this.semanticEngine = semanticEngine;
    this.project = null;
    this.verbose = false;

    // Load config
    this.config = this.loadConfig();
  }

  loadConfig() {
    try {
      const configPath = path.join(__dirname, 'config.json');
      const configData = fs.readFileSync(configPath, 'utf8');
      return JSON.parse(configData).config;
    } catch (error) {
      console.warn('[C020] Could not load config, using defaults');
      return {
        checkDefaultImports: true,
        checkNamedImports: true,
        checkNamespaceImports: true,
        ignoreTypeImports: false,
        allowedUnusedPatterns: ['^_']
      };
    }
  }

  async initialize(semanticEngine = null) {
    if (semanticEngine) {
      this.semanticEngine = semanticEngine;
    }
    this.verbose = semanticEngine?.verbose || false;

    // Use semantic engine's project if available
    if (this.semanticEngine?.project) {
      this.project = this.semanticEngine.project;
      if (this.verbose) {
        console.log('[DEBUG] ðŸŽ¯ C020: Using semantic engine project');
      }
    } else {
      this.project = new Project({
        compilerOptions: {
          target: 99,
          module: 99,
          allowJs: true,
          checkJs: false,
          jsx: 2,
        },
      });
      if (this.verbose) {
        console.log('[DEBUG] ðŸŽ¯ C020: Created standalone ts-morph project');
      }
    }
  }

  async analyze(files, language, options = {}) {
    this.verbose = options.verbose || this.verbose;

    if (!this.project) {
      await this.initialize();
    }

    const violations = [];

    for (const filePath of files) {
      try {
        const fileViolations = await this.analyzeFile(filePath, options);
        violations.push(...fileViolations);
      } catch (error) {
        if (this.verbose) {
          console.warn(`[C020] Error analyzing ${filePath}:`, error.message);
        }
      }
    }

    return violations;
  }

  async analyzeFile(filePath, options = {}) {
    // Get or add source file
    let sourceFile = this.project.getSourceFile(filePath);

    if (!sourceFile && fs.existsSync(filePath)) {
      sourceFile = this.project.addSourceFileAtPath(filePath);
    }

    if (!sourceFile) {
      return [];
    }

    const violations = [];

    // Get all imports
    const imports = this.getAllImports(sourceFile);

    // Check each import for usage
    for (const importInfo of imports) {
      if (this.isImportUnused(importInfo, sourceFile)) {
        violations.push(this.createViolation(importInfo, sourceFile));
      }
    }

    return violations;
  }

  /**
   * Get all imports from a source file
   * Returns array of import info objects
   */
  getAllImports(sourceFile) {
    const imports = [];

    // Get all import declarations
    const importDeclarations = sourceFile.getImportDeclarations();

    for (const importDecl of importDeclarations) {
      const moduleSpecifier = importDecl.getModuleSpecifierValue();

      // Check if it's a type-only import
      const isTypeOnly = importDecl.isTypeOnly();

      // Skip type imports if configured
      if (isTypeOnly && this.config.ignoreTypeImports) {
        continue;
      }

      // Get default import (e.g., import fs from 'fs')
      const defaultImport = importDecl.getDefaultImport();
      if (defaultImport && this.config.checkDefaultImports) {
        imports.push({
          type: 'default',
          name: defaultImport.getText(),
          node: importDecl,
          nameNode: defaultImport,
          moduleSpecifier,
          isTypeOnly,
          position: {
            line: importDecl.getStartLineNumber(),
            column: importDecl.getStart() - importDecl.getStartLinePos() + 1
          }
        });
      }

      // Get namespace import (e.g., import * as utils from './utils')
      const namespaceImport = importDecl.getNamespaceImport();
      if (namespaceImport && this.config.checkNamespaceImports) {
        imports.push({
          type: 'namespace',
          name: namespaceImport.getText(),
          node: importDecl,
          nameNode: namespaceImport,
          moduleSpecifier,
          isTypeOnly,
          position: {
            line: importDecl.getStartLineNumber(),
            column: importDecl.getStart() - importDecl.getStartLinePos() + 1
          }
        });
      }

      // Get named imports (e.g., import { User, Order } from './models')
      const namedImports = importDecl.getNamedImports();
      if (namedImports.length > 0 && this.config.checkNamedImports) {
        for (const namedImport of namedImports) {
          const importName = namedImport.getName();
          const aliasNode = namedImport.getAliasNode();
          const actualName = aliasNode ? aliasNode.getText() : importName;

          imports.push({
            type: 'named',
            name: actualName,
            originalName: importName,
            node: importDecl,
            nameNode: namedImport,
            moduleSpecifier,
            isTypeOnly: isTypeOnly || namedImport.isTypeOnly(),
            position: {
              line: importDecl.getStartLineNumber(),
              column: namedImport.getStart() - importDecl.getStartLinePos() + 1
            }
          });
        }
      }
    }

    return imports;
  }

  /**
   * Check if an import is unused
   */
  isImportUnused(importInfo, sourceFile) {
    const { name, isTypeOnly, moduleSpecifier } = importInfo;

    // Special case: React imports in JSX/TSX files
    // React is used implicitly for JSX transform even if not directly referenced
    if (name === 'React' && moduleSpecifier === 'react') {
      if (this.fileHasJSX(sourceFile)) {
        return false; // React is used implicitly for JSX
      }
    }

    // Check if import name matches allowed unused patterns (e.g., starts with _)
    for (const pattern of this.config.allowedUnusedPatterns) {
      const regex = new RegExp(pattern);
      if (regex.test(name)) {
        return false; // Allowed to be unused
      }
    }

    // Find all references to this import
    const nameNode = importInfo.nameNode;

    // Get the identifier for the import
    let identifier;
    if (Node.isImportSpecifier(nameNode)) {
      // Named import
      identifier = nameNode.getNameNode();
      if (nameNode.getAliasNode()) {
        identifier = nameNode.getAliasNode();
      }
    } else {
      // Default or namespace import
      identifier = nameNode;
    }

    // Find all references using ts-morph's reference finding
    const referencedSymbols = identifier.findReferencesAsNodes();

    // Filter out the import declaration itself
    const usages = referencedSymbols.filter(ref => {
      // Check if reference is in the same file
      if (ref.getSourceFile().getFilePath() !== sourceFile.getFilePath()) {
        return false;
      }

      // Check if it's not the import declaration itself
      const parent = ref.getParent();
      if (Node.isImportSpecifier(parent) ||
          Node.isImportClause(parent) ||
          Node.isNamespaceImport(parent)) {
        return false;
      }

      return true;
    });

    // For type-only imports, also check if used in type positions
    if (isTypeOnly && usages.length === 0) {
      // Check type references
      const typeReferences = this.findTypeReferences(name, sourceFile);
      return typeReferences.length === 0;
    }

    return usages.length === 0;
  }

  /**
   * Find type references for type-only imports
   */
  findTypeReferences(typeName, sourceFile) {
    const typeReferences = [];

    // Find all type references
    const typeReferences_nodes = sourceFile.getDescendantsOfKind(SyntaxKind.TypeReference);

    for (const typeRef of typeReferences_nodes) {
      const typeName_node = typeRef.getTypeName();
      if (Node.isIdentifier(typeName_node) && typeName_node.getText() === typeName) {
        typeReferences.push(typeRef);
      }
    }

    return typeReferences;
  }

  /**
   * Check if a file contains JSX elements
   * Used to determine if React import is actually used (implicitly)
   */
  fileHasJSX(sourceFile) {
    // Check for JSX elements: <div>...</div>
    const jsxElements = sourceFile.getDescendantsOfKind(SyntaxKind.JsxElement);

    // Check for self-closing JSX: <Component />
    const jsxSelfClosing = sourceFile.getDescendantsOfKind(SyntaxKind.JsxSelfClosingElement);

    // Check for JSX fragments: <>...</>
    const jsxFragment = sourceFile.getDescendantsOfKind(SyntaxKind.JsxFragment);

    return jsxElements.length > 0 || jsxSelfClosing.length > 0 || jsxFragment.length > 0;
  }

  /**
   * Create violation object
   */
  createViolation(importInfo, sourceFile) {
    const { type, name, originalName, moduleSpecifier, isTypeOnly, position } = importInfo;

    let importText = '';
    if (type === 'default') {
      importText = `import ${name} from '${moduleSpecifier}'`;
    } else if (type === 'namespace') {
      importText = `import * as ${name} from '${moduleSpecifier}'`;
    } else if (type === 'named') {
      if (originalName !== name) {
        importText = `import { ${originalName} as ${name} } from '${moduleSpecifier}'`;
      } else {
        importText = `import { ${name} } from '${moduleSpecifier}'`;
      }
    }

    const typePrefix = isTypeOnly ? 'Type import' : 'Import';

    return {
      ruleId: this.ruleId,
      message: `${typePrefix} '${name}' is declared but never used`,
      severity: 'warning',
      filePath: sourceFile.getFilePath(),
      location: {
        start: {
          line: position.line,
          column: position.column
        },
        end: {
          line: importInfo.node.getEndLineNumber(),
          column: importInfo.node.getEnd() - importInfo.node.getStartLinePos() + 1
        }
      },
      context: {
        importName: name,
        importType: type,
        moduleSpecifier,
        isTypeOnly,
        suggestedFix: `Remove unused import: ${importText}`
      }
    };
  }
}

module.exports = C020TsMorphAnalyzer;
