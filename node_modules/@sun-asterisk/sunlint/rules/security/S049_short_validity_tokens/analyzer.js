/**
 * S049 Main Analyzer - Authentication tokens should have short validity periods
 * Primary: Symbol-based analysis (when available)
 * Fallback: Regex-based for all other cases
 * Command: node cli.js --rule=S049 --input=examples/rule-test-fixtures/rules/S049_short_validity_tokens --engine=heuristic
 */

const S049SymbolBasedAnalyzer = require("./symbol-based-analyzer.js");
const S049RegexBasedAnalyzer = require("./regex-based-analyzer.js");

class S049Analyzer {
  constructor(options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`ðŸ”§ [S049] Constructor called with options:`, !!options);
      console.log(
        `ðŸ”§ [S049] Options type:`,
        typeof options,
        Object.keys(options || {})
      );
    }

    this.ruleId = "S049";
    this.ruleName = "Authentication tokens should have short validity periods";
    this.description =
      "Authentication tokens (JWT, session tokens, etc.) should have appropriately short validity periods to minimize the risk of token compromise. Long-lived tokens increase the attack surface and potential impact of token theft.";
    this.semanticEngine = options.semanticEngine || null;
    this.verbose = options.verbose || false;

    // Configuration
    this.config = {
      useSymbolBased: true, // Primary approach
      fallbackToRegex: true, // Secondary approach
      regexBasedOnly: false, // Can be set to true for pure mode
    };

    // Initialize analyzers
    try {
      this.symbolAnalyzer = new S049SymbolBasedAnalyzer(this.semanticEngine);
      if (process.env.SUNLINT_DEBUG) {
        console.log(`ðŸ”§ [S049] Symbol analyzer created successfully`);
      }
    } catch (error) {
      console.error(`ðŸ”§ [S049] Error creating symbol analyzer:`, error);
    }

    try {
      this.regexAnalyzer = new S049RegexBasedAnalyzer(this.semanticEngine);
      if (process.env.SUNLINT_DEBUG) {
        console.log(`ðŸ”§ [S049] Regex analyzer created successfully`);
      }
    } catch (error) {
      console.error(`ðŸ”§ [S049] Error creating regex analyzer:`, error);
    }
  }

  /**
   * Initialize analyzer with semantic engine
   */
  async initialize(semanticEngine) {
    this.semanticEngine = semanticEngine;

    if (process.env.SUNLINT_DEBUG) {
      console.log(`ðŸ”§ [S049] Main analyzer initializing...`);
    }

    // Initialize both analyzers
    if (this.symbolAnalyzer) {
      await this.symbolAnalyzer.initialize?.(semanticEngine);
    }
    if (this.regexAnalyzer) {
      await this.regexAnalyzer.initialize?.(semanticEngine);
    }

    // Clean up if needed
    if (this.regexAnalyzer) {
      this.regexAnalyzer.cleanup?.();
    }

    if (process.env.SUNLINT_DEBUG) {
      console.log(`ðŸ”§ [S049] Main analyzer initialized successfully`);
    }
  }

  /**
   * Single file analysis method for testing
   */
  analyzeSingle(filePath, options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(`ðŸ“Š [S049] analyzeSingle() called for: ${filePath}`);
    }

    // Return result using same format as analyze method
    return this.analyze([filePath], "typescript", options);
  }

  async analyze(files, language, options = {}) {
    if (process.env.SUNLINT_DEBUG) {
      console.log(
        `ðŸ”§ [S049] analyze() method called with ${files.length} files, language: ${language}`
      );
    }

    const results = [];
    const preferredEngine = options.engine || "heuristic";

    for (const filePath of files) {
      let fileResults = [];

      try {
        // Determine analysis strategy
        let useSymbolBased = this.config.useSymbolBased && this.semanticEngine;
        
        if (preferredEngine === "regex") {
          useSymbolBased = false;
        }

        // Primary analysis: Symbol-based (when available and enabled)
        if (useSymbolBased && this.symbolAnalyzer) {
          if (process.env.SUNLINT_DEBUG) {
            console.log(`ðŸ”§ [S049] Using symbol-based analysis for: ${filePath}`);
          }
          
          try {
            fileResults = await this.symbolAnalyzer.analyze(filePath, language, options);
          } catch (error) {
            console.error(`ðŸ”§ [S049] Symbol-based analysis failed:`, error);
            fileResults = [];
          }
        }

        // Fallback analysis: Regex-based
        if ((!fileResults || fileResults.length === 0) && this.config.fallbackToRegex && this.regexAnalyzer) {
          if (process.env.SUNLINT_DEBUG) {
            console.log(`ðŸ”§ [S049] Using regex-based analysis for: ${filePath}`);
          }
          
          try {
            fileResults = await this.regexAnalyzer.analyze(filePath, language, options);
          } catch (error) {
            console.error(`ðŸ”§ [S049] Regex-based analysis failed:`, error);
            fileResults = [];
          }
        }

        // Add file results to overall results
        if (fileResults && fileResults.length > 0) {
          results.push(...fileResults);
        }

      } catch (error) {
        console.error(`ðŸ”§ [S049] Error analyzing file ${filePath}:`, error);
      }
    }

    if (process.env.SUNLINT_DEBUG) {
      console.log(`ðŸ”§ [S049] Analysis completed. Found ${results.length} issues.`);
    }

    return results;
  }

  /**
   * Clean up resources
   */
  cleanup() {
    if (this.symbolAnalyzer) {
      this.symbolAnalyzer.cleanup?.();
    }
    if (this.regexAnalyzer) {
      this.regexAnalyzer.cleanup?.();
    }
  }
}

module.exports = S049Analyzer;
