/**
 * C067 Symbol-Based Analyzer - Simplified Version
 *
 * Detects hardcoded configuration that should be externalized:
 * - API URLs/endpoints (http/https to external services)
 * - Credentials (passwords, API keys, secrets)
 * - Timeouts, retry intervals, batch sizes (only in specific contexts)
 *
 * Does NOT flag:
 * - Values in centralized config files (config.ts, constants.ts, etc.)
 * - Values from environment variables
 * - Common safe values (HTTP status codes, indices, etc.)
 * - Database field definitions, UI strings, validation messages
 */

const { Project, SyntaxKind } = require("ts-morph");

class C067SymbolBasedAnalyzer {
  constructor(semanticEngine = null) {
    this.semanticEngine = semanticEngine;
    this.verbose = false;
  }

  async initialize(semanticEngine = null) {
    if (semanticEngine) {
      this.semanticEngine = semanticEngine;
    }
    this.verbose = semanticEngine?.verbose || false;
  }

  async analyzeFileBasic(filePath, options = {}) {
    const violations = [];

    try {
      const sourceFile = this.semanticEngine.project.getSourceFile(filePath);
      if (!sourceFile) {
        return await this.analyzeFileStandalone(filePath, options);
      }

      // Skip config/constant files - they ARE the centralized config location
      if (this.isConfigFile(filePath)) {
        return violations;
      }

      const hardcodedConfigs = this.findHardcodedConfigs(sourceFile, filePath);

      for (const config of hardcodedConfigs) {
        violations.push({
          ruleId: "C067",
          message: this.createMessage(config),
          filePath: filePath,
          line: config.line,
          column: config.column,
          severity: "warning",
          category: "configuration",
          type: config.type,
          value: config.value,
          suggestion: this.getSuggestion(config.type),
        });
      }

      return violations;
    } catch (error) {
      throw error;
    }
  }

  async analyzeFileStandalone(filePath, options = {}) {
    const violations = [];

    try {
      const project = new Project({
        compilerOptions: {
          target: "ES2020",
          module: "CommonJS",
          allowJs: true,
          skipLibCheck: true,
          strict: false,
        },
        useInMemoryFileSystem: true,
      });

      const fs = require("fs");
      const path = require("path");

      if (!fs.existsSync(filePath)) {
        throw new Error(`File not found: ${filePath}`);
      }

      const fileContent = fs.readFileSync(filePath, "utf8");
      const fileName = path.basename(filePath);
      const sourceFile = project.createSourceFile(fileName, fileContent);

      // Skip config/constant files
      if (this.isConfigFile(filePath)) {
        return violations;
      }

      const hardcodedConfigs = this.findHardcodedConfigs(sourceFile, filePath);

      for (const config of hardcodedConfigs) {
        violations.push({
          ruleId: "C067",
          message: this.createMessage(config),
          filePath: filePath,
          line: config.line,
          column: config.column,
          severity: "warning",
          category: "configuration",
          type: config.type,
          value: config.value,
          suggestion: this.getSuggestion(config.type),
        });
      }

      return violations;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Check if file is a centralized config file (should be skipped)
   */
  isConfigFile(filePath) {
    const fileName = filePath.toLowerCase();

    const configPatterns = [
      // Config files
      /config\.(ts|js|json)$/,
      /\.config\.(ts|js)$/,
      /configs?\//,
      /configuration\//,

      // Constants files - centralized config location
      /constants?\.(ts|js)$/,
      /\.constants?\.(ts|js)$/,

      // Settings/defaults
      /settings\.(ts|js)$/,
      /defaults?\.(ts|js)$/,

      // Environment files
      /\.env/,
      /environment\.(ts|js)$/,

      // Test files
      /\.(test|spec)\.(ts|tsx|js|jsx)$/,
      /\/__tests__\//,
      /\/test\//,
      /\/tests\//,
      /\.mock\./,
      /\.fixture\./,
      /test-fixtures\//,

      // Entity/model files (contain DB constraints)
      /\.entity\.(ts|js)$/,
      /entities\//,

      // DTO/interface files
      /\.dto\.(ts|js)$/,
      /\.interface\.(ts|js)$/,

      // Enum files
      /\.enum\.(ts|js)$/,
      /enums\//,
    ];

    return configPatterns.some(pattern => pattern.test(fileName));
  }

  /**
   * Find hardcoded configurations - focused on real violations
   */
  findHardcodedConfigs(sourceFile, filePath) {
    const configs = [];

    sourceFile.forEachDescendant((node) => {
      // Check string literals for URLs and credentials
      if (node.getKind() === SyntaxKind.StringLiteral) {
        const config = this.analyzeStringLiteral(node, sourceFile);
        if (config) configs.push(config);
      }

      // Check numeric literals for timeouts/intervals in specific contexts
      if (node.getKind() === SyntaxKind.NumericLiteral) {
        const config = this.analyzeNumericLiteral(node, sourceFile);
        if (config) configs.push(config);
      }
    });

    return configs;
  }

  /**
   * Analyze string literals - focus on URLs and credentials
   */
  analyzeStringLiteral(node, sourceFile) {
    const value = node.getLiteralValue();
    const position = sourceFile.getLineAndColumnAtPos(node.getStart());

    // Skip short strings
    if (value.length < 5) return null;

    // Skip common safe patterns
    if (this.isSafeString(value, node)) return null;

    // 1. Detect hardcoded API URLs (http/https URLs)
    if (this.isHardcodedUrl(value, node)) {
      return {
        type: "api_url",
        value: value.length > 60 ? value.substring(0, 60) + "..." : value,
        line: position.line,
        column: position.column,
      };
    }

    // 2. Detect hardcoded credentials
    const credentialType = this.detectCredential(value, node);
    if (credentialType) {
      return {
        type: credentialType,
        value: this.maskValue(value),
        line: position.line,
        column: position.column,
      };
    }

    return null;
  }

  /**
   * Check if string is a hardcoded URL that should be externalized
   */
  isHardcodedUrl(value, node) {
    // Must be HTTP/HTTPS URL
    if (!value.match(/^https?:\/\//i)) return false;

    // Skip localhost/127.0.0.1 - these are often dev defaults
    if (value.match(/localhost|127\.0\.0\.1|0\.0\.0\.0/i)) return false;

    // Skip placeholder/example URLs
    if (value.match(/example\.com|placeholder|test\.com|sample\.com/i)) return false;

    // Skip documentation URLs
    if (value.match(/docs\.|documentation|readme|github\.com|stackoverflow/i)) return false;

    // Skip XML/SVG namespace URLs
    if (value.match(/w3\.org|xmlns|schema\.org/i)) return false;

    // Skip CDN/public resource URLs (fonts, icons, etc.)
    if (value.match(/fonts\.googleapis|fonts\.gstatic|cdnjs|unpkg|jsdelivr|fontawesome|cdn\./i)) return false;

    // Check parent context - skip if in safe locations
    const parent = node.getParent();
    if (parent) {
      const parentText = parent.getText().toLowerCase();

      // Skip error messages, logging
      if (parentText.match(/\berror\b|\blog\b|\bwarn\b|\binfo\b|\bdebug\b|\bmessage\b|\bdescription\b/)) return false;
    }

    // This looks like a real hardcoded API URL
    return true;
  }

  /**
   * Detect hardcoded credentials
   */
  detectCredential(value, node) {
    // Skip import paths and module paths
    if (value.includes("/") || value.startsWith("~") || value.startsWith("@")) return null;

    // Check AWS key pattern FIRST (before class name skip)
    if (value.match(/^AKIA[A-Z0-9]{16}$/)) {
      return "aws_key";
    }

    // Skip if value looks like a class name, module name, or identifier
    // But not if it's all uppercase (could be a key/secret)
    if (value.match(/^[A-Z][a-zA-Z0-9]*$/) && !value.match(/^[A-Z0-9]+$/)) return null;
    if (value.match(/^[a-z][a-zA-Z0-9]*Service$/)) return null;
    if (value.match(/^[a-z][a-zA-Z0-9]*Controller$/)) return null;
    if (value.match(/^[a-z][a-zA-Z0-9]*Module$/)) return null;

    const parent = node.getParent();
    if (!parent) return null;

    // Skip import declarations
    const grandParent = parent.getParent();
    if (grandParent) {
      const gpKind = grandParent.getKindName();
      if (gpKind === "ImportDeclaration" || gpKind === "ImportSpecifier") return null;
    }

    const parentText = parent.getText().toLowerCase();
    const parentKind = parent.getKindName();

    // Only check property assignments and variable declarations
    if (parentKind !== "PropertyAssignment" && parentKind !== "VariableDeclaration" && parentKind !== "BinaryExpression") {
      return null;
    }

    // Check if parent property name suggests credential
    const credentialPatterns = [
      { pattern: /password\s*[=:]|passwd\s*[=:]|pwd\s*[=:]/i, type: "password" },
      { pattern: /api[_-]?key\s*[=:]|apikey\s*[=:]/i, type: "api_key" },
      { pattern: /secret[_-]?key\s*[=:]|secretkey\s*[=:]|client[_-]?secret\s*[=:]/i, type: "secret" },
      { pattern: /access[_-]?token\s*[=:]|auth[_-]?token\s*[=:]/i, type: "token" },
      { pattern: /private[_-]?key\s*[=:]/i, type: "private_key" },
    ];

    for (const { pattern, type } of credentialPatterns) {
      if (pattern.test(parentText)) {
        // Skip if value is from env or config
        if (value.match(/process\.env|config\.|getenv|env\[/i)) return null;

        // Skip placeholder values (but be specific, not just starting patterns)
        if (value.match(/^(your[-_]?(password|key|secret|token)|my[-_]?(password|key|secret|token)|test[-_]?(password|key|secret|token)|placeholder|xxx+|changeme|TODO|FIXME)/i)) return null;
        if (value.match(/^(example|sample|demo)[-_]/i)) return null;

        // Skip empty or very short values
        if (value.length < 6) return null;

        return type;
      }
    }

    // Check value patterns that look like credentials
    // Connection strings with credentials
    if (value.match(/mongodb(\+srv)?:\/\/[^:]+:[^@]+@/i) ||
        value.match(/postgres:\/\/[^:]+:[^@]+@/i) ||
        value.match(/mysql:\/\/[^:]+:[^@]+@/i) ||
        value.match(/redis:\/\/:[^@]+@/i)) {
      return "connection_string";
    }

    // JWT tokens (base64 with dots)
    if (value.match(/^eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+$/)) {
      return "jwt_token";
    }

    // AWS-style keys
    if (value.match(/^AKIA[A-Z0-9]{16}$/)) {
      return "aws_key";
    }

    return null;
  }

  /**
   * Analyze numeric literals - only in specific timeout/config contexts
   */
  analyzeNumericLiteral(node, sourceFile) {
    const value = node.getLiteralValue();
    const position = sourceFile.getLineAndColumnAtPos(node.getStart());

    const parent = node.getParent();
    if (!parent) return null;

    const parentText = parent.getText().toLowerCase();
    const grandParent = parent.getParent();
    const grandParentText = grandParent ? grandParent.getText().toLowerCase() : "";

    // Check specific config patterns FIRST (before safe number check)
    // This allows us to detect batch_size: 1000 even though 1000 is normally "safe"

    // Only flag numbers in specific configuration contexts
    // 1. Timeout configurations (must be in setTimeout context or named as timeout)
    if (this.isTimeoutConfig(value, parentText, grandParentText)) {
      return {
        type: "timeout",
        value: value,
        line: position.line,
        column: position.column,
      };
    }

    // 2. Retry configurations
    if (this.isRetryConfig(value, parentText, grandParentText)) {
      return {
        type: "retry_config",
        value: value,
        line: position.line,
        column: position.column,
      };
    }

    // 3. Batch size configurations
    if (this.isBatchConfig(value, parentText, grandParentText)) {
      return {
        type: "batch_size",
        value: value,
        line: position.line,
        column: position.column,
      };
    }

    return null;
  }

  /**
   * Check if number is a timeout configuration
   */
  isTimeoutConfig(value, parentText, grandParentText) {
    // Must be a reasonable timeout value (1000ms - 5min)
    if (value < 1000 || value > 300000) return false;

    // Common timeout patterns
    const timeoutPatterns = [
      /timeout\s*[=:]/,
      /\.timeout\s*=/,
      /connectiontimeout/,
      /requesttimeout/,
      /sockettimeout/,
    ];

    return timeoutPatterns.some(p => p.test(parentText) || p.test(grandParentText));
  }

  /**
   * Check if number is a retry configuration
   */
  isRetryConfig(value, parentText, grandParentText) {
    const context = parentText + " " + grandParentText;

    const retryPatterns = [
      /retry[_-]?count\s*[=:]/,
      /max[_-]?retries?\s*[=:]/,
      /retry[_-]?interval\s*[=:]/,
      /retry[_-]?delay\s*[=:]/,
      /backoff/,
    ];

    return retryPatterns.some(p => p.test(context));
  }

  /**
   * Check if number is a batch size configuration
   */
  isBatchConfig(value, parentText, grandParentText) {
    // Batch sizes (typically 50-10000)
    if (value < 50 || value > 100000) return false;

    // Skip unit conversion constants (1024 for KB, MB, GB conversions)
    // These appear in expressions like: * 1024 * 1024
    if (value === 1024 || value === 2048 || value === 4096) {
      // Check if this is used in multiplication (unit conversion)
      if (parentText.includes('*') && parentText.includes('1024')) {
        return false;
      }
    }

    const context = parentText + " " + grandParentText;

    const batchPatterns = [
      /batch[_-]?size\s*[=:]/,
      /page[_-]?size\s*[=:]/,
      /chunk[_-]?size\s*[=:]/,
    ];

    return batchPatterns.some(p => p.test(context));
  }

  /**
   * Check if string value is safe (not a violation)
   */
  isSafeString(value, node) {
    // Skip relative paths
    if (value.startsWith("./") || value.startsWith("../") || value.startsWith("/")) return true;

    // Skip common safe strings
    const safePatterns = [
      // File extensions, MIME types
      /^\.(ts|js|json|html|css|xml|yaml|yml|md|txt)$/i,
      /^(application|text|image|video|audio)\//,

      // HTTP methods, headers
      /^(GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS)$/,
      /^(OK|Created|Not Found|Unauthorized|Forbidden)$/i,
      /^(Content-Type|Authorization|Accept|User-Agent)$/i,

      // Common field names, identifiers (lowercase only, not uppercase keys)
      /^[a-z_][a-z0-9_]*$/,

      // Date/time formats
      /^(YYYY|MM|DD|HH|mm|ss|ISO|UTC)/,

      // Color codes
      /^#[0-9a-f]{3,8}$/i,

      // Empty or whitespace
      /^\s*$/,

      // SQL/ORM keywords
      /^(ASC|DESC|NULL|NOT NULL|PRIMARY|UNIQUE|FOREIGN|INDEX)$/i,

      // Common string values
      /^(true|false|null|undefined|none|default)$/i,
    ];

    if (safePatterns.some(p => p.test(value))) return true;

    // Skip if value looks like an enum value or constant
    if (value === value.toUpperCase() && value.match(/^[A-Z_]+$/)) return true;

    return false;
  }

  /**
   * Check if number is a safe common value
   */
  isSafeNumber(value) {
    // Common safe numbers
    const safeNumbers = [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
      100, 200, 201, 204, 301, 302, 304, 400, 401, 403, 404, 500, 502, 503, // HTTP status
      1000, // Common multiplier
      -1, // Common sentinel
    ];

    if (safeNumbers.includes(value)) return true;

    // Skip small numbers (likely indices, counts)
    if (value >= 0 && value <= 100) return true;

    // Skip round numbers that are likely safe constants
    if (value % 1000 === 0 && value <= 10000) return true;

    return false;
  }

  /**
   * Mask sensitive values for display
   */
  maskValue(value) {
    if (value.length <= 8) {
      return "*".repeat(value.length);
    }
    return value.substring(0, 3) + "*".repeat(Math.min(value.length - 6, 20)) + value.substring(value.length - 3);
  }

  /**
   * Create violation message
   */
  createMessage(config) {
    const messages = {
      api_url: `Hardcoded API URL '${config.value}' should be externalized to environment variables or config file`,
      password: `Hardcoded password detected. Move to secure environment variable`,
      api_key: `Hardcoded API key detected. Move to secure environment variable`,
      secret: `Hardcoded secret detected. Move to secure environment variable`,
      token: `Hardcoded token detected. Move to secure environment variable`,
      private_key: `Hardcoded private key detected. Move to secure environment variable`,
      connection_string: `Hardcoded connection string with credentials. Move to environment variable`,
      jwt_token: `Hardcoded JWT token detected. This should be dynamically generated`,
      aws_key: `Hardcoded AWS key detected. Move to secure environment variable`,
      timeout: `Timeout value ${config.value}ms should be configurable via environment or config file`,
      retry_config: `Retry configuration value ${config.value} should be externalized`,
      batch_size: `Batch size ${config.value} should be configurable`,
    };

    return messages[config.type] || `Hardcoded configuration value should be externalized`;
  }

  /**
   * Get suggestion for fixing the violation
   */
  getSuggestion(type) {
    const suggestions = {
      api_url: "Use environment variable: process.env.API_URL or config.apiUrl",
      password: "Use environment variable: process.env.DB_PASSWORD",
      api_key: "Use environment variable: process.env.API_KEY",
      secret: "Use environment variable: process.env.SECRET_KEY",
      token: "Use environment variable or secure token storage",
      private_key: "Use environment variable or secure key management",
      connection_string: "Use environment variable: process.env.DATABASE_URL",
      jwt_token: "Generate tokens dynamically, do not hardcode",
      aws_key: "Use AWS credential provider or environment variables",
      timeout: "Move to config: config.timeout or process.env.TIMEOUT",
      retry_config: "Move to config: config.retryCount or process.env.MAX_RETRIES",
      batch_size: "Move to config: config.batchSize or process.env.BATCH_SIZE",
    };

    return suggestions[type] || "Externalize to environment variable or config file";
  }
}

module.exports = C067SymbolBasedAnalyzer;
