/**
 * S006 Symbol-Based Analyzer - No Plaintext Recovery/Activation Codes
 *
 * Uses ts-morph AST analysis to detect plaintext recovery/activation codes
 * in various contexts: API responses, logging, email templates, etc.
 */

const { SyntaxKind } = require("ts-morph");

class S006SymbolBasedAnalyzer {
  constructor(semanticEngine = null) {
    this.semanticEngine = semanticEngine;
    this.ruleId = "S006";

    // Sensitive code-related identifiers (security/auth related only)
    this.sensitiveIdentifiers = new Set([
      "activationcode",
      "recoverycode",
      "resetcode",
      "verificationcode",
      "confirmationcode",
      "otp",
      "otpcode",
      "totp",
      "pin",
      "pincode",
      // Removed generic "code" - too many false positives with business codes
      // Only specific security-related codes above
      "secret",
      "password",
      "passphrase",
    ]);

    // Business/technical identifiers that should NOT be flagged (not security codes)
    this.safeBusinessIdentifiers = new Set([
      "statuscode",
      "httpstatuscode",
      "errorcode",
      "responsecode",
      "agencycode",
      "companycode",
      "groupcode",        // Group identifier (business code)
      "teamcode",         // Team identifier
      "organizationcode", // Organization identifier
      "secretariat",      // Secretariat role/position name (not a secret code)
      "eventcode",
      "productcode",
      "itemcode",
      "categorycode",
      "departmentcode",
      "locationcode",
      "branchcode",
      "regioncode",
      "countrycode",
      "languagecode",
      "currencycode",
      "timecode",
      "zipcode",
      "postalcode",
      "areacode",
      "dialcode",
      "apiname",
      "adminapiname",
      "appinstall",
      "externalpointeventid", // External point system event identifier
      "externalserviceid", // External service identifier
      "pointstatus", // User point status (business state, not security code)
      "memberstatus", // User member status
      "friendshipstatus", // User friendship status
      "groupinvoicedetailid", // Invoice detail identifier (business ID, not security code)
      "invoiceid", // Invoice identifier
      "orderid", // Order identifier
      "detailid", // Detail record identifier
      "transactionid", // Transaction identifier
      "paymentid", // Payment identifier
      "subscriptionid", // Subscription identifier
      "customerid", // Customer identifier
      "userid", // User identifier (not sensitive in business context)
      "accountid", // Account identifier
      // API/Endpoint related (not sensitive codes)
      "generateotpapi", // API endpoint name
      "adduserbyemailnopasswordapi", // API endpoint name
      "setpasswordurl", // URL configuration
      "responseotp", // Response field name in config
      "apidocsauthbasicpassword", // API docs authentication (config)
      "basicauthpassword", // Basic auth config (not actual password)
      // Time/interval configurations (not sensitive codes)
      "dedupinginterval", // SWR deduping interval
      "refreshinterval", // Refresh interval
      "retryinterval", // Retry interval
      "pollinginterval", // Polling interval
      "timeoutinterval", // Timeout interval
      // Message/validation constants (not actual codes/passwords)
      "invalidpassword", // Error message constant
      "incorrectpassword", // Error message constant
      "incorrectcurrentpassword", // Error message constant
      "confirmationpasswordnotmatch", // Error message constant
      // Form input fields (user input, not server response with actual codes)
      // Note: These are commonly used as field names in registration/verification forms
      // The actual verification should happen server-side with hashed codes
      // Database metadata fields (counters, flags, not sensitive data)
      "failedpasswordattempts", // Password attempt counter
      "failedloginattempts", // Login attempt counter
      "passwordattempts", // Attempt counter
      "loginattempts", // Attempt counter
      // Swagger/Validation schema properties (not actual data)
      "ispassword", // Swagger schema validation flag
      "isotp", // Swagger schema validation flag
      "isotpcode", // Swagger schema validation flag
      "isactivationcode", // Swagger schema validation flag
      "isverificationcode", // Swagger schema validation flag
      // Validation constants
      "password_min_length", // Validation constant
      "password_max_length", // Validation constant
      "otp_length", // Validation constant
      "code_length", // Validation constant
    ]);

    // Safe password-related patterns (template names, route names, form fields, not actual passwords)
    this.safePasswordPatterns = [
      "forgotpassword",
      "resetpassword",
      "changepassword",
      "updatepassword",
      "passwordreset",
      "passwordchange",
      "passwordupdate",
      "passwordrecovery",
      "registerpassword", // Registration route/form
      "currentpassword", // Form field for current password
      "newpassword", // Form field for new password
      "confirmpassword", // Form field for password confirmation
      "confirmationpassword", // Form field for password confirmation
      "passwordconfirm", // Form field for password confirmation
    ];

    // Safe token types (JWT, session tokens, etc.)
    this.safeTokenTypes = new Set([
      "resettoken",
      "accesstoken",
      "refreshtoken",
      "sessiontoken",
      "authtoken",
      "jwttoken",
      "bearertoken",
    ]);

    // Transmission/exposure contexts
    this.exposureContexts = new Set([
      "send",
      "email",
      "sms",
      "text",
      "message",
      "mail",
      "push",
      "notify",
      "response",
      "body",
      "json",
      "data",
      "payload",
      "log",
      "console",
      "debug",
      "info",
      "warn",
      "error",
      "trace",
      "render",
      "template",
      "view",
      "html",
    ]);

    // Safe patterns to exclude
    this.safePatterns = [
      "hash",
      "encrypt",
      "cipher",
      "bcrypt",
      "crypto",
      "secure",
      "hashed",
      "encrypted",
      "sendsecure",
      "hashcode",
      "encryptcode",
      "savehashed",
      "storehashed",
      "validatecode",
      "verifycode",
      "checkcode",
      // Encoding operations (base64, etc.)
      "btoa", // Base64 encoding (often used with env vars for Basic Auth)
      "atob", // Base64 decoding
      "base64",
      // Parsing operations (input processing, not output exposure)
      "json.parse",
      "json.stringify",
      "parse(",
      "parseint",
      "parsefloat",
      // Audit/internal logging (not external exposure)
      "logadminpointhistory",
      "adminpointhistory",
      "auditlog",
      "systemlog",
      "internallog",
      "logger.warn", // Warning logs are typically business messages, not sensitive data exposure
      "logger.debug", // Debug logs are for development, not production exposure
      "logger.info", // Info logs are for general information
      "logger.error", // Error logs are internal, not user-facing
      // Configuration and endpoint definitions
      "config.",
      "endpoint.",
      "_url",
      "_api",
      "_endpoint",
      // Environment variables (should be managed separately)
      "process.env",
    ];

    // Safe return/response patterns (just success messages, no actual codes)
    this.safeResponsePatterns = [
      "success",
      "message",
      "sent",
      "instructions",
      "check your",
      "please enter",
      "has been sent",
      "successfully sent",
      "sent to your email",
      "sent to email",
      "sent successfully",
      "generated successfully",
    ];
  }

  async initialize(semanticEngine) {
    this.semanticEngine = semanticEngine;
  }

  async analyze(sourceFile, filePath) {
    const violations = [];

    try {
      // Skip configuration files - they contain config structures, not actual sensitive data
      if (this.isConfigFile(filePath)) {
        return violations; // Config files are safe
      }

      // Check return statements with sensitive codes
      this.checkReturnStatements(sourceFile, filePath, violations);

      // Check property assignments in objects
      this.checkObjectLiterals(sourceFile, filePath, violations);

      // Check call expressions (res.json, console.log, etc.)
      this.checkCallExpressions(sourceFile, filePath, violations);

      // Check template literals with codes
      this.checkTemplateLiterals(sourceFile, filePath, violations);

      // Check interface/type definitions
      this.checkTypeDefinitions(sourceFile, filePath, violations);

      // Removed: checkVariableDeclarations - too many false positives
      // Variables can be used safely in many contexts (hashing, validation, etc.)
    } catch (error) {
      console.warn(`⚠️ [S006] Analysis error in ${filePath}: ${error.message}`);
    }

    return violations;
  }

  /**
   * Check if file is a configuration file or Swagger schema file
   */
  isConfigFile(filePath) {
    const configPatterns = [
      "/config/",
      "/configs/",
      "/configuration/",
      "config.ts",
      "config.js",
      ".config.ts",
      ".config.js",
      "Config.ts",
      "Config.js",
      // Swagger/OpenAPI schema files - contain validation schema, not actual data
      "/swagger/",
      ".swagger.ts",
      ".swagger.js",
      "swagger.config",
      "/openapi/",
      ".openapi.ts",
      ".openapi.js",
    ];
    return configPatterns.some((pattern) => filePath.includes(pattern));
  }

  /**
   * Check return statements that expose sensitive codes
   * e.g., return { activationCode };
   */
  checkReturnStatements(sourceFile, filePath, violations) {
    const returnStatements = sourceFile.getDescendantsOfKind(
      SyntaxKind.ReturnStatement
    );

    for (const returnStmt of returnStatements) {
      const expression = returnStmt.getExpression();
      if (!expression) continue;

      // Check if returning object with sensitive properties
      if (expression.getKind() === SyntaxKind.ObjectLiteralExpression) {
        const objLiteral = expression;
        const properties = objLiteral.getProperties();

        // Skip if in infrastructure config builder function
        const parentFunc = this.findParentFunctionName(returnStmt);
        if (parentFunc) {
          const funcNameLower = parentFunc.toLowerCase();
          if (
            funcNameLower.includes("buildenv") ||
            funcNameLower.includes("getenv") ||
            funcNameLower.includes("loadenv") ||
            funcNameLower.includes("config") ||
            funcNameLower.includes("setup") ||
            funcNameLower === "env"
          ) {
            continue; // Infrastructure config builders are safe
          }
        }

        // Skip validation schemas returned from React hooks or validation builders
        // Check if this is inside a React hook (useMemo, useCallback, etc.) or validation function
        let currentParent = returnStmt.getParent();
        let isValidationContext = false;
        let depth = 0;

        while (currentParent && depth < 10) {
          const parentText = currentParent.getText().toLowerCase();

          // Check for React hooks that typically return configuration/schema objects
          if (
            parentText.startsWith("usememo(") ||
            parentText.startsWith("usecallback(") ||
            parentText.startsWith("useeffect(")
          ) {
            // Check if the returned object contains validation properties
            const returnedText = expression.getText().toLowerCase();
            if (
              returnedText.includes("validate:") ||
              returnedText.includes("validator:") ||
              returnedText.includes("rules:") ||
              returnedText.includes("onblur:") ||
              returnedText.includes("onchange:") ||
              returnedText.includes("checkRequired") ||
              returnedText.includes("checkMinLength")
            ) {
              isValidationContext = true;
              break;
            }
          }

          currentParent = currentParent.getParent();
          depth++;
        }

        if (isValidationContext) {
          continue; // Validation schema from React hook - safe
        }

        // Skip if return object contains only safe messages (success, message, etc.)
        const hasOnlySafeProperties = properties.every((prop) => {
          const name = prop.getName?.() || "";
          const normalizedName = name.toLowerCase();
          return (
            normalizedName === "success" ||
            normalizedName === "message" ||
            normalizedName === "expiresat" ||
            normalizedName === "timestamp" ||
            normalizedName === "status"
          );
        });

        if (hasOnlySafeProperties) {
          continue;
        }

        for (const prop of properties) {
          if (
            prop.getKind() === SyntaxKind.PropertyAssignment ||
            prop.getKind() === SyntaxKind.ShorthandPropertyAssignment
          ) {
            const name = prop.getName?.() || "";
            const normalizedName = this.normalizeIdentifier(name);

            // Skip statusCode - it's HTTP status code, not sensitive
            if (normalizedName === "statuscode") {
              continue;
            }

            if (
              this.isSensitiveIdentifier(normalizedName) &&
              !this.isInSafeContext(prop)
            ) {
              violations.push({
                ruleId: this.ruleId,
                severity: "error",
                message: `Returning sensitive code '${name}' in plaintext - codes should be encrypted or excluded from responses`,
                line: prop.getStartLineNumber(),
                column: prop.getStart() - prop.getStartLinePos() + 1,
                filePath: filePath,
                file: filePath,
              });
            }
          }
        }
      }
    }
  }

  /**
   * Check object literals for sensitive code exposure
   * e.g., { resetCode: code, ... }
   */
  checkObjectLiterals(sourceFile, filePath, violations) {
    const objectLiterals = sourceFile.getDescendantsOfKind(
      SyntaxKind.ObjectLiteralExpression
    );

    for (const objLiteral of objectLiterals) {
      // Skip if in safe context
      if (this.isInSafeContext(objLiteral)) continue;

      const properties = objLiteral.getProperties();

      for (const prop of properties) {
        if (prop.getKind() === SyntaxKind.PropertyAssignment) {
          const name = prop.getName?.() || "";
          const normalizedName = this.normalizeIdentifier(name);

          if (this.isSensitiveIdentifier(normalizedName)) {
            // Skip error constants, configuration objects, and form states
            const parentVarName = this.findParentVariableName(objLiteral);
            const parentVarNameUpper = parentVarName?.toUpperCase() || "";
            if (
              parentVarName &&
              (parentVarNameUpper.includes("ERROR") ||
                parentVarNameUpper.includes("ERRORS") ||
                parentVarNameUpper.includes("MESSAGE") ||
                parentVarNameUpper.includes("MESSAGES") ||
                parentVarNameUpper.includes("MAPPING") ||
                parentVarNameUpper.includes("FIELDS") ||
                parentVarNameUpper.includes("CONFIG") ||
                parentVarNameUpper.includes("CONSTANT") ||
                parentVarNameUpper.includes("ENDPOINT") ||
                parentVarNameUpper.includes("API") ||
                parentVarNameUpper.includes("URL") ||
                parentVarNameUpper.includes("ROUTE") ||
                parentVarNameUpper.includes("ROUTES") ||
                parentVarNameUpper.includes("INITIAL") ||
                parentVarNameUpper.includes("DEFAULT") ||
                parentVarNameUpper.includes("STATE") ||
                parentVarNameUpper.includes("FORM") ||
                parentVarNameUpper.includes("VALIDATION") ||
                parentVarNameUpper.includes("SCHEMA") ||
                parentVarNameUpper.includes("RULES") ||
                parentVarNameUpper.includes("PATTERN") ||
                parentVarNameUpper.includes("REGEX") ||
                parentVarNameUpper.includes("REGEXP"))
            ) {
              continue; // Error constants, configs, routes, form states, validation schemas, and regex patterns are safe
            }

            // Skip masking/sanitization utility configurations
            // These are security utilities that PROTECT sensitive data, not expose them
            if (
              parentVarName &&
              (parentVarNameUpper.includes("MASK") ||
                parentVarNameUpper.includes("SANITIZE") ||
                parentVarNameUpper.includes("REDACT") ||
                parentVarNameUpper.includes("HIDE") ||
                parentVarNameUpper.includes("OBFUSCATE"))
            ) {
              continue; // Masking/sanitization utilities are safe
            }

            // Check if inside a masking/sanitization function
            const parentFuncName = this.findParentFunctionName(objLiteral);
            const parentFuncNameUpper = parentFuncName?.toUpperCase() || "";
            if (
              parentFuncName &&
              (parentFuncNameUpper.includes("MASK") ||
                parentFuncNameUpper.includes("SANITIZE") ||
                parentFuncNameUpper.includes("REDACT") ||
                parentFuncNameUpper.includes("HIDE") ||
                parentFuncNameUpper.includes("OBFUSCATE") ||
                parentFuncNameUpper.includes("STRIP") ||
                parentFuncNameUpper.includes("REMOVE"))
            ) {
              continue; // Inside masking/sanitization function - safe
            }

            // Skip URL/endpoint configurations (e.g., set_password_url, generate_otp_api)
            if (
              normalizedName.endsWith("url") ||
              normalizedName.endsWith("api") ||
              normalizedName.endsWith("endpoint") ||
              normalizedName.includes("apiname")
            ) {
              continue; // URL/API endpoint configurations are not sensitive data
            }

            // Skip validation schema configurations
            // Check if this property's value contains validation-related properties
            const propValue = prop.getInitializer();
            if (propValue && propValue.getKind() === SyntaxKind.ObjectLiteralExpression) {
              const valueText = propValue.getText().toLowerCase();
              // If the property value contains validation keywords, it's a validation schema
              if (
                valueText.includes("validate:") ||
                valueText.includes("validator:") ||
                valueText.includes("rules:") ||
                valueText.includes("onblur:") ||
                valueText.includes("onchange:") ||
                valueText.includes("checkRequired") ||
                valueText.includes("checkMinLength") ||
                valueText.includes("checkMaxLength")
              ) {
                continue; // Validation schema configuration - safe
              }
            }

            // Skip regex pattern definitions
            // If the property value is a RegExp literal (e.g., PASSWORD: /^[a-z]+$/), it's a pattern definition
            if (propValue && propValue.getKind() === SyntaxKind.RegularExpressionLiteral) {
              continue; // Regex pattern definition - safe
            }

            // Check if in exposure context (e.g., res.json, send, etc.)
            const parent = this.findParentContext(objLiteral);
            if (parent && this.isExposureContext(parent)) {
              // Check if this is request input (not exposure)
              // Look for JSON.stringify in parent chain with body/data context
              let currentParent = parent;
              let depth = 0;
              let isRequestBody = false;
              let isFormState = false;
              let isStateDispatch = false;
              let isServiceCall = false;

              while (currentParent && depth < 10) {
                const parentText = currentParent.getText().toLowerCase();

                // Check if this is a service/API call (client sending data to server)
                // Method calls: AuthService.verify(), apiClient.post()
                if (
                  parentText.includes("service.") ||
                  parentText.includes("api.") ||
                  parentText.includes("client.") ||
                  parentText.match(/\w+service\./i)
                ) {
                  isServiceCall = true;
                  break;
                }

                // Function calls for authentication/verification (client to server)
                // e.g., confirmResetPassword(), verifyOtp(), loginUser(), registerUser()
                if (currentParent.getKind() === SyntaxKind.CallExpression) {
                  const callExpr = currentParent;
                  const expression = callExpr.getExpression();
                  const funcName = expression.getText().toLowerCase();

                  // Check if function name indicates API call
                  if (
                    funcName.includes("verify") ||
                    funcName.includes("confirm") ||
                    funcName.includes("reset") ||
                    funcName.includes("login") ||
                    funcName.includes("signup") ||
                    funcName.includes("register") ||
                    funcName.includes("authenticate") ||
                    funcName.includes("validate") ||
                    funcName.includes("check")
                  ) {
                    isServiceCall = true;
                    break;
                  }
                }

                // Check if this is state management dispatch
                // e.g., dispatch(setRegisterInfo({})), setState({})
                if (
                  parentText.includes("dispatch(") ||
                  parentText.includes("setstate") ||
                  parentText.includes("updatestate") ||
                  parentText.includes("setregister") ||
                  parentText.includes("setuser") ||
                  parentText.includes("setform")
                ) {
                  isStateDispatch = true;
                  break;
                }

                // Check if this is form state (useState, useForm, etc.)
                if (
                  parentText.includes("usestate") ||
                  parentText.includes("useform") ||
                  parentText.includes("initialstate") ||
                  parentText.includes("defaultvalues") ||
                  parentText.includes("formdata")
                ) {
                  isFormState = true;
                  break;
                }

                // Check if this object is being passed to JSON.stringify
                // and is part of a fetch/axios request body
                if (parentText.includes("json.stringify")) {
                  // Look further up for body: or data: context
                  let upperParent = currentParent.getParent();
                  let upperDepth = 0;

                  while (upperParent && upperDepth < 5) {
                    const upperText = upperParent.getText().toLowerCase();
                    if (
                      (upperText.includes("body:") ||
                        upperText.includes("data:")) &&
                      (upperText.includes("fetch") ||
                        upperText.includes("axios") ||
                        upperText.includes("method:") ||
                        upperText.includes("post") ||
                        upperText.includes("put"))
                    ) {
                      isRequestBody = true;
                      break;
                    }
                    upperParent = upperParent.getParent();
                    upperDepth++;
                  }
                }

                if (
                  isRequestBody ||
                  isFormState ||
                  isStateDispatch ||
                  isServiceCall
                )
                  break;
                currentParent = currentParent.getParent();
                depth++;
              }

              if (
                isRequestBody ||
                isFormState ||
                isStateDispatch ||
                isServiceCall
              ) {
                // This is request body, form state, state dispatch, or service call - user input data
                // Not an exposure, so skip
                continue;
              }

              // Use warning for JWT config properties (common pattern in DTOs)
              const isJwtConfig =
                normalizedName === "secret" &&
                (objLiteral.getText().includes("expiresIn") ||
                  objLiteral.getText().includes("JWT") ||
                  objLiteral.getText().includes("process.env"));

              violations.push({
                ruleId: this.ruleId,
                severity: isJwtConfig ? "warning" : "error",
                message: isJwtConfig
                  ? `Object property '${name}' in JWT config - consider refactoring signing logic to service layer`
                  : `Object property '${name}' exposes sensitive code in plaintext - use encrypted transmission or exclude from response`,
                line: prop.getStartLineNumber(),
                column: prop.getStart() - prop.getStartLinePos() + 1,
                filePath: filePath,
                file: filePath,
              });
            }
          }
        }
      }
    }
  }

  /**
   * Check call expressions like res.json(), console.log(), etc.
   * e.g., res.json({ code: verificationCode })
   */
  checkCallExpressions(sourceFile, filePath, violations) {
    const callExpressions = sourceFile.getDescendantsOfKind(
      SyntaxKind.CallExpression
    );

    for (const callExpr of callExpressions) {
      const expression = callExpr.getExpression();
      const expressionText = expression.getText().toLowerCase();

      // Skip safe methods (parsing, configuration, internal logging)
      if (
        this.safePatterns.some((pattern) => expressionText.includes(pattern))
      ) {
        continue;
      }

      // Skip parsing operations (JSON.parse, parseInt, etc.) - these are INPUT processing, not OUTPUT exposure
      if (
        expressionText.includes("parse") ||
        expressionText.includes("json.stringify") ||
        expressionText.includes(".map(") ||
        expressionText.includes(".filter(") ||
        expressionText.includes(".reduce(")
      ) {
        continue; // Data processing/transformation, not exposure
      }

      // Skip internal logging methods
      if (
        expressionText.includes("logger.") ||
        expressionText.includes("httplog") ||
        expressionText.includes("requestlog") ||
        expressionText.includes("console.debug") ||
        expressionText.includes("console.info")
      ) {
        continue; // Internal logging is not external exposure
      }

      // Skip AWS Cognito admin operations (internal service management, not client exposure)
      if (
        expressionText.includes("cognito") &&
        (expressionText.includes("adminsetuserpassword") ||
          expressionText.includes("admindeleteuser") ||
          expressionText.includes("adminresetuser") ||
          expressionText.includes("deleteuserbyemail") ||
          expressionText.includes("createuser") ||
          expressionText.includes("updateuser"))
      ) {
        continue; // AWS Cognito admin SDK calls - server-side operations, not client exposure
      }

      // Skip UI rendering functions (not data exposure)
      if (
        expressionText.startsWith("render") &&
        !expressionText.includes("response") &&
        !expressionText.includes("send") &&
        !expressionText.includes("json")
      ) {
        continue; // UI rendering components are safe
      }

      // Check for exposure methods (only actual external transmission)
      const isExposureMethod =
        expressionText.includes("res.json") ||
        expressionText.includes("res.send") ||
        expressionText.includes("response.json") ||
        expressionText.includes("response.send") ||
        expressionText.includes("email") ||
        expressionText.includes("sms") ||
        expressionText.includes("notify") ||
        expressionText.includes("ws.send") ||
        expressionText.includes("websocket.send");

      if (!isExposureMethod) continue;

      // Skip JSON.stringify in request body context (client sending code to server for verification)
      if (expressionText.includes("json.stringify")) {
        // Check if this is part of fetch/axios request body
        let parent = callExpr.getParent();
        let depth = 0;
        let isRequestBody = false;

        while (parent && depth < 10) {
          const parentText = parent.getText().toLowerCase();
          if (
            (parentText.includes("body:") || parentText.includes("data:")) &&
            (parentText.includes("fetch") ||
              parentText.includes("axios") ||
              parentText.includes("method:") ||
              parentText.includes("post"))
          ) {
            isRequestBody = true;
            break;
          }
          parent = parent.getParent();
          depth++;
        }

        if (isRequestBody) {
          continue; // Skip - this is client sending code for verification, not exposure
        }
      }

      // Check arguments for sensitive codes
      const args = callExpr.getArguments();
      for (const arg of args) {
        // Skip if argument is in safe context
        if (this.isInSafeContext(arg)) {
          continue;
        }

        // Skip safe string messages
        if (
          arg.getKind() === SyntaxKind.StringLiteral ||
          arg.getKind() === SyntaxKind.NoSubstitutionTemplateLiteral
        ) {
          const text = arg.getText().toLowerCase();
          if (
            this.safeResponsePatterns.some((pattern) => text.includes(pattern))
          ) {
            continue;
          }
        }

        if (this.containsSensitiveCode(arg)) {
          // For other methods, use general check
          const argText = arg.getText();
          const match = argText.match(
            /\b(activation|recovery|reset|verification|otp|code)\w*/i
          );
          const codeName = match ? match[0] : "sensitive code";

          // Check if this is OTP/SMS transmission (accepted functional requirement)
          const isOtpSms =
            (expressionText.includes("sendmessage") ||
              expressionText.includes("sendsms") ||
              expressionText.includes("sendotp")) &&
            (codeName.toLowerCase().includes("otp") ||
              argText.toLowerCase().includes("otp"));

          violations.push({
            ruleId: this.ruleId,
            severity: isOtpSms ? "warning" : "error",
            message: isOtpSms
              ? `OTP transmission via ${expressionText}() - ensure secure channel and proper expiration/rate limiting`
              : `Exposing '${codeName}' via ${expressionText}() - codes should not be transmitted in plaintext`,
            line: arg.getStartLineNumber(),
            column: arg.getStart() - arg.getStartLinePos() + 1,
            filePath: filePath,
            file: filePath,
          });
        }
      }
    }
  }

  /**
   * Check template literals for code exposure
   * e.g., `Your code is: ${activationCode}`
   */
  checkTemplateLiterals(sourceFile, filePath, violations) {
    const templates = sourceFile.getDescendantsOfKind(
      SyntaxKind.TemplateExpression
    );

    for (const template of templates) {
      const spans = template.getTemplateSpans();

      for (const span of spans) {
        const expression = span.getExpression();
        const expressionText = expression.getText().toLowerCase();
        const normalizedExpr = this.normalizeIdentifier(expressionText);

        // Skip JWT signing operations - these produce signed tokens (safe), not plaintext secrets
        if (
          expressionText.includes("jwtsecret") ||
          expressionText.includes("jwtsign") ||
          expressionText.includes("tokensign") ||
          expressionText.includes("sign(") ||
          expressionText.includes(".sign(")
        ) {
          continue;
        }

        // Skip safe patterns (btoa, process.env, etc.)
        if (
          this.safePatterns.some((pattern) => expressionText.includes(pattern))
        ) {
          continue; // Safe encoding/config patterns
        }

        // Skip metadata access (.name, .length, .type, etc.) - these are not sensitive data
        if (
          expressionText.includes(".name") ||
          expressionText.includes(".length") ||
          expressionText.includes(".type") ||
          expressionText.includes(".id") ||
          expressionText.includes(".status") ||
          expressionText.includes(".method")
        ) {
          continue; // Metadata properties are not sensitive codes
        }

        // Skip if this is user input data (registerInfo, formData, etc.)
        if (
          expressionText.includes("registerinfo.") ||
          expressionText.includes("formdata.") ||
          expressionText.includes("formvalues.") ||
          expressionText.includes("inputdata.")
        ) {
          continue; // User input data, not server response
        }

        if (this.isSensitiveIdentifier(normalizedExpr)) {
          // Check if in exposure context
          const parent = this.findParentContext(template);
          if (parent && this.isExposureContext(parent)) {
            // Check if this is in fetch/axios body (server-to-server API call)
            let currentParent = parent;
            let depth = 0;
            let isServerToServerCall = false;

            while (currentParent && depth < 10) {
              const parentText = currentParent.getText().toLowerCase();

              // Check if this is fetch/axios body for external API
              if (
                (parentText.includes("body:") ||
                  parentText.includes("data:")) &&
                (parentText.includes("fetch(") ||
                  parentText.includes("axios.") ||
                  parentText.includes("http.") ||
                  parentText.includes("https.") ||
                  parentText.includes("request("))
              ) {
                // Check if calling external API (not internal endpoint)
                if (
                  parentText.includes("http://") ||
                  parentText.includes("https://") ||
                  parentText.includes("api.") ||
                  parentText.includes("siteverify") ||
                  parentText.includes("oauth") ||
                  parentText.includes("recaptcha")
                ) {
                  isServerToServerCall = true;
                  break;
                }
              }

              currentParent = currentParent.getParent();
              depth++;
            }

            if (isServerToServerCall) {
              // This is server-to-server API call (e.g., verify captcha with Google)
              // Secret keys in external API calls are acceptable
              continue;
            }

            violations.push({
              ruleId: this.ruleId,
              severity: "error",
              message: `Template literal exposes sensitive code '${expression.getText()}' - avoid including codes in templates`,
              line: expression.getStartLineNumber(),
              column: expression.getStart() - expression.getStartLinePos() + 1,
              filePath: filePath,
              file: filePath,
            });
          }
        }
      }
    }
  }

  /**
   * Check interface/type definitions
   * e.g., interface Response { verificationCode: string }
   */
  checkTypeDefinitions(sourceFile, filePath, violations) {
    const interfaces = sourceFile.getDescendantsOfKind(
      SyntaxKind.InterfaceDeclaration
    );

    for (const iface of interfaces) {
      const name = iface.getName();
      const normalizedName = name.toLowerCase();

      // Skip request/input payloads - these are data sent TO the server (not exposed BY server)
      if (
        normalizedName.includes("request") ||
        normalizedName.includes("input") ||
        normalizedName.includes("update") ||
        normalizedName.includes("create") ||
        normalizedName.includes("submit") ||
        normalizedName.includes("login") ||
        normalizedName.includes("signup") ||
        normalizedName.includes("register") ||
        normalizedName.includes("change") ||
        normalizedName.includes("reset") ||
        normalizedName.includes("forgot") ||
        normalizedName.includes("verify") ||
        (normalizedName.includes("payload") &&
          (normalizedName.includes("update") ||
            normalizedName.includes("create") ||
            normalizedName.includes("input") ||
            normalizedName.includes("request")))
      ) {
        continue; // Input payloads are safe - user sends data to server
      }

      // Check if it's a response/DTO type (output from server)
      if (
        normalizedName.includes("response") ||
        normalizedName.includes("result") ||
        normalizedName.includes("output") ||
        (normalizedName.includes("dto") && !normalizedName.includes("input")) ||
        (normalizedName.includes("payload") &&
          (normalizedName.includes("response") ||
            normalizedName.includes("result") ||
            normalizedName.includes("output")))
      ) {
        const properties = iface.getProperties();

        for (const prop of properties) {
          const propName = prop.getName();
          const normalizedPropName = this.normalizeIdentifier(propName);

          if (this.isSensitiveIdentifier(normalizedPropName)) {
            violations.push({
              ruleId: this.ruleId,
              severity: "warning",
              message: `Interface '${name}' exposes sensitive property '${propName}' - consider excluding codes from response types`,
              line: prop.getStartLineNumber(),
              column: prop.getStart() - prop.getStartLinePos() + 1,
              filePath: filePath,
              file: filePath,
            });
          }
        }
      }
    }
  }

  /**
   * Check variable declarations for sensitive code handling
   */
  checkVariableDeclarations(sourceFile, filePath, violations) {
    const varDecls = sourceFile.getDescendantsOfKind(
      SyntaxKind.VariableDeclaration
    );

    for (const varDecl of varDecls) {
      const name = varDecl.getName();
      const normalizedName = this.normalizeIdentifier(name);

      if (!this.isSensitiveIdentifier(normalizedName)) continue;

      const initializer = varDecl.getInitializer();
      if (!initializer) continue;

      // Check if variable is used in exposure context
      const varStatement = varDecl.getFirstAncestorByKind(
        SyntaxKind.VariableStatement
      );
      if (!varStatement) continue;

      const scope = varStatement.getParent();
      if (!scope) continue;

      // Look for usage in exposure contexts
      const identifiers = scope.getDescendantsOfKind(SyntaxKind.Identifier);
      for (const identifier of identifiers) {
        if (identifier.getText() === name) {
          const parent = identifier.getParent();
          if (parent && this.isExposureContext(parent)) {
            violations.push({
              ruleId: this.ruleId,
              severity: "warning",
              message: `Variable '${name}' containing sensitive code is used in exposure context - ensure proper encryption`,
              line: identifier.getStartLineNumber(),
              column: identifier.getStart() - identifier.getStartLinePos() + 1,
              filePath: filePath,
              file: filePath,
            });
            break; // Only report once per variable
          }
        }
      }
    }
  }

  /**
   * Helper: Normalize identifier by removing non-alphanumeric and lowercase
   */
  normalizeIdentifier(name) {
    return name.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
  }

  /**
   * Helper: Check if identifier is sensitive
   */
  isSensitiveIdentifier(normalizedName) {
    // First check if it's a safe token type (JWT, session token, etc.)
    if (this.safeTokenTypes.has(normalizedName)) {
      return false;
    }

    // Check if it's a business/technical identifier (not security code)
    if (this.safeBusinessIdentifiers.has(normalizedName)) {
      return false;
    }

    // Check if it's a safe password pattern (template/route names, not actual passwords)
    if (
      this.safePasswordPatterns.some((pattern) =>
        normalizedName.includes(pattern)
      )
    ) {
      return false;
    }

    // Check if it ends with "token" (resetToken, authToken, etc. are secure JWT tokens)
    if (normalizedName.endsWith("token")) {
      return false;
    }

    // Check if it's just generic "code" without security context
    // Only flag if it's specifically security-related
    if (normalizedName === "code") {
      // Check if it has security context in variable name
      // e.g., "verificationCode", "otpCode" are sensitive
      // but "errorCode", "statusCode" are not
      return false; // Generic "code" alone is not sensitive
    }

    // Note: "password" as a property name in data objects IS sensitive
    // Only skip "password" in very specific safe contexts (handled by safePasswordPatterns)
    // This is checked below via sensitiveIdentifiers.has()

    // Exact match first
    if (this.sensitiveIdentifiers.has(normalizedName)) {
      return true;
    }

    // For partial match, be more strict to avoid false positives
    // Only match if sensitive word is at start or end, or clearly separated
    return Array.from(this.sensitiveIdentifiers).some((sensitive) => {
      // Skip very short words (2-3 chars) to avoid matching inside other words
      // e.g., "pin" should not match "dedupingInterval", "shopping", etc.
      if (sensitive.length <= 3) {
        // For short words, only match if:
        // 1. Exact match (already checked above)
        // 2. At start: "pin" matches "pincode", "pintester"
        // 3. At end: "pin" matches "loginpin", "resetpin"
        // 4. Standalone with separators (camelCase boundaries)
        return (
          normalizedName.startsWith(sensitive) ||
          normalizedName.endsWith(sensitive)
        );
      }

      // For longer sensitive words (4+ chars), use includes as before
      return normalizedName.includes(sensitive);
    });
  }

  /**
   * Helper: Check if node is in safe context (hashed, encrypted, etc.)
   */
  isInSafeContext(node) {
    // Check the node itself
    const nodeText = node.getText().toLowerCase();
    if (this.safePatterns.some((pattern) => nodeText.includes(pattern))) {
      return true;
    }

    // Check if it's part of a safe message response (success: true, message: "...")
    if (
      this.safeResponsePatterns.some((pattern) => nodeText.includes(pattern))
    ) {
      return true;
    }

    // Check parent context
    let current = node.getParent();
    let depth = 0;

    while (current && depth < 5) {
      const text = current.getText().toLowerCase();

      // Check for safe patterns
      if (this.safePatterns.some((pattern) => text.includes(pattern))) {
        return true;
      }

      // Check if parent is a variable with "hashed" or "encrypted" in name
      if (current.getKind() === SyntaxKind.VariableDeclaration) {
        const varName = current.getName?.() || "";
        const normalizedVarName = varName.toLowerCase();
        if (
          normalizedVarName.includes("hashed") ||
          normalizedVarName.includes("encrypted") ||
          normalizedVarName.includes("secure") ||
          normalizedVarName.includes("token")
        ) {
          return true;
        }
      }

      // Check if parent is a safe function call (e.g., sendSecure, hash, encrypt)
      if (current.getKind() === SyntaxKind.CallExpression) {
        const callExpr = current;
        const expression = callExpr.getExpression();
        const exprText = expression.getText().toLowerCase();
        if (this.safePatterns.some((pattern) => exprText.includes(pattern))) {
          return true;
        }
      }

      current = current.getParent();
      depth++;
    }

    return false;
  }

  /**
   * Helper: Find parent variable name for object literals
   */
  findParentVariableName(node) {
    let current = node.getParent();
    let depth = 0;

    while (current && depth < 5) {
      if (current.getKind() === SyntaxKind.VariableDeclaration) {
        return current.getName?.() || "";
      }
      current = current.getParent();
      depth++;
    }

    return null;
  }

  /**
   * Helper: Find parent function name for config builder detection
   */
  findParentFunctionName(node) {
    let current = node.getParent();
    let depth = 0;

    while (current && depth < 10) {
      if (
        current.getKind() === SyntaxKind.FunctionDeclaration ||
        current.getKind() === SyntaxKind.FunctionExpression ||
        current.getKind() === SyntaxKind.ArrowFunction
      ) {
        // For named functions
        const funcName = current.getName?.();
        if (funcName) return funcName;

        // For arrow functions assigned to const/let/var
        const parent = current.getParent();
        if (parent && parent.getKind() === SyntaxKind.VariableDeclaration) {
          return parent.getName?.() || "";
        }
      }
      current = current.getParent();
      depth++;
    }

    return null;
  }

  /**
   * Helper: Find parent context (call expression, return, etc.)
   */
  findParentContext(node) {
    let current = node.getParent();
    let depth = 0;

    while (current && depth < 10) {
      const kind = current.getKind();
      if (
        kind === SyntaxKind.CallExpression ||
        kind === SyntaxKind.ReturnStatement ||
        kind === SyntaxKind.VariableDeclaration
      ) {
        return current;
      }
      current = current.getParent();
      depth++;
    }

    return null;
  }

  /**
   * Helper: Check if parent context is exposure context
   */
  isExposureContext(node) {
    const text = node.getText().toLowerCase();
    return Array.from(this.exposureContexts).some((context) =>
      text.includes(context)
    );
  }

  /**
   * Helper: Check if argument contains sensitive code
   */
  containsSensitiveCode(node) {
    // PRIORITY 1: For object literals, check property names AND values
    // This prevents false positives from matching keywords in surrounding context
    if (node.getKind() === SyntaxKind.ObjectLiteralExpression) {
      const properties = node.getProperties();
      for (const prop of properties) {
        // Check property name
        const propName = prop.getName?.() || "";
        const normalizedPropName = this.normalizeIdentifier(propName);
        if (this.isSensitiveIdentifier(normalizedPropName)) {
          return true;
        }

        // ALSO check property value (important for nested structures)
        // e.g., { htmlBody: mapDataToTemplate({ password }) }
        if (prop.getKind() === SyntaxKind.PropertyAssignment) {
          const initializer = prop.getInitializer();
          if (initializer && this.containsSensitiveCode(initializer)) {
            return true;
          }
        }
      }
      return false; // Object literal checked, no sensitive props or values
    }

    // PRIORITY 2: For call expressions, recursively check arguments
    // This handles cases like mapDataToTemplate({ password })
    if (node.getKind() === SyntaxKind.CallExpression) {
      const args = node.getArguments();
      for (const arg of args) {
        if (this.containsSensitiveCode(arg)) {
          return true;
        }
      }
      return false; // Call expression checked, no sensitive args
    }

    // PRIORITY 3: For simple identifiers, check the identifier name only
    if (node.getKind() === SyntaxKind.Identifier) {
      const text = node.getText().toLowerCase();
      const normalized = this.normalizeIdentifier(text);
      return this.isSensitiveIdentifier(normalized);
    }

    // PRIORITY 4: For other node types, only check if text is short (not complex expression)
    const text = node.getText();
    if (text.length > 100) {
      // Long text likely contains surrounding context - skip to avoid false positives
      return false;
    }

    const normalized = this.normalizeIdentifier(text.toLowerCase());
    if (this.isSensitiveIdentifier(normalized)) {
      return true;
    }

    // Check template spans
    if (node.getKind() === SyntaxKind.TemplateExpression) {
      const spans = node.getTemplateSpans();
      for (const span of spans) {
        const expr = span.getExpression();
        const exprText = expr.getText().toLowerCase();
        const normalizedExpr = this.normalizeIdentifier(exprText);
        if (this.isSensitiveIdentifier(normalizedExpr)) {
          return true;
        }
      }
    }

    return false;
  }

  cleanup() {
    // No cleanup needed
  }
}

module.exports = S006SymbolBasedAnalyzer;
