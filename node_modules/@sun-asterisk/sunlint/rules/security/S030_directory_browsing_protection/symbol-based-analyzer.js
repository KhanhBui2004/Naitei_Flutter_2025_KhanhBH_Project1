/**
 * S030 Symbol-Based Analyzer - Disable directory browsing and protect sensitive metadata files
 * Enhanced to analyze static file serving configurations and middleware
 */

class S030SymbolBasedAnalyzer {
  constructor(semanticEngine) {
    this.ruleId = "S030";
    this.semanticEngine = semanticEngine;

    // Web framework static serving methods
    this.staticMethods = [
      "static",
      "serveStatic",
      "staticFiles",
      "useStaticAssets",
    ];
    this.frameworkMethods = {
      express: ["static", "use"],
      koa: ["static"],
      fastify: ["register"],
      hapi: ["route"],
      nestjs: ["useStaticAssets", "useGlobalPrefix"],
      nextjs: ["static", "use"],
    };

    // Sensitive file patterns that should be protected
    this.sensitiveFiles = [
      ".env",
      ".git",
      ".svn",
      ".hg",
      ".bzr",
      ".CVS",
      "config",
      "settings",
      "secrets",
      "keys",
      "backup",
      "database",
      ".aws",
      ".ssh",
      "credentials",
      "private",
    ];

    // Directory listing indicators (dangerous configurations)
    this.directoryListingPatterns = [
      "autoIndex",
      "directory",
      "listing",
      "browse",
      "index",
      "serveIndex",
      "list",
      "dotfiles",
      "hidden",
    ];

    // Middleware that enables directory browsing
    this.dangerousMiddleware = [
      "serveIndex",
      "serve-index",
      "directory",
      "autoIndex",
    ];
  }

  async initialize() {}

  analyze(sourceFile, filePath) {
    const violations = [];

    // Skip files that are unlikely to contain server configurations
    const skipPatterns = [
      /\.d\.ts$/,
      /\.types\.ts$/,
      /\.interface\.ts$/,
      /\.constants?\.ts$/,
      /\.spec\.(ts|tsx|js|jsx)$/,
      /\.test\.(ts|tsx|js|jsx)$/,
      /__tests__\//,          // Test directories
      /__mocks__\//,          // Mock directories
      /\.model\.ts$/,
      /\.entity\.ts$/,
      /\.dto\.ts$/,
    ];

    const shouldSkip = skipPatterns.some((pattern) => pattern.test(filePath));
    if (shouldSkip) {
      return violations;
    }

    try {
      const { SyntaxKind } = require("ts-morph");

      // Find static file serving configurations
      const callExpressions = sourceFile.getDescendantsOfKind(
        SyntaxKind.CallExpression
      );

      for (const call of callExpressions) {
        try {
          // Analyze static file serving configurations
          this.analyzeStaticFileServing(call, violations, filePath);

          // Analyze middleware registration
          this.analyzeMiddlewareUsage(call, violations, filePath);

          // Analyze route handlers for sensitive paths
          this.analyzeSensitiveRoutes(call, violations, filePath);
        } catch (error) {
          console.warn(
            `⚠ [S030] Call expression analysis failed:`,
            error.message
          );
        }
      }

      // Analyze NestJS decorators
      const decorators = sourceFile.getDescendantsOfKind(SyntaxKind.Decorator);
      for (const decorator of decorators) {
        try {
          this.analyzeNestJSDecorators(decorator, violations, filePath);
        } catch (error) {
          console.warn(`⚠ [S030] Decorator analysis failed:`, error.message);
        }
      }

      // Analyze NextJS export functions (API routes)
      const functionDeclarations = sourceFile.getDescendantsOfKind(
        SyntaxKind.FunctionDeclaration
      );
      for (const func of functionDeclarations) {
        try {
          this.analyzeNextJSAPIRoutes(func, violations, filePath);
        } catch (error) {
          console.warn(
            `⚠ [S030] NextJS API route analysis failed:`,
            error.message
          );
        }
      }

      // Check for variable declarations that might expose sensitive paths
      const variableDeclarations = sourceFile.getDescendantsOfKind(
        SyntaxKind.VariableDeclaration
      );

      for (const variable of variableDeclarations) {
        try {
          this.analyzeSensitivePathVariables(variable, violations, filePath);
        } catch (error) {
          console.warn(`⚠ [S030] Variable analysis failed:`, error.message);
        }
      }

      // Check property assignments in object literals (config objects)
      const objectLiterals = sourceFile.getDescendantsOfKind(
        SyntaxKind.ObjectLiteralExpression
      );

      for (const objLiteral of objectLiterals) {
        try {
          this.analyzeConfigurationObjects(objLiteral, violations, filePath);
        } catch (error) {
          console.warn(
            `⚠ [S030] Object literal analysis failed:`,
            error.message
          );
        }
      }
    } catch (error) {
      console.warn(
        `⚠ [S030] Symbol analysis failed for ${filePath}:`,
        error.message
      );
    }

    return violations;
  }

  analyzeStaticFileServing(call, violations, filePath) {
    const { SyntaxKind } = require("ts-morph");

    const expression = call.getExpression();
    let methodName = null;
    let objectName = null;

    // Handle property access: app.use(), express.static()
    if (expression.getKind() === SyntaxKind.PropertyAccessExpression) {
      methodName = expression.getName();
      const object = expression.getExpression();
      if (object.getKind() === SyntaxKind.Identifier) {
        objectName = object.getText();
      }
    }

    // Check for static file serving patterns
    if (this.staticMethods.includes(methodName) || methodName === "use") {
      const args = call.getArguments();

      for (const arg of args) {
        // Check if serving sensitive directories
        if (arg.getKind() === SyntaxKind.StringLiteral) {
          const path = arg.getLiteralValue();
          if (this.isSensitivePath(path)) {
            const startLine = call.getStartLineNumber();
            violations.push({
              ruleId: this.ruleId,
              message: `Static file serving exposes sensitive path '${path}' - this could leak sensitive metadata files`,
              severity: "error",
              line: startLine,
              column: 1,
            });
          }
        }

        // Check configuration objects for dangerous settings
        if (arg.getKind() === SyntaxKind.ObjectLiteralExpression) {
          this.analyzeStaticConfigObject(
            arg,
            violations,
            call.getStartLineNumber()
          );
        }
      }
    }
  }

  analyzeMiddlewareUsage(call, violations, filePath) {
    const { SyntaxKind } = require("ts-morph");

    const expression = call.getExpression();

    // Check for dangerous middleware usage
    const args = call.getArguments();
    for (const arg of args) {
      if (arg.getKind() === SyntaxKind.CallExpression) {
        const innerExpression = arg.getExpression();

        if (innerExpression.getKind() === SyntaxKind.Identifier) {
          const middlewareName = innerExpression.getText();
          if (this.dangerousMiddleware.includes(middlewareName)) {
            const startLine = call.getStartLineNumber();
            violations.push({
              ruleId: this.ruleId,
              message: `Dangerous middleware '${middlewareName}' enables directory browsing - disable or configure securely`,
              severity: "error",
              line: startLine,
              column: 1,
            });
          }
        }
      }
    }
  }

  analyzeSensitiveRoutes(call, violations, filePath) {
    const { SyntaxKind } = require("ts-morph");

    const expression = call.getExpression();

    // Check for route definitions that expose sensitive paths
    if (expression.getKind() === SyntaxKind.PropertyAccessExpression) {
      const methodName = expression.getName();
      const httpMethods = ["get", "post", "put", "delete", "patch", "all"];

      if (httpMethods.includes(methodName)) {
        const args = call.getArguments();
        if (args.length > 0 && args[0].getKind() === SyntaxKind.StringLiteral) {
          const routePath = args[0].getLiteralValue();

          if (this.isSensitivePath(routePath)) {
            const startLine = call.getStartLineNumber();
            violations.push({
              ruleId: this.ruleId,
              message: `Route '${routePath}' exposes sensitive path - implement proper access controls`,
              severity: "error",
              line: startLine,
              column: 1,
            });
          }
        }
      }
    }
  }

  analyzeStaticConfigObject(configObj, violations, lineNumber) {
    const properties = configObj.getProperties();

    for (const prop of properties) {
      if (
        prop.getKind() === require("ts-morph").SyntaxKind.PropertyAssignment
      ) {
        const name = prop.getName();
        const value = prop.getInitializer();

        // Check for dangerous configuration options
        if (this.directoryListingPatterns.includes(name)) {
          if (value && this.isTruthyValue(value)) {
            violations.push({
              ruleId: this.ruleId,
              message: `Configuration option '${name}' enables directory browsing - set to false or remove`,
              severity: "error",
              line: lineNumber,
              column: 1,
            });
          }
        }

        // Check for dotfiles configuration
        if (name === "dotfiles" && value) {
          const dotfilesValue = this.getValueAsString(value);
          if (dotfilesValue === "allow" || dotfilesValue === true) {
            violations.push({
              ruleId: this.ruleId,
              message:
                "Dotfiles access is enabled - set dotfiles to 'deny' to protect sensitive files",
              severity: "warning",
              line: lineNumber,
              column: 1,
            });
          }
        }
      }
    }
  }

  analyzeSensitivePathVariables(variable, violations, filePath) {
    const initializer = variable.getInitializer();
    const varName = variable.getName();

    if (
      initializer &&
      initializer.getKind() === require("ts-morph").SyntaxKind.StringLiteral
    ) {
      const path = initializer.getLiteralValue();

      // Skip application routes (UI paths that are not file system paths)
      // Application routes typically start with / and don't have file extensions
      // Examples: /dashboard/settings, /api/users, /admin/config
      if (this.isApplicationRoute(path)) {
        return;
      }

      if (this.isSensitivePath(path)) {
        const startLine = variable.getStartLineNumber();
        violations.push({
          ruleId: this.ruleId,
          message: `Variable '${varName}' contains sensitive path '${path}' - ensure proper access controls`,
          severity: "warning",
          line: startLine,
          column: 1,
        });
      }
    }
  }

  isApplicationRoute(path) {
    if (!path || typeof path !== "string") return false;

    // Application routes start with / and typically don't have file extensions
    // and don't start with dotfiles or contain actual file indicators
    if (path.startsWith("/")) {
      // Check if it looks like a file path vs app route
      const hasFileExtension = /\.[a-z0-9]+$/i.test(path);
      const hasDotfile = /\/\.[a-z]/i.test(path) || path.startsWith("/.");
      const hasFileIndicator = /\.(env|git|ssh|yml|yaml|json|xml|sql|log)($|\/)/i.test(path);

      // If it has file indicators, it's a file path, not an app route
      if (hasFileExtension || hasDotfile || hasFileIndicator) {
        return false;
      }

      // Otherwise, it's likely an application route
      return true;
    }

    return false;
  }

  analyzeConfigurationObjects(objLiteral, violations, filePath) {
    const properties = objLiteral.getProperties();

    for (const prop of properties) {
      if (
        prop.getKind() === require("ts-morph").SyntaxKind.PropertyAssignment
      ) {
        const name = prop.getName();
        const value = prop.getInitializer();

        // Check for configuration that might enable directory browsing
        if (
          name === "list" ||
          name === "directory" ||
          name === "autoIndex" ||
          name === "listing"
        ) {
          if (value && this.isTruthyValue(value)) {
            const startLine = prop.getStartLineNumber();
            violations.push({
              ruleId: this.ruleId,
              message: `Configuration '${name}: true' enables directory browsing - disable for security`,
              severity: "error",
              line: startLine,
              column: 1,
            });
          }
        }

        // Check for hidden files access
        if (name === "hidden") {
          if (value && this.isTruthyValue(value)) {
            const startLine = prop.getStartLineNumber();
            violations.push({
              ruleId: this.ruleId,
              message: `Configuration '${name}: true' enables hidden files access - disable for security`,
              severity: "warning",
              line: startLine,
              column: 1,
            });
          }
        }
      }
    }
  }

  isSensitivePath(path) {
    if (!path || typeof path !== "string") return false;

    // Skip application routes (URL paths that are not file references)
    if (this.isApplicationRoute(path)) {
      return false;
    }

    const normalizedPath = path.toLowerCase();

    return this.sensitiveFiles.some((sensitive) => {
      const sensitiveLower = sensitive.toLowerCase();

      // Create regex pattern to match:
      // 1. Exact match (entire path is the sensitive keyword)
      // 2. Preceded by path separator (/, ., -)
      // 3. Followed by path separator (/, ., -)
      // This prevents false positives like "settingStartDate" matching "setting"
      const pattern = new RegExp(
        `(^|[/.\-])${sensitiveLower.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}([/.\-]|$)`,
        'i'
      );

      return pattern.test(normalizedPath);
    });
  }

  isApplicationRoute(path) {
    if (!path || typeof path !== "string") return false;

    // If path starts with / and doesn't have file extensions or dotfiles, likely an app route
    if (path.startsWith("/")) {
      const hasFileExtension = /\.[a-z0-9]+$/i.test(path);
      const hasDotfile = /\/\.[a-z]/i.test(path) || path.startsWith("/.");
      const hasFileIndicator = /\.(env|git|ssh|yml|yaml|json|xml|sql|log)($|\/)/i.test(path);

      if (hasFileExtension || hasDotfile || hasFileIndicator) {
        return false; // It's a file reference
      }

      return true; // It's an application route
    }

    return false;
  }

  isTruthyValue(valueNode) {
    const { SyntaxKind } = require("ts-morph");

    if (valueNode.getKind() === SyntaxKind.TrueKeyword) return true;
    if (valueNode.getKind() === SyntaxKind.StringLiteral) {
      const value = valueNode.getLiteralValue();
      return value === "true" || value === "allow" || value === "yes";
    }
    if (valueNode.getKind() === SyntaxKind.NumericLiteral) {
      return valueNode.getLiteralValue() !== 0;
    }

    return false;
  }

  getValueAsString(valueNode) {
    const { SyntaxKind } = require("ts-morph");

    if (valueNode.getKind() === SyntaxKind.StringLiteral) {
      return valueNode.getLiteralValue();
    }
    if (valueNode.getKind() === SyntaxKind.TrueKeyword) return true;
    if (valueNode.getKind() === SyntaxKind.FalseKeyword) return false;

    return valueNode.getText();
  }

  analyzeNestJSDecorators(decorator, violations, filePath) {
    const { SyntaxKind } = require("ts-morph");

    const expression = decorator.getCallExpression();
    if (!expression) return;

    const decoratorName = expression.getExpression().getText();

    // Check for route decorators with sensitive paths
    if (["Get", "Post", "Put", "Delete", "Patch"].includes(decoratorName)) {
      const args = expression.getArguments();
      if (args.length > 0 && args[0].getKind() === SyntaxKind.StringLiteral) {
        const routePath = args[0].getLiteralValue();

        if (this.isSensitivePath(routePath)) {
          const startLine = decorator.getStartLineNumber();
          violations.push({
            ruleId: this.ruleId,
            message: `NestJS route '${routePath}' exposes sensitive path - implement proper access controls`,
            severity: "error",
            line: startLine,
            column: 1,
          });
        }
      }
    }

    // Check for Controller decorator with sensitive paths
    if (decoratorName === "Controller") {
      const args = expression.getArguments();
      if (args.length > 0 && args[0].getKind() === SyntaxKind.StringLiteral) {
        const controllerPath = args[0].getLiteralValue();

        if (this.isSensitivePath(controllerPath)) {
          const startLine = decorator.getStartLineNumber();
          violations.push({
            ruleId: this.ruleId,
            message: `NestJS controller path '${controllerPath}' exposes sensitive path - review controller design`,
            severity: "warning",
            line: startLine,
            column: 1,
          });
        }
      }
    }
  }

  analyzeNextJSAPIRoutes(func, violations, filePath) {
    const { SyntaxKind } = require("ts-morph");

    // Check if this is an exported API route function
    const exportKeyword = func
      .getFirstAncestorByKind(SyntaxKind.SourceFile)
      ?.getExportedDeclarations()
      ?.get(func.getName() || "default");

    if (!exportKeyword) return;

    // Check if function name suggests HTTP method (GET, POST, etc.)
    const funcName = func.getName();
    const httpMethods = ["GET", "POST", "PUT", "DELETE", "PATCH"];

    if (httpMethods.includes(funcName)) {
      // Check function body for actual file serving operations (not just string mentions)
      const body = func.getBody();
      if (body) {
        const bodyText = body.getText();

        // Only detect actual file operations that expose sensitive files
        // (not just variable names or env vars containing "secret", "config", etc.)
        const fileOperationPatterns = [
          // File serving operations with sensitive paths
          /(?:sendFile|readFile|writeFile|readFileSync|writeFileSync)\s*\(\s*['"`][^'"`]*(?:\.env|\.git|\.ssh|config\/|backup\/|secrets\/)[^'"`]*['"`]/g,
          /(?:express\.static|serveStatic|staticFiles)\s*\(\s*['"`][^'"`]*(?:\.env|\.git|\.ssh|config|backup|secrets)[^'"`]*['"`]/g,
          // Direct file path exposure in response
          /(?:res|response)\.send(?:File)?\s*\(\s*['"`][^'"`]*(?:\.env|\.git|\.ssh)[^'"`]*['"`]/g,
        ];

        for (const pattern of fileOperationPatterns) {
          const matches = [...bodyText.matchAll(pattern)];
          if (matches.length > 0) {
            const startLine = func.getStartLineNumber();
            violations.push({
              ruleId: this.ruleId,
              message: `NextJS API route '${funcName}' contains file operations on sensitive paths - ensure proper access controls`,
              severity: "error",
              line: startLine,
              column: 1,
            });
            break; // Only report once per function
          }
        }
      }
    }
  }

  cleanup() {}
}

module.exports = S030SymbolBasedAnalyzer;
